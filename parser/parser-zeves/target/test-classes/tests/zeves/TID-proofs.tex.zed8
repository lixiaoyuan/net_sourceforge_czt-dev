
â”€ section TID_proofs parents zeves_toolkit â”” 

\syndef{\Optional}{pregen}{Optional}
â”€ generic ( Optional _ ) â”” 

â”€ â˜“ Optional X == { x : ğ”½ X | # x â‰¤ 1 } â”” 

â”œ Optional$domainCheck 
prove by rewrite ;  
â”” 

â”€ â˜“ Nil [ X ] == âˆ… [ X ] â”” 

â”€ â˜“ The [ X ] == { x : X â¦ { x } â†¦ x } â”” 

â”€ â˜’ theorem rule lOptionalMember [ X ] 
âˆ€ m : X ; M : Optional X â¦ m âˆˆ M â‡” M = { m } 
â”” 

â”œ lOptionalMember 
invoke ( Optional _ ) ;  
apply extensionality to predicate M = { m } ;  
use cardIsNonNegative [ X ] [ S := M ] ;  
split M = { } ;  
prove by rewrite ;  
use card0 [ X ] [ S := M ] ;  
rearrange ;  
simplify ;  
simplify ;  
split âˆƒ i : â„• â¦ i = ( # _ ) [ X ] M ;  
cases ;  
prove by rewrite ;  
equality substitute ( # _ ) [ X ] M ;  
next ;  
rearrange ;  
instantiate i == 1 ;  
prove by rewrite ;  
next ;  
split Â¬ i = 1 ;  
cases ;  
split i â‰¤ 1 ;  
simplify ;  
split i â‰¥ 0 ;  
simplify ;  
next ;  
split m âˆˆ M ;  
rewrite ;  
use sizeDef [ X ] [ S := M ] ;  
prenex ;  
rearrange ;  
rewrite ;  
invoke ( _ â¤– _ ) ;  
invoke ( _ â†  _ ) ;  
invoke ( _ â†£ _ ) ;  
invoke ( _ â†’ _ ) ;  
invoke ( _ â¤€ _ ) ;  
invoke ( _ â¤” _ ) ;  
rewrite ;  
prenex ;  
invoke ( _ â‡¸ _ ) ;  
invoke ( _ â†” _ ) ;  
rewrite ;  
rearrange ;  
split ran [ { 1 } , M ] f = M ;  
rewrite ;  
equality substitute M ;  
apply inRan ;  
invoke ( _ â†” _ ) ;  
rearrange ;  
prenex ;  
rewrite ;  
instantiate y1 == m , y2 == x ;  
apply inPower to predicate f âˆˆ â„™ ( { 1 } Ã— M ) ;  
instantiate e == ( 1 , m ) ;  
instantiate e == ( 1 , x ) ;  
rearrange ;  
rewrite ;  
next ;  
split m âˆˆ M ;  
rewrite ;  
use card0 [ X ] [ S := M ] ;  
rearrange ;  
simplify ;  
â”” 

â”€ â˜’ theorem rule lOptionalWeakening [ X ] 
x âˆˆ Optional X â‡’ x âˆˆ â„™ X 
â”” 

â”œ lOptionalWeakening 
rewrite ;  
invoke ( Optional _ ) ;  
rewrite ;  
â”” 

â”€ â˜’ theorem rule lOptionalWeakening2 [ X ] 
âˆ€ S : â„™ X | x âˆˆ Optional S â¦ x âˆˆ â„™ S 
â”” 

â”œ lOptionalWeakening2 
apply lOptionalWeakening to predicate x âˆˆ â„™ S ;  
rewrite ;  
â”” 

â”€ theorem frule lOptionalFinWeakening [ X ] 
âˆ€ x : Optional X â¦ x âˆˆ ğ”½ X 
â”” 

â”œ lOptionalFinWeakening 
invoke ( Optional _ ) ;  
rewrite ;  
â”” 

â”€ â˜’ theorem rule lOptionalMemberElem [ X ] 
âˆ€ x : ğ”½ X â¦ x âˆˆ Optional X â‡” x = { } âˆ¨ ( âˆƒ y : X â¦ x = { y } ) 
â”” 

â”œ lOptionalMemberElem 
use cardIsNonNegative [ X ] [ S := x ] ;  
prove by rewrite ;  
use card0 [ X ] [ S := x ] ;  
rearrange ;  
simplify ;  
split x = { } ;  
rewrite ;  
cases ;  
invoke ( Optional _ ) ;  
rewrite ;  
next ;  
apply extensionality to predicate x = { } ;  
prove by rewrite ;  
use lOptionalMember [ X ] [ M := x , m := x__0 ] ;  
rearrange ;  
rewrite ;  
rewrite ;  
with normalization rewrite ;  
rewrite ;  
prenex ;  
rewrite ;  
cases ;  
instantiate y__0 == x__0 ;  
rewrite ;  
next ;  
rearrange ;  
split x = { y } ;  
rewrite ;  
invoke ( Optional _ ) ;  
rewrite ;  
prove by rewrite ;  
next ;  
â”” 

â”€ theorem lNonemptyOptionalMemberElem [ X ] 
âˆ€ x : Optional X | Â¬ x = { } â¦ âˆƒ y : X â¦ x = { y } 
â”” 

â”œ lNonemptyOptionalMemberElem 
use lOptionalFinWeakening [ X ] ;  
use lOptionalMemberElem [ X ] ;  
rearrange ;  
rewrite ;  
â”” 

â”€ â˜’ theorem rule lInNil [ X ] 
âˆ€ x : X â¦ Â¬ x âˆˆ Nil 
â”” 

â”œ lInNil 
invoke Nil ;  
rewrite ;  
â”” 

â”€ â˜’ theorem rule lNilSubset [ X ] 
Nil âˆˆ â„™ X 
â”” 

â”œ lNilSubset 
invoke Nil ;  
rewrite ;  
â”” 

â”€ theorem grule gTheRelType [ X ] 
The [ X ] âˆˆ â„™ X â†” X 
â”” 

â”œ gTheRelType 
invoke ( _ â†” _ ) ;  
invoke The ;  
prove by reduce ;  
â”” 

â”€ â˜’ theorem rule lTheMember [ X ] 
âˆ€ y : X â¦ x = { y } â‡’ ( x , y ) âˆˆ The [ X ] 
â”” 

â”œ lTheMember 
invoke The ;  
prove by reduce ;  
â”” 

â”€ â˜’ theorem rule lTheAppliesToDef [ X ] 
âˆ€ x : ğ”½ X | Â¬ x = { } âˆ§ x âˆˆ Optional X â¦ The [ X ] applies$to x 
â”” 

â”œ lTheAppliesToDef 
apply appliesToDef ;  
rewrite ;  
invoke The ;  
prove by rewrite ;  
apply lOptionalMemberElem ;  
prove by rewrite ;  
â”” 

â”€ theorem lBijectionFinite [ X , Y ] 
âˆ€ A : ğ”½ X ; B : â„™ Y â¦ âˆ€ f : A â¤– B â¦ f âˆˆ A â‡» B âˆ§ B âˆˆ ğ”½ Y âˆ§ # B = # A = # f 
â”” 

â”œ lBijectionFinite 
use functionFinite [ X , Y ] ;  
use finiteFunction [ X , Y ] ;  
use functionFinite [ X , Y ] [ A := X , B := Y ] ;  
use finiteFunction [ Y , X ] [ f := f ( _ âˆ¼ ) [ X , Y ] ] ;  
use functionFinite [ Y , X ] [ A := B , B := A , f := f ( _ âˆ¼ ) [ X , Y ] ] ;  
prove by rewrite ;  
â”” 

â”€ â˜’ theorem rule lNonMaximalCard [ X ] 
âˆ€ A : â„™ X â¦ âˆ€ S : ğ”½ A â¦ ( # _ ) [ A ] S = ( # _ ) [ X ] S 
â”” 

â”œ lNonMaximalCard 
use sizeDef [ X ] ;  
use sizeDef [ A ] ;  
prove by rewrite ;  
use lBijectionFinite [ â„¤ , X ] [ f := f , A := 1 .. ( # _ ) [ A ] S , B := S ] ;  
use lBijectionFinite [ â„¤ , X ] [ f := f__0 , A := 1 .. ( # _ ) [ X ] S , B := S ] ;  
with disabled ( sizeRange ) prove by rewrite ;  
use cardIsNonNegative [ A ] ;  
rearrange ;  
rewrite ;  
â”” 

â”€ â˜’ theorem rule lOptionalSubtypeWeakening [ X ] 
âˆ€ S : â„™ X | x âˆˆ Optional S â¦ x âˆˆ Optional X 
â”” 

â”œ lOptionalSubtypeWeakening 
invoke ( Optional _ ) ;  
rewrite ;  
use lNonMaximalCard [ X ] [ A := S , S := x ] ;  
rearrange ;  
rewrite ;  
â”” 

â”€ theorem grule gTheMaxType [ X ] 
The [ X ] âˆˆ â„™ X â‡¸ X 
â”” 

â”œ gTheMaxType 
invoke The ;  
invoke ( _ â‡¸ _ ) ;  
invoke ( _ â†” _ ) ;  
prove by rewrite ;  
â”” 

â”€ theorem rule lNilNotInThe [ X ] 
Â¬ Nil [ X ] âˆˆ dom The [ X ] 
â”” 

â”œ lNilNotInThe 
apply inDom ;  
rewrite ;  
invoke The ;  
invoke Nil ;  
rewrite ;  
â”” 

â”€ theorem rule lNilIsOptional [ X ] 
âˆ€ A : â„™ X â¦ { } âˆˆ Optional A 
â”” 

â”œ lNilIsOptional 
invoke ( Optional _ ) ;  
rewrite ;  
â”” 

â”€ theorem rule lInTheDomain [ X ] 
âˆ€ x : Optional X | Â¬ x = Nil â¦ x âˆˆ dom The 
â”” 

â”œ lInTheDomain 
apply inDom to predicate x âˆˆ dom [ ( â„™ X ) , X ] The [ X ] ;  
rewrite ;  
invoke The ;  
invoke Nil ;  
apply lOptionalMemberElem ;  
prove by rewrite ;  
â”” 

â”€ theorem rule lOptionalSubtying [ X ] 
âˆ€ A : â„™ X â¦ âˆ€ x : Optional A â¦ x âˆˆ Optional X 
â”” 

â”œ lOptionalSubtying 
invoke ( Optional _ ) ;  
rewrite ;  
use lNonMaximalCard [ X ] [ S := x ] ;  
prove by rewrite ;  
â”” 

â”€ â˜’ theorem rule lOptionalWeakening3 [ X ] 
âˆ€ S : â„™ X | x âˆˆ Optional S â¦ x âˆˆ â„™ X 
â”” 

â”œ lOptionalWeakening3 
apply lOptionalWeakening to predicate x âˆˆ â„™ X ;  
rewrite ;  
â”” 

â”€ â˜’ theorem rule lTheAppliesElem [ X ] 
âˆ€ x : X â¦ The [ X ] { x } = x 
â”” 

â”œ lTheAppliesElem 
use lInTheDomain [ X ] [ x := { x } ] ;  
apply inDom to predicate { x } âˆˆ dom [ ( â„™ X ) , X ] The [ X ] ;  
rearrange ;  
invoke Nil ;  
invoke ( Optional _ ) ;  
rewrite ;  
prenex ;  
use pairInFunction [ â„™ X , X ] [ f := The [ X ] , x := { x } , y := y ] ;  
prove by rewrite ;  
equality substitute The [ X ] { x } ;  
invoke The ;  
rewrite ;  
â”” 

â”€ theorem rule lTheResultType [ X ] 
âˆ€ S : Optional X | Â¬ S = { } â¦ The [ X ] S âˆˆ X 
â”” 

â”œ lTheResultType 
apply lOptionalMemberElem ;  
prove by rewrite ;  
apply lTheAppliesElem ;  
prove by rewrite ;  
â”” 

â”€ theorem rule lElemDiffAbsorption [ X ] 
âˆ€ x : X ; S : â„™ X | Â¬ x âˆˆ S â¦ S âˆ– { x } = S 
â”” 

â”œ lElemDiffAbsorption 
apply extensionality ;  
prove by rewrite ;  
â”” 

â”€ TIME == â„• â”” 

â”€ zeroTime == 0 â”” 

â”€ PRESENCE ::= present | absent â”” 

â”€ CLASS ::= unmarked | unclassified | restricted | confidential | secret | topsecret â”” 

â”Œ Clearance 
class : CLASS â”” 

â•· minClearance : Clearance Ã— Clearance â†’ Clearance â”” 

â”€ PRIVILEGE ::= userOnly | guard | securityOfficer | auditManager â”” 

â”€ [ USER ] â”” 

â•· ISSUER : â„™ USER â”” 

â”€ [ FINGERPRINT ] â”” 

â”€ [ FINGERPRINTTEMPLATE ] â”” 

â”Œ FingerprintTemplate 
template : FINGERPRINTTEMPLATE â”” 

â”€ [ KEYPART ] â”” 

â”Œ CertificateId 
issuer : ISSUER â”” 

â”Œ Certificate 
cid : CertificateId 
validityPeriod : â„™ TIME 
isValidatedBy : Optional KEYPART â”” 

â”Œ IDCert 
Certificate 
subject : USER 
subjectPubK : KEYPART â”” 

â”Œ CAIdCert 
IDCert |
 isValidatedBy = { subjectPubK } â”” 

â”€ [ TOKENID ] â”” 

â”Œ AttCertificate 
Certificate 
baseCertId : CertificateId 
tokenID : TOKENID â”” 

â”Œ PrivCert 
AttCertificate 
role : PRIVILEGE 
clearance : Clearance â”” 

â”Œ AuthCert 
AttCertificate 
role : PRIVILEGE 
clearance : Clearance â”” 

â”Œ IandACert 
AttCertificate 
template : FingerprintTemplate â”” 

â”Œ Token 
tokenID : TOKENID 
idCert : IDCert 
privCert : PrivCert 
iandACert : IandACert 
authCert : Optional AuthCert â”” 

â”Œ ValidToken 
Token |
 privCert . baseCertId = idCert . cid 
iandACert . baseCertId = idCert . cid 
privCert . tokenID = tokenID 
iandACert . tokenID = tokenID â”” 

â”Œ TokenWithValidAuth 
Token |
 authCert â‰  Nil âˆ§ ( The authCert ) . tokenID = tokenID âˆ§ ( The authCert ) . baseCertId = idCert . cid â”” 

â”œ TokenWithValidAuth$domainCheck 
invoke Token ;  
prove by rewrite ;  
apply lInTheDomain to predicate authCert âˆˆ dom The ;  
rewrite ;  
use lOptionalSubtying [ â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; clearance : â¦‰ class : CLASS â¦Š ; isValidatedBy : â„™ KEYPART ; role : PRIVILEGE ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ] [ A := AuthCert , x := authCert ] ;  
prove by rewrite ;  
â”” 

â”Œ TokenWithValidAuth0 
Token 
ac : AuthCert |
 authCert â‰  Nil 
The authCert = ac 
tokenID = ac . tokenID 
idCert . cid = ac . baseCertId â”” 

â”œ TokenWithValidAuth0$domainCheck 
apply lTheAppliesToDef ;  
prove by rewrite ;  
â”” 

â”€ TokenWithValidAuth1 == TokenWithValidAuth0 âˆ– ( ac ) â”” 

â”€ â˜’ theorem rule lTokenWithValidAuthEquiv 
TokenWithValidAuth â‡” TokenWithValidAuth1 
â”” 

â”œ lTokenWithValidAuthEquiv 
split TokenWithValidAuth ;  
cases ;  
with enabled ( PrivCert$inSet , AuthCert$member , Nil ) prove by reduce ;  
apply lOptionalMemberElem ;  
prove by rewrite ;  
apply lTheAppliesElem ;  
prove by rewrite ;  
with enabled ( lOptionalWeakening , AuthCert$member ) prove by reduce ;  
next ;  
split TokenWithValidAuth1 ;  
with enabled ( PrivCert$inSet , AuthCert$member , Nil ) prove by reduce ;  
next ;  
â”” 

â”Œ CurrentToken 
ValidToken 
now : TIME |
 now âˆˆ idCert . validityPeriod âˆ© privCert . validityPeriod âˆ© iandACert . validityPeriod â”” 

â”Œ Enrol 
idStationCert : IDCert 
issuerCerts : â„™ IDCert |
 idStationCert âˆˆ issuerCerts â”” 

â”Œ ValidEnrol 
Enrol |
 issuerCerts âˆ© { CAIdCert | true } â‰  âˆ… 
âˆ€ cert : issuerCerts â¦ cert . isValidatedBy â‰  Nil âˆ§ ( âˆƒ issuerCert : issuerCerts â¦ ( issuerCert âˆˆ CAIdCert âˆ§ The cert . isValidatedBy = issuerCert . subjectPubK âˆ§ cert . cid . issuer = issuerCert . subject ) ) â”” 

â”œ ValidEnrol$domainCheck 
rewrite ;  
apply lInTheDomain to predicate cert . isValidatedBy âˆˆ dom The ;  
rewrite ;  
invoke Enrol ;  
apply inPower to predicate issuerCerts âˆˆ â„™ IDCert ;  
instantiate e == cert ;  
apply IDCert$member to predicate cert âˆˆ IDCert ;  
prove by rewrite ;  
â”” 

â”€ DOOR ::= open | closed â”” 

â”€ LATCH ::= unlocked | locked â”” 

â”€ ALARM ::= silent | alarming â”” 

â”€ DISPLAYMESSAGE ::= blank | welcome | insertFinger | openDoor | wait | removeToken | tokenUpdateFailed | doorUnlocked â”” 

â”€ FINGERPRINTTRY ::= noFP | badFP | goodFP âŸª FINGERPRINT âŸ« â”” 

â”€ TOKENTRY ::= noT | badT | goodT âŸª Token âŸ« â”” 

â”€ [ Audit ] â”” 

\The next constant must be $\nat_1$, otherwise $Config$ is infeasible.
â•· maxSupportedLogSize : â„•â†˜1â†– â”” 

â”Œ Config 
alarmSilentDuration , latchUnlockDuration : TIME 
tokenRemovalDuration : TIME 
enclaveClearance : Clearance 
authPeriod : PRIVILEGE â†’ TIME â†’ â„™ TIME 
entryPeriod : PRIVILEGE â†’ CLASS â†’ â„™ TIME 
minPreservedLogSize : â„• 
alarmThresholdSize : â„• |
 alarmThresholdSize < minPreservedLogSize 
minPreservedLogSize â‰¤ maxSupportedLogSize â”” 

â”€ FLOPPY ::= noFloppy | emptyFloppy | badFloppy | enrolmentFile âŸª ValidEnrol âŸ« | auditFile âŸª ğ”½ Audit âŸ« | configFile âŸª Config âŸ« â”” 

â”€ ADMINOP ::= archiveLog | updateConfigData | overrideLock | shutdownOp â”” 

â”€ KEYBOARD ::= noKB | badKB | keyedOps âŸª ADMINOP âŸ« â”” 

â”Œ Stats 
successEntry : â„• 
failEntry : â„• 
successBio : â„• 
failBio : â„• â”” 

â”€ SCREENTEXT ::= clear | welcomeAdmin | busy | removeAdminToken | closeDoor | requestAdminOp | doingOp | invalidRequest | invalidData | insertEnrolmentData | validatingEnrolmentData | enrolmentFailed | archiveFailed | insertBlankFloppy | insertConfigData | displayStats âŸª Stats âŸ« | displayConfigData âŸª Config âŸ« â”” 

â”Œ Screen 
screenStats : SCREENTEXT 
screenMsg : SCREENTEXT 
screenConfig : SCREENTEXT â”” 

â”Œ TISControlledRealWorld 
latch : LATCH 
alarm : ALARM 
display : DISPLAYMESSAGE 
screen : Screen â”” 

â”Œ TISMonitoredRealWorld 
now : TIME 
door : DOOR 
finger : FINGERPRINTTRY 
userToken , adminToken : TOKENTRY 
floppy : FLOPPY 
keyboard : KEYBOARD â”” 

â”€ RealWorld == TISControlledRealWorld âˆ§ TISMonitoredRealWorld â”” 

Function $sizeLog$ is not well defined originally. It doesn't have
a case for when $entry \neq log$, despite being a total function.
Also, if we assume a naive interpretation for this case, where the
entry's size is simply ignored (as given below), then the axiom is
inconsistent because $sizeLog$ might never terminate (e.g., until we
find an $entry \in log$, which might take unbounded amounts of time).
â•· sizeElement0 : Audit â†’ â„• 
sizeLog0 : ğ”½ Audit â†’ â„• |
 ã€Š disabled rule dSizeLogEmpty0 ã€‹ sizeLog0 âˆ… = 0 
ã€Š disabled rule dSizeLog0 ã€‹ âˆ€ log : ğ”½ Audit ; entry : Audit â¦ sizeLog0 log = if ( entry âˆˆ log ) then sizeLog0 ( log âˆ– { entry } ) + sizeElement0 entry else sizeLog0 log â”” 

â”œ unnamedn3$domainCheck 
prove by rewrite ;  
â”” 

â•· sizeElement : Audit â†’ â„• 
sizeLog : ğ”½ Audit â†’ â„• |
 ã€Š disabled rule dSizeLogBase ã€‹ sizeLog { } = 0 
ã€Š disabled rule dSizeLogInduc ã€‹ âˆ€ log : ğ”½ Audit ; entry : Audit â¦ sizeLog ( { entry } âˆª log ) = sizeElement entry + sizeLog ( log âˆ– { entry } ) â”” 

â”œ unnamedn4$domainCheck 
prove by rewrite ;  
â”” 

â”Œ AuditLog 
auditLog : ğ”½ Audit 
auditAlarm : ALARM â”” 

â•· oldestLogTime : ğ”½ Audit â†’ TIME 
newestLogTime : ğ”½ Audit â†’ TIME |
 ã€Š disabled rule dNewestLogTime ã€‹ âˆ€ A , B : ğ”½ Audit â¦ newestLogTime ( A âˆª B ) â‰¥ newestLogTime A 
ã€Š disabled rule dOldestLogTime ã€‹ âˆ€ C , D : ğ”½ Audit â¦ oldestLogTime ( C âˆª D ) â‰¤ oldestLogTime C â”” 

â”œ unnamedn5$domainCheck 
prove by reduce ;  
â”” 

â”Œ KeyStore 
issuerKey : ISSUER â‡¸ KEYPART 
ownName : Optional ISSUER |
 ownName â‰  Nil â‡’ The ownName âˆˆ dom issuerKey â”” 

â”œ KeyStore$domainCheck 
rewrite ;  
â”” 

â”€ ADMINPRIVILEGE == { guard , auditManager , securityOfficer } â”” 

â”€ theorem grule gAdminPriviledgeIsPriviledge 
ADMINPRIVILEGE âˆˆ â„™ PRIVILEGE 
â”” 

â”œ gAdminPriviledgeIsPriviledge 
prove by reduce ;  
â”” 

â”Œ Admin 
rolePresent : Optional ADMINPRIVILEGE 
availableOps : â„™ ADMINOP 
currentAdminOp : Optional ADMINOP |
 rolePresent = Nil â‡’ availableOps = âˆ… 
rolePresent â‰  Nil âˆ§ The rolePresent = guard â‡’ availableOps = { overrideLock } 
rolePresent â‰  Nil âˆ§ The rolePresent = auditManager â‡’ availableOps = { archiveLog } 
rolePresent â‰  Nil âˆ§ The rolePresent = securityOfficer â‡’ availableOps = { updateConfigData , shutdownOp } 
currentAdminOp â‰  Nil â‡’ The currentAdminOp âˆˆ availableOps âˆ§ rolePresent â‰  Nil â”” 

This an other proofs (commented above) are much simpler thanks to
the enabled rewrite rules in backward chaining:lInTheDomain,
lOptionalSubtying; and in forward chaining :lOptionalFinWeakening.
â”œ Admin$domainCheck 
rewrite ;  
â”” 

\The next lemma is logically equivalent to $Admin$'s invariant, yet in a form
that we find more intuitive, and also it is easier to do proof with (e.g., it leads
to less case splits).
â”€ theorem lAdminInvLemma 
âˆ€ Admin â¦ ( rolePresent = Nil âˆ§ availableOps = Nil âˆ§ currentAdminOp = Nil ) âˆ¨ ( rolePresent â‰  Nil âˆ§ availableOps â‰  Nil âˆ§ ( currentAdminOp â‰  Nil â‡’ The currentAdminOp âˆˆ availableOps ) âˆ§ ( The rolePresent = guard â‡’ availableOps = { overrideLock } ) âˆ§ ( The rolePresent = auditManager â‡’ availableOps = { archiveLog } ) âˆ§ ( The rolePresent = securityOfficer â‡’ availableOps = { updateConfigData , shutdownOp } ) ) 
â”” 

â”œ lAdminInvLemma 
invoke Admin ;  
invoke Nil ;  
with enabled ( lOptionalWeakening ) prove by rewrite ;  
apply lOptionalMemberElem ;  
prove by rewrite ;  
split currentAdminOp = { } ;  
rewrite ;  
cases ;  
apply lTheAppliesElem ;  
rewrite ;  
with normalization prove by reduce ;  
next ;  
equality substitute ;  
apply lTheAppliesElem ;  
rewrite ;  
apply extensionality to predicate availableOps = { } ;  
prove by rewrite ;  
instantiate x == y__0 ;  
rewrite ;  
next ;  
â”” 

â”Œ Admin1 
rolePresent : Optional ADMINPRIVILEGE 
availableOps : â„™ ADMINOP 
currentAdminOp : Optional ADMINOP |
 ( rolePresent = Nil âˆ§ availableOps = Nil âˆ§ currentAdminOp = Nil ) âˆ¨ ( rolePresent â‰  Nil âˆ§ availableOps â‰  Nil âˆ§ ( currentAdminOp â‰  Nil â‡’ The currentAdminOp âˆˆ availableOps ) âˆ§ ( The rolePresent = guard â‡’ availableOps = { overrideLock } ) âˆ§ ( The rolePresent = auditManager â‡’ availableOps = { archiveLog } ) âˆ§ ( The rolePresent = securityOfficer â‡’ availableOps = { updateConfigData , shutdownOp } ) ) â”” 

â”œ Admin1$domainCheck 
prove by rewrite ;  
â”” 

â”€ â˜’ theorem rule lAdminEquiv 
Admin â‡” Admin1 
â”” 

â”œ lAdminEquiv 
split Admin ;  
cases ;  
use lAdminInvLemma ;  
invoke Admin1 ;  
prove by rewrite ;  
next ;  
split Admin1 ;  
with enabled ( Nil , lOptionalWeakening ) prove by reduce ;  
next ;  
â”” 


â”Œ DoorLatchAlarm 
currentTime : TIME 
currentDoor : DOOR 
currentLatch : LATCH 
doorAlarm : ALARM 
latchTimeout : TIME 
alarmTimeout : TIME |
 currentLatch = locked â‡” currentTime â‰¥ latchTimeout 
doorAlarm = alarming â‡” currentDoor = open âˆ§ currentLatch = locked âˆ§ currentTime â‰¥ alarmTimeout â”” 

A clearer(?) version of $DoorLatchAlarm$? It leads to nearly
as complex proofs. It has at least a clearer picture of the
various cases and dependencies involved. First we decompose and
reorder each equivalence
â”Œ DoorLatchAlarm0 
currentTime : TIME 
currentDoor : DOOR 
currentLatch : LATCH 
doorAlarm : ALARM 
latchTimeout : TIME 
alarmTimeout : TIME |
 doorAlarm = alarming â‡’ currentDoor = open âˆ§ currentLatch = locked âˆ§ currentTime â‰¥ alarmTimeout 
currentLatch = locked â‡’ currentTime â‰¥ latchTimeout 
currentTime â‰¥ latchTimeout â‡’ currentLatch = locked 
currentDoor = open âˆ§ currentLatch = locked âˆ§ currentTime â‰¥ alarmTimeout â‡’ doorAlarm = alarming â”” 
Then, we decompose the implications into clearer combination of cases.
We also add a few redundant conjuncts about $doorAlarm$ and $currentLatch$
when their $\IF-\THEN-\ELSE$ statements evaluate to $false$. This is helpful
because it avoids expanding their underlying free (enumerated) types
â”Œ DoorLatchAlarm1 
currentTime : TIME 
currentDoor : DOOR 
currentLatch : LATCH 
doorAlarm : ALARM 
latchTimeout : TIME 
alarmTimeout : TIME |
 if ( doorAlarm = alarming ) then [ | currentDoor = open âˆ§ currentLatch = locked âˆ§ currentTime â‰¥ alarmTimeout âˆ§ currentTime â‰¥ latchTimeout ] else doorAlarm = silent âˆ§ ( if ( currentLatch = locked ) then [ | currentTime â‰¥ latchTimeout âˆ§ ( currentDoor = open â‡’ currentTime < alarmTimeout ) ] else [ | currentLatch = unlocked âˆ§ currentTime < latchTimeout ] ) â”” 
To make sure all is okay, we prove they are equivalent, and leave it as a
disabled rule:~whenever one needs, just apply them.
â”€ â˜’ theorem rule lDoorLatchAlarmEquiv0 
DoorLatchAlarm â‡” DoorLatchAlarm0 
â”” 

â”œ lDoorLatchAlarmEquiv0 
with normalization prove by reduce ;  
â”” 

â”€ â˜’ theorem rule lDoorLatchAlarmEquiv1 
DoorLatchAlarm â‡” DoorLatchAlarm1 
â”” 

â”œ lDoorLatchAlarmEquiv1 
with enabled ( ALARM$member , LATCH$member ) with normalization reduce ;  
â”” 

â”€ â˜’ theorem rule lDoorLatchAlarmEquiv2 
DoorLatchAlarm0 â‡” DoorLatchAlarm1 
â”” 

â”œ lDoorLatchAlarmEquiv2 
with enabled ( ALARM$member , LATCH$member ) with normalization reduce ;  
â”” 


â”Œ UserToken 
currentUserToken : TOKENTRY 
userTokenPresence : PRESENCE â”” 

â”Œ AdminToken 
currentAdminToken : TOKENTRY 
adminTokenPresence : PRESENCE â”” 

â”Œ Finger 
currentFinger : FINGERPRINTTRY 
fingerPresence : PRESENCE â”” 

â”Œ Floppy 
currentFloppy : FLOPPY 
writtenFloppy : FLOPPY 
floppyPresence : PRESENCE â”” 

â”Œ Keyboard 
currentKeyedData : KEYBOARD 
keyedDataPresence : PRESENCE â”” 

â”€ STATUS ::= quiescent | gotUserToken | waitingFinger | gotFinger | waitingUpdateToken | waitingEntry | waitingRemoveTokenSuccess | waitingRemoveTokenFail â”” 

â”€ ENCLAVESTATUS ::= notEnrolled | waitingEnrol | waitingEndEnrol | enclaveQuiescent | gotAdminToken | waitingRemoveAdminTokenFail | waitingStartAdminOp | waitingFinishAdminOp | shutdown â”” 

â”Œ Internal 
tkstatus : STATUS 
enclaveStatus : ENCLAVESTATUS 
tokenRemovalTimeout : TIME â”” 

â”Œ IDStation 
UserToken 
AdminToken 
Finger 
DoorLatchAlarm 
Floppy 
Keyboard 
Config 
Stats 
KeyStore 
Admin 
AuditLog 
Internal 
currentDisplay : DISPLAYMESSAGE 
currentScreen : Screen |
 tkstatus âˆˆ { gotFinger , waitingFinger , waitingUpdateToken , waitingEntry } â‡’ ( âˆƒ ValidToken â¦ goodT ( Î¸ ValidToken ) = currentUserToken ) âˆ¨ ( âˆƒ TokenWithValidAuth â¦ goodT ( Î¸ TokenWithValidAuth ) = currentUserToken ) 
rolePresent â‰  Nil â‡’ ( âˆƒ TokenWithValidAuth â¦ goodT ( Î¸ TokenWithValidAuth ) = currentAdminToken ) 
enclaveStatus âˆ‰ { notEnrolled , waitingEnrol , waitingEndEnrol } â‡’ ownName â‰  Nil 
enclaveStatus âˆˆ { waitingStartAdminOp , waitingFinishAdminOp } â‡” currentAdminOp â‰  Nil 
currentAdminOp â‰  Nil âˆ§ The currentAdminOp âˆˆ { shutdownOp , overrideLock } â‡’ enclaveStatus = waitingStartAdminOp 
enclaveStatus = gotAdminToken â‡’ rolePresent = Nil 
currentScreen . screenStats = displayStats ( Î¸ Stats ) 
currentScreen . screenConfig = displayConfigData ( Î¸ Config ) â”” 

â”œ IDStation$domainCheck 
rewrite ;  
â”” 

â”Œ IDStationState 
UserToken 
AdminToken 
Finger 
DoorLatchAlarm 
Floppy 
Keyboard 
Config 
Stats 
KeyStore 
Admin 
AuditLog 
Internal 
currentDisplay : DISPLAYMESSAGE 
currentScreen : Screen |
 true â”” 

â”Œ IDStation1 
IDStationState |
 currentScreen . screenStats = displayStats ( Î¸ Stats ) 
currentScreen . screenConfig = displayConfigData ( Î¸ Config ) 
rolePresent â‰  Nil â‡’ enclaveStatus â‰  gotAdminToken âˆ§ ( âˆƒ TokenWithValidAuth â¦ currentAdminToken = goodT ( Î¸ TokenWithValidAuth ) ) 
currentAdminOp = Nil â‡’ enclaveStatus â‰  waitingStartAdminOp âˆ§ enclaveStatus â‰  waitingFinishAdminOp 
ownName = Nil â‡’ enclaveStatus âˆˆ { notEnrolled , waitingEnrol , waitingEndEnrol } 
enclaveStatus â‰  waitingStartAdminOp âˆ§ currentAdminOp â‰  Nil â‡’ enclaveStatus = waitingFinishAdminOp âˆ§ The currentAdminOp â‰  shutdownOp âˆ§ The currentAdminOp â‰  overrideLock 
( âˆ€ ValidToken â¦ goodT ( Î¸ Token ) â‰  currentUserToken ) âˆ§ ( âˆ€ TokenWithValidAuth â¦ goodT ( Î¸ TokenWithValidAuth ) â‰  currentUserToken ) â‡’ tkstatus âˆ‰ { waitingFinger , gotFinger , waitingUpdateToken , waitingEntry } â”” 

â”œ IDStation1$domainCheck 
prove by rewrite ;  
â”” 

â”€ â˜’ theorem rule lIDStationEquiv1 
IDStation â‡” IDStation1 
â”” 

â”œ lIDStationEquiv1 
split IDStation ;  
simplify ;  
cases ;  
invoke IDStation ;  
invoke IDStation1 ;  
invoke IDStationState ;  
invoke Nil ;  
with enabled ( lOptionalWeakening ) prove by rewrite ;  
cases ;  
rearrange ;  
simplify ;  
equality substitute currentAdminToken ;  
prove by rewrite ;  
next ;  
instantiate authCert__4 == authCert__0 , iandACert__4 == iandACert__0 , idCert__4 == idCert__0 , privCert__4 == privCert__0 , tokenID__4 == tokenID__0 ;  
split TokenWithValidAuth [ authCert__0 / authCert , iandACert__0 / iandACert , idCert__0 / idCert , privCert__0 / privCert , tokenID__0 / tokenID ] â‡’ Â¬ goodT ( Î¸ ( Token [ authCert__0 / authCert , iandACert__0 / iandACert , idCert__0 / idCert , privCert__0 / privCert , tokenID__0 / tokenID ] ) ) = currentUserToken ;  
simplify ;  
instantiate authCert__2 == authCert , iandACert__2 == iandACert , idCert__2 == idCert , privCert__2 == privCert , tokenID__2 == tokenID ;  
split ValidToken [ authCert__0 / authCert , iandACert__0 / iandACert , idCert__0 / idCert , privCert__0 / privCert , tokenID__0 / tokenID ] â‡’ Â¬ goodT ( Î¸ ( Token [ authCert__0 / authCert , iandACert__0 / iandACert , idCert__0 / idCert , privCert__0 / privCert , tokenID__0 / tokenID ] ) ) = currentUserToken ;  
simplify ;  
next ;  
split IDStation1 ;  
simplify ;  
invoke IDStation ;  
invoke IDStation1 ;  
invoke Nil ;  
with disabled ( inCup ) with enabled ( lOptionalWeakening ) prove by rewrite ;  
cases ;  
prove by rewrite ;  
next ;  
with disabled ( inCup ) with enabled ( lOptionalWeakening ) prove by rewrite ;  
instantiate authCert__3 == authCert__1 , iandACert__3 == iandACert__1 , idCert__3 == idCert__1 , privCert__3 == privCert__1 , tokenID__3 == tokenID__1 ;  
with disabled ( inCup ) with enabled ( lOptionalWeakening ) prove by rewrite ;  
split TokenWithValidAuth [ authCert__1 / authCert , iandACert__1 / iandACert , idCert__1 / idCert , privCert__1 / privCert , tokenID__1 / tokenID ] â‡’ Â¬ goodT ( Î¸ ( Token [ authCert__1 / authCert , iandACert__1 / iandACert , idCert__1 / idCert , privCert__1 / privCert , tokenID__1 / tokenID ] ) ) = currentUserToken ;  
simplify ;  
rearrange ;  
equality substitute currentUserToken ;  
with disabled ( inCup ) rewrite ;  
simplify ;  
next ;  
rearrange ;  
simplify ;  
equality substitute currentAdminToken ;  
with disabled ( inCup ) rewrite ;  
simplify ;  
next ;  
use lOptionalWeakening3 [ USER ] [ S := ISSUER , x := ownName ] ;  
rearrange ;  
rewrite ;  
next ;  
rearrange ;  
rewrite ;  
next ;  
use lOptionalWeakening3 [ PRIVILEGE ] [ S := ADMINPRIVILEGE , x := rolePresent ] ;  
rearrange ;  
rewrite ;  
next ;  
â”” 

â”Œ RealWorldChanges 
Î”RealWorld |
 nowâ€² â‰¥ now â”” 

â”Œ PollTime 
Î”DoorLatchAlarm 
RealWorld |
 currentTimeâ€² = now â”” 

â”Œ PollDoor 
Î”DoorLatchAlarm 
RealWorld |
 currentDoorâ€² = door 
latchTimeoutâ€² = latchTimeout 
alarmTimeoutâ€² = alarmTimeout â”” 

â”Œ PollUserToken 
Î”UserToken 
RealWorld |
 userTokenPresenceâ€² = present â‡” userToken â‰  noT 
currentUserTokenâ€² = if ( userToken â‰  noT ) then userToken else currentUserToken â”” 

â”Œ PollAdminToken 
Î”AdminToken 
RealWorld |
 adminTokenPresenceâ€² = present â‡” adminToken â‰  noT 
currentAdminTokenâ€² = if ( adminToken â‰  noT ) then adminToken else currentAdminToken â”” 

â”Œ PollFinger 
Î”Finger 
RealWorld |
 fingerPresenceâ€² = present â‡” finger â‰  noFP 
currentFingerâ€² = if ( finger â‰  noFP ) then finger else currentFinger â”” 

â”Œ PollFloppy 
Î”Floppy 
RealWorld |
 floppyPresenceâ€² = present â‡” floppy â‰  noFloppy 
currentFloppyâ€² = if ( floppy â‰  noFloppy ) then floppy else currentFloppy 
writtenFloppyâ€² = writtenFloppy â”” 

â”Œ PollKeyboard 
Î”Keyboard 
RealWorld |
 keyedDataPresence = present â‡” keyboard â‰  noKB 
currentKeyedDataâ€² = if ( keyboard â‰  noKB ) then keyboard else currentKeyedData â”” 

â”€ theorem grule gTIMEMaxType 
TIME âˆˆ â„™ â„¤ 
â”” 

â”œ gTIMEMaxType 
prove by reduce ;  
â”” 

â”Œ AddElementsToLog 
Config 
Î”AuditLog |
 âˆƒ newElements : ğ”½â†˜1â†– Audit â¦ oldestLogTime newElements â‰¥ newestLogTime auditLog âˆ§ ( auditLogâ€² = auditLog âˆª newElements âˆ§ ( sizeLog auditLogâ€² < alarmThresholdSize âˆ§ auditAlarmâ€² = auditAlarm âˆ¨ sizeLog auditLogâ€² â‰¥ alarmThresholdSize âˆ§ auditAlarmâ€² = alarming ) âˆ¨ sizeLog auditLog + sizeLog newElements > minPreservedLogSize âˆ§ ( âˆƒ oldElements : ğ”½ Audit â¦ ( oldElements âˆª auditLogâ€² = auditLog âˆª newElements âˆ§ oldestLogTime auditLogâ€² â‰¥ newestLogTime oldElements ) ) âˆ§ sizeLog auditLogâ€² â‰¥ minPreservedLogSize âˆ§ auditAlarmâ€² = alarming ) â”” 

â”œ AddElementsToLog$domainCheck 
rewrite ;  
â”” 

â”Œ AuditDoor 
Î”DoorLatchAlarm 
AddElementsToLog |
 currentDoor â‰  currentDoorâ€² â”” 

â”Œ AuditLatch 
Î”DoorLatchAlarm 
AddElementsToLog |
 currentLatchâ€² â‰  currentLatch â”” 

â”Œ AuditAlarm 
Î”DoorLatchAlarm 
AddElementsToLog |
 doorAlarm â‰  doorAlarmâ€² â”” 

â”Œ AuditLogAlarm 
AddElementsToLog |
 auditAlarm â‰  auditAlarmâ€² â”” 

â”Œ AuditDisplay 
AddElementsToLog 
Î”IDStation |
 currentDisplayâ€² â‰  currentDisplay â”” 

â”Œ AuditScreen 
Î”IDStation 
AddElementsToLog |
 currentScreenâ€² . screenMsg â‰  currentScreen . screenMsg â”” 

â”Œ NoChange 
Î”IDStation |
 currentDoor = currentDoorâ€² 
currentLatchâ€² = currentLatch 
doorAlarm = doorAlarmâ€² 
auditAlarm = auditAlarmâ€² 
currentDisplayâ€² = currentDisplay 
currentScreenâ€² . screenMsg = currentScreen . screenMsg 
AddElementsToLog âˆ¨ ÎAuditLog â”” 

â”€ LogChange == AuditAlarm âˆ¨ AuditLatch âˆ¨ AuditDoor âˆ¨ AuditLogAlarm âˆ¨ AuditScreen âˆ¨ AuditDisplay âˆ¨ NoChange â”” 

â”Œ TISPoll 
Î”IDStation 
ÎRealWorld 
PollTime 
PollDoor 
PollUserToken 
PollAdminToken 
PollFinger 
PollFloppy 
PollKeyboard 
LogChange 
ÎConfig 
ÎKeyStore 
ÎAdmin 
ÎStats 
ÎInternal |
 currentScreenâ€² = currentScreen 
currentDisplay = doorUnlocked âˆ§ currentLatchâ€² = locked âˆ§ ( tkstatus â‰  waitingRemoveTokenFail âˆ§ currentDisplayâ€² = welcome âˆ¨ tkstatus = waitingRemoveTokenFail âˆ§ currentDisplay = removeToken ) âˆ¨ Â¬ ( currentDisplay = doorUnlocked âˆ§ currentLatchâ€² = locked ) âˆ§ currentDisplayâ€² = currentDisplay â”” 

â”Œ UpdateLatch 
ÎDoorLatchAlarm 
RealWorldChanges |
 latchâ€² = currentLatch â”” 

â”Œ UpdateAlarm 
ÎDoorLatchAlarm 
AuditLog 
RealWorldChanges |
 alarmâ€² = alarming â‡” doorAlarm = alarming âˆ¨ auditAlarm = alarming â”” 

â”Œ UpdateDisplay 
Î”IDStation 
RealWorldChanges |
 displayâ€² = currentDisplay 
currentDisplayâ€² = currentDisplay â”” 

Missing DCC (Domain check condition): $rolePresent \neq \nil$
â”Œ UpdateScreen 
Î”IDStation 
ÎAdmin 
RealWorldChanges |
 screenâ€² . screenMsg = currentScreen . screenMsg 
screenâ€² . screenConfig = if ( rolePresent â‰  Nil âˆ§ The rolePresent = securityOfficer ) then currentScreen . screenConfig else clear 
screenâ€² . screenStats = if ( rolePresent â‰  Nil ) then currentScreen . screenStats else clear â”” 
Here there is a choice: either (as it is) with conjunction on the first IF with the missing condition;
or with a more complicated IF-THEN-ELSE, where $rolePresent \neq Nil$ is brought outside the two IFs.
\The later might make proof easier. (Is it the same?

â”œ UpdateScreen$domainCheck 
rewrite ;  
apply lInTheDomain to predicate rolePresent âˆˆ dom The ;  
invoke ÎAdmin ;  
invoke predicate Admin ;  
rewrite ;  
â”” 

â”Œ UpdateUserToken 
ÎIDStation 
RealWorldChanges 
ÎTISControlledRealWorld |
 userTokenâ€² = currentUserToken â”” 

â”€ TISUpdate == UpdateLatch âˆ§ UpdateAlarm âˆ§ UpdateDisplay âˆ§ UpdateScreen âˆ§ ÎUserToken âˆ§ ÎAdminToken âˆ§ ÎFinger âˆ§ ÎFloppy âˆ§ ÎKeyStore âˆ§ ÎAdmin âˆ§ ÎInternal âˆ§ ( AddElementsToLog âˆ¨ ÎAuditLog ) â”” 

â”Œ UpdateFloppy 
Î”IDStation 
RealWorldChanges 
ÎUserToken 
ÎAdminToken 
ÎFinger 
ÎDoorLatchAlarm 
ÎKeyboard 
ÎConfig 
ÎStats 
ÎKeyStore 
ÎAdmin 
ÎAuditLog 
ÎInternal 
ÎTISControlledRealWorld |
 floppyâ€² = writtenFloppy 
currentFloppyâ€² = badFloppy 
floppyPresenceâ€² = floppyPresence 
currentDisplayâ€² = currentDisplay 
currentScreenâ€² = currentScreen â”” 

This operation is not quite rightly defined. $archive$ needs to be an
output variable, as this is what it is meant to be, and because it would
otherwise mess precondition operations.
â”Œ ArchiveLog 
Config 
Î”AuditLog 
archive! : ğ”½ Audit |
 âˆƒ notArchived , newElements : ğ”½ Audit â¦ archive âŠ† auditLog âˆª newElements âˆ§ auditLogâ€² âŠ† archive âˆª notArchived âˆ§ newestLogTime archive â‰¤ oldestLogTime notArchived âˆ§ AddElementsToLog â”” 

â”œ ArchiveLog$domainCheck 
rewrite ;  
â”” 

â”Œ ClearLog 
Config 
Î”AuditLog 
archive! : ğ”½ Audit |
 âˆƒ sinceArchive , lostSinceArchive : ğ”½ Audit â¦ archive âˆª sinceArchive = lostSinceArchive âˆª auditLog âˆ§ oldestLogTime sinceArchive â‰¥ newestLogTime archive âˆ§ newestLogTime lostSinceArchive â‰¤ oldestLogTime auditLog âˆ§ auditLogâ€² = sinceArchive 
sizeLog auditLogâ€² < alarmThresholdSize âˆ§ auditAlarmâ€² = silent âˆ¨ sizeLog auditLogâ€² â‰¥ alarmThresholdSize âˆ§ auditAlarmâ€² = alarming â”” 

â”œ ClearLog$domainCheck 
rewrite ;  
â”” 

â”Œ AddSuccessfulEntryToStats 
Î”Stats |
 failEntryâ€² = failEntry 
successEntryâ€² = successEntry + 1 
failBioâ€² = failBio 
successBioâ€² = successBio â”” 

â”Œ AddFailedEntryToStats 
Î”Stats |
 failEntryâ€² = failEntry + 1 
successEntryâ€² = successEntry 
failBioâ€² = failBio 
successBioâ€² = successBio â”” 

â”Œ AddSuccessfulBioCheckToStats 
Î”Stats |
 failEntryâ€² = failEntry 
successEntryâ€² = successEntry 
failBioâ€² = failBio 
successBioâ€² = successBio + 1 â”” 

â”Œ AddFailedBioCheckToStats 
Î”Stats |
 failEntryâ€² = failEntry 
successEntryâ€² = successEntry 
failBioâ€² = failBio + 1 
successBioâ€² = successBio â”” 

â”Œ UnlockDoor 
Î”DoorLatchAlarm 
Config |
 latchTimeoutâ€² = currentTime + latchUnlockDuration 
alarmTimeoutâ€² = currentTime + latchUnlockDuration + alarmSilentDuration 
currentTimeâ€² = currentTime 
currentDoorâ€² = currentDoor â”” 

â”Œ LockDoor 
Î”DoorLatchAlarm |
 currentLatchâ€² = locked 
latchTimeoutâ€² = currentTime 
alarmTimeoutâ€² = currentTime 
currentTimeâ€² = currentTime 
currentDoorâ€² = currentDoor â”” 

â”Œ CertIssuerKnown 
KeyStore 
Certificate |
 cid . issuer âˆˆ dom issuerKey â”” 

â”Œ CertOK 
CertIssuerKnown |
 issuerKey cid . issuer âˆˆ isValidatedBy â”” 

â”œ CertOK$domainCheck 
invoke CertIssuerKnown ;  
simplify ;  
â”” 

â”Œ CertIssuerIsThisTIS 
KeyStore 
Certificate |
 ownName â‰  Nil 
cid . issuer = The ownName â”” 

â”œ CertIssuerIsThisTIS$domainCheck 
rewrite ;  
invoke Certificate ;  
invoke KeyStore ;  
rewrite ;  
â”” 

â”€ AuthCertOK == CertIssuerIsThisTIS âˆ§ CertOK â”” 

â”€ theorem rule lConfigAuthPeriodTotalOnFirstArg 
âˆ€ Config ; p : PRIVILEGE ; t : TIME â¦ t âˆˆ dom ( authPeriod p ) 
â”” 

â”œ lConfigAuthPeriodTotalOnFirstArg 
invoke Config ;  
invoke ( _ â†’ _ ) ;  
rewrite ;  
instantiate x == p ;  
prove by rewrite ;  
use pairInFunction [ PRIVILEGE , â„™ ( TIME Ã— â„™ TIME ) ] [ f := authPeriod , x := p , y := y ] ;  
rearrange ;  
rewrite ;  
equality substitute authPeriod p ;  
apply inDom ;  
rewrite ;  
instantiate x__1 == t ;  
prenex ;  
instantiate y__4 == y__0 ;  
rewrite ;  
â”” 

â”Œ NewAuthCert 
ValidToken 
KeyStore 
Config 
newAuthCert : AuthCert 
currentTime : TIME |
 ownName â‰  Nil 
newAuthCert . cid . issuer = The ownName 
newAuthCert . validityPeriod = ( authPeriod privCert . role ) currentTime 
newAuthCert . baseCertId = idCert . cid 
newAuthCert . tokenID = tokenID 
newAuthCert . role = privCert . role 
newAuthCert . clearance = minClearance ( enclaveClearance , privCert . clearance ) 
newAuthCert . isValidatedBy = { issuerKey ( The ownName ) } â”” 

â”œ NewAuthCert$domainCheck 
rewrite ;  
cases ;  
apply lInTheDomain ;  
invoke KeyStore ;  
rewrite ;  
next ;  
invoke ValidToken ;  
invoke Token ;  
apply PrivCert$member to predicate privCert âˆˆ PrivCert ;  
prove by rewrite ;  
next ;  
invoke ValidToken ;  
invoke Token ;  
apply PrivCert$member ;  
prove by rewrite ;  
next ;  
invoke KeyStore ;  
prove by rewrite ;  
next ;  
â”” 

â”€ theorem grule gGoodTMaxInjType 
goodT âˆˆ â¦‰ authCert : â„™ â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; clearance : â¦‰ class : CLASS â¦Š ; isValidatedBy : â„™ KEYPART ; role : PRIVILEGE ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ; iandACert : â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; isValidatedBy : â„™ KEYPART ; template : â¦‰ template : FINGERPRINTTEMPLATE â¦Š ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ; idCert : â¦‰ cid : â¦‰ issuer : USER â¦Š ; isValidatedBy : â„™ KEYPART ; subject : USER ; subjectPubK : KEYPART ; validityPeriod : â„™ â„¤ â¦Š ; privCert : â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; clearance : â¦‰ class : CLASS â¦Š ; isValidatedBy : â„™ KEYPART ; role : PRIVILEGE ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ; tokenID : TOKENID â¦Š â¤” TOKENTRY 
â”” 

â”œ gGoodTMaxInjType 
invoke ( _ â¤” _ ) ;  
rewrite ;  
invoke ( _ â‡¸ _ ) ;  
prove by rewrite ;  
use goodT$injective [ x$ := y1 , x$â€² := y2 ] ;  
use pairInFunction [ â¦‰ authCert : â„™ â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; clearance : â¦‰ class : CLASS â¦Š ; isValidatedBy : â„™ KEYPART ; role : PRIVILEGE ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ; iandACert : â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; isValidatedBy : â„™ KEYPART ; template : â¦‰ template : FINGERPRINTTEMPLATE â¦Š ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ; idCert : â¦‰ cid : â¦‰ issuer : USER â¦Š ; isValidatedBy : â„™ KEYPART ; subject : USER ; subjectPubK : KEYPART ; validityPeriod : â„™ â„¤ â¦Š ; privCert : â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; clearance : â¦‰ class : CLASS â¦Š ; isValidatedBy : â„™ KEYPART ; role : PRIVILEGE ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ; tokenID : TOKENID â¦Š , TOKENTRY ] [ f := goodT , x := y1 , y := x ] ;  
use pairInFunction [ â¦‰ authCert : â„™ â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; clearance : â¦‰ class : CLASS â¦Š ; isValidatedBy : â„™ KEYPART ; role : PRIVILEGE ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ; iandACert : â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; isValidatedBy : â„™ KEYPART ; template : â¦‰ template : FINGERPRINTTEMPLATE â¦Š ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ; idCert : â¦‰ cid : â¦‰ issuer : USER â¦Š ; isValidatedBy : â„™ KEYPART ; subject : USER ; subjectPubK : KEYPART ; validityPeriod : â„™ â„¤ â¦Š ; privCert : â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; clearance : â¦‰ class : CLASS â¦Š ; isValidatedBy : â„™ KEYPART ; role : PRIVILEGE ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ; tokenID : TOKENID â¦Š , TOKENTRY ] [ f := goodT , x := y2 , y := x ] ;  
prove by rewrite ;  
use goodT$declaration ;  
invoke ( _ â†’ _ ) ;  
invoke ( _ â‡¸ _ ) ;  
invoke ( _ â†” _ ) ;  
rewrite ;  
trivial rewrite ;  
prenex ;  
apply inPower to predicate r âˆˆ â„™ ( Token Ã— TOKENTRY ) ;  
instantiate e == ( y1 , x ) ;  
instantiate e == ( y2 , x ) ;  
prove by rewrite ;  
â”” 

Missing DCC: $authCert' \neq nil$ and that $currentUserToken' \in \ran gootT$.
â”Œ AddAuthCertToUserToken 
Î”UserToken 
KeyStore 
Config 
currentTime : TIME |
 userTokenPresence = present 
currentUserToken âˆˆ ran goodT 
currentUserTokenâ€² âˆˆ ran goodT 
âˆƒ ValidToken ; ValidTokenâ€² â¦ Î¸ ValidToken = ( goodT âˆ¼ ) currentUserToken âˆ§ Î¸ ValidTokenâ€² = ( goodT âˆ¼ ) currentUserTokenâ€² âˆ§ ( âˆƒ newAuthCert : AuthCert â¦ ( authCertâ€² â‰  Nil âˆ§ The authCertâ€² = newAuthCert âˆ§ NewAuthCert ) ) âˆ§ tokenIDâ€² = tokenID âˆ§ idCertâ€² = idCert âˆ§ privCertâ€² = privCert âˆ§ iandACertâ€² = iandACert 
userTokenPresenceâ€² = userTokenPresence â”” 

â”œ AddAuthCertToUserToken$domainCheck 
prove by rewrite ;  
â”” 

â”Œ UpdateKeyStore 
Î”KeyStore 
ValidEnrol |
 ownName â‰  Nil âˆ§ ownNameâ€² â‰  Nil 
The ownNameâ€² = idStationCert . subject 
issuerKeyâ€² = issuerKey âŠ• { c : issuerCerts â¦ ( c . subject â†¦ c . subjectPubK ) } âŠ• { ( The ownName â†¦ idStationCert . subjectPubK ) } â”” 

â”œ UpdateKeyStore$domainCheck 
rewrite ;  
apply lInTheDomain ;  
invoke Î”KeyStore ;  
invoke KeyStore ;  
rewrite ;  
cases ;  
next ;  
next ;  
â”” 

â”€ theorem grule gEnrolementFilePInjType 
enrolmentFile âˆˆ â¦‰ idStationCert : â¦‰ cid : â¦‰ issuer : USER â¦Š ; isValidatedBy : â„™ KEYPART ; subject : USER ; subjectPubK : KEYPART ; validityPeriod : â„™ â„¤ â¦Š ; issuerCerts : â„™ â¦‰ cid : â¦‰ issuer : USER â¦Š ; isValidatedBy : â„™ KEYPART ; subject : USER ; subjectPubK : KEYPART ; validityPeriod : â„™ â„¤ â¦Š â¦Š â¤” FLOPPY 
â”” 

â”œ gEnrolementFilePInjType 
invoke ( _ â¤” _ ) ;  
rewrite ;  
invoke ( _ â‡¸ _ ) ;  
prove by rewrite ;  
use enrolmentFile$injective [ x$ := y1 , x$â€² := y2 ] ;  
use pairInFunction [ â¦‰ idStationCert : â¦‰ cid : â¦‰ issuer : USER â¦Š ; isValidatedBy : â„™ KEYPART ; subject : USER ; subjectPubK : KEYPART ; validityPeriod : â„™ â„¤ â¦Š ; issuerCerts : â„™ â¦‰ cid : â¦‰ issuer : USER â¦Š ; isValidatedBy : â„™ KEYPART ; subject : USER ; subjectPubK : KEYPART ; validityPeriod : â„™ â„¤ â¦Š â¦Š , FLOPPY ] [ f := enrolmentFile , x := y1 , y := x ] ;  
use pairInFunction [ â¦‰ idStationCert : â¦‰ cid : â¦‰ issuer : USER â¦Š ; isValidatedBy : â„™ KEYPART ; subject : USER ; subjectPubK : KEYPART ; validityPeriod : â„™ â„¤ â¦Š ; issuerCerts : â„™ â¦‰ cid : â¦‰ issuer : USER â¦Š ; isValidatedBy : â„™ KEYPART ; subject : USER ; subjectPubK : KEYPART ; validityPeriod : â„™ â„¤ â¦Š â¦Š , FLOPPY ] [ f := enrolmentFile , x := y2 , y := x ] ;  
prove by rewrite ;  
use enrolmentFile$declaration ;  
invoke ( _ â†’ _ ) ;  
invoke ( _ â‡¸ _ ) ;  
invoke ( _ â†” _ ) ;  
rewrite ;  
trivial rewrite ;  
prenex ;  
apply inPower to predicate r âˆˆ â„™ ( ValidEnrol Ã— FLOPPY ) ;  
instantiate e == ( y1 , x ) ;  
instantiate e == ( y2 , x ) ;  
prove by rewrite ;  
â”” 

â”Œ UpdateKeyStoreFromFloppy 
Î”KeyStore 
Floppy |
 currentFloppy âˆˆ ran enrolmentFile 
âˆƒ ValidEnrol â¦ Î¸ ValidEnrol = ( enrolmentFile âˆ¼ ) ( currentFloppy ) âˆ§ UpdateKeyStore â”” 

â”œ UpdateKeyStoreFromFloppy$domainCheck 
rewrite ;  
â”” 

â”Œ AdminLogon 
Î”Admin 
AdminToken |
 rolePresent = Nil 
âˆƒ ValidToken â¦ goodT ( Î¸ ValidToken ) = currentAdminToken âˆ§ rolePresentâ€² â‰  Nil âˆ§ authCert â‰  Nil âˆ§ The rolePresentâ€² = ( The authCert ) . role 
currentAdminOpâ€² = Nil â”” 

â”œ AdminLogon$domainCheck 
rewrite ;  
apply lInTheDomain ;  
invoke Î”Admin ;  
invoke Admin ;  
rewrite ;  
use lOptionalSubtying [ â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; clearance : â¦‰ class : CLASS â¦Š ; isValidatedBy : â„™ KEYPART ; role : PRIVILEGE ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ] [ A := AuthCert , x := authCert ] ;  
rearrange ;  
rewrite ;  
â”” 

â”Œ AdminLogout 
Î”Admin |
 rolePresent â‰  Nil 
rolePresentâ€² = Nil 
currentAdminOpâ€² = Nil â”” 

â”€ theorem grule gKeyedOpsPInjType 
keyedOps âˆˆ ADMINOP â¤” KEYBOARD 
â”” 

â”œ gKeyedOpsPInjType 
invoke ( _ â¤” _ ) ;  
rewrite ;  
invoke ( _ â‡¸ _ ) ;  
prove by rewrite ;  
use keyedOps$injective [ x$ := y1 , x$â€² := y2 ] ;  
use pairInFunction [ ADMINOP , KEYBOARD ] [ f := keyedOps , x := y1 , y := x ] ;  
use pairInFunction [ ADMINOP , KEYBOARD ] [ f := keyedOps , x := y2 , y := x ] ;  
prove by rewrite ;  
â”” 

â”Œ AdminStartOp 
Î”Admin 
Keyboard |
 rolePresent â‰  Nil 
currentAdminOp = Nil 
currentKeyedData âˆˆ keyedOps â¦‡ availableOps â¦ˆ 
rolePresentâ€² = rolePresent 
currentAdminOpâ€² â‰  Nil 
The currentAdminOpâ€² = ( keyedOps âˆ¼ ) ( currentKeyedData ) â”” 

â”œ AdminStartOp$domainCheck 
rewrite ;  
invoke Î”Admin ;  
apply inImage ;  
apply inRan ;  
invoke Nil ;  
prove by rewrite ;  
instantiate x__0 == x ;  
prove by rewrite ;  
â”” 

â”Œ AdminFinishOp 
Î”Admin |
 rolePresent â‰  Nil 
currentAdminOp â‰  Nil 
rolePresentâ€² = rolePresent 
currentAdminOpâ€² = Nil â”” 

â”Œ ResetScreenMessage 
Î”Internal 
Î”Admin 
currentScreen , currentScreenâ€² : Screen |
 tkstatusâ€² âˆ‰ { quiescent , waitingRemoveTokenFail } âˆ§ currentScreenâ€² . screenMsg = busy âˆ¨ tkstatusâ€² âˆˆ { quiescent , waitingRemoveTokenFail } âˆ§ ( enclaveStatusâ€² = enclaveQuiescent âˆ§ rolePresentâ€² = Nil âˆ§ currentScreenâ€² . screenMsg = welcomeAdmin âˆ¨ enclaveStatusâ€² = enclaveQuiescent âˆ§ rolePresentâ€² â‰  Nil âˆ§ currentScreenâ€² . screenMsg = requestAdminOp âˆ¨ enclaveStatusâ€² = waitingRemoveAdminTokenFail âˆ§ currentScreenâ€² . screenMsg = removeAdminToken âˆ¨ enclaveStatusâ€² âˆ‰ { enclaveQuiescent , waitingRemoveAdminTokenFail } âˆ§ currentScreenâ€² . screenMsg = currentScreen . screenMsg ) â”” 

â”Œ UserEntryContext 
Î”IDStation 
RealWorldChanges 
ÎConfig 
ÎAdminToken 
ÎKeyStore 
ÎAdmin 
ÎKeyboard 
ÎFloppy 
ÎFinger 
ÎTISControlledRealWorld 
ResetScreenMessage |
 enclaveStatusâ€² = enclaveStatus 
tkstatus â‰  waitingEntry â‡’ tokenRemovalTimeoutâ€² = tokenRemovalTimeout â”” 

â”Œ UserTokenTorn 
UserEntryContext 
ÎUserToken 
ÎDoorLatchAlarm 
AddFailedEntryToStats 
AddElementsToLog |
 tkstatus âˆˆ { gotUserToken , waitingUpdateToken , waitingFinger , gotFinger , waitingEntry } 
userTokenPresence = absent 
currentDisplayâ€² = welcome 
tkstatusâ€² = quiescent â”” 

â”Œ ReadUserToken 
UserEntryContext 
ÎUserToken 
ÎDoorLatchAlarm 
ÎStats 
AddElementsToLog |
 enclaveStatus âˆˆ { enclaveQuiescent , waitingRemoveAdminTokenFail } 
tkstatus = quiescent 
userTokenPresence = present 
currentDisplayâ€² = wait 
tkstatusâ€² = gotUserToken â”” 

â”€ TISReadUserToken == ReadUserToken â”” 

â”Œ UserTokenWithOKAuthCert 
KeyStore 
UserToken 
currentTime : TIME |
 currentUserToken âˆˆ ran goodT 
âˆƒ TokenWithValidAuth â¦ goodT ( Î¸ TokenWithValidAuth ) = currentUserToken âˆ§ currentTime âˆˆ ( The authCert ) . validityPeriod âˆ§ ( âˆƒ IDCert â¦ ( Î¸ IDCert = idCert âˆ§ CertOK ) ) âˆ§ ( âˆƒ AuthCert â¦ ( Î¸ AuthCert = The authCert âˆ§ AuthCertOK ) ) â”” 

â”œ UserTokenWithOKAuthCert$domainCheck 
rewrite ;  
apply lInTheDomain to predicate authCert âˆˆ dom The ;  
use lOptionalSubtying [ â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; clearance : â¦‰ class : CLASS â¦Š ; isValidatedBy : â„™ KEYPART ; role : PRIVILEGE ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ] [ A := AuthCert , x := authCert ] ;  
invoke TokenWithValidAuth ;  
prove by rewrite ;  
â”” 

â”Œ UserTokenOK 
KeyStore 
UserToken 
currentTime : TIME |
 currentUserToken âˆˆ ran goodT 
âˆƒ CurrentToken â¦ goodT ( Î¸ ValidToken ) = currentUserToken âˆ§ now = currentTime âˆ§ ( âˆƒ IDCert â¦ ( Î¸ IDCert = idCert âˆ§ CertOK ) ) âˆ§ ( âˆƒ PrivCert â¦ ( Î¸ PrivCert = privCert âˆ§ CertOK ) ) âˆ§ ( âˆƒ IandACert â¦ ( Î¸ IandACert = iandACert âˆ§ CertOK ) ) â”” 

â”œ UserTokenOK$domainCheck 
rewrite ;  
â”” 

â”Œ BioCheckNotRequired 
UserEntryContext 
ÎUserToken 
ÎDoorLatchAlarm 
ÎStats 
AddElementsToLog |
 tkstatus = gotUserToken 
userTokenPresence = present 
UserTokenWithOKAuthCert 
tkstatusâ€² = waitingEntry 
currentDisplayâ€² = wait â”” 

â”Œ BioCheckRequired 
UserEntryContext 
ÎUserToken 
ÎDoorLatchAlarm 
ÎStats 
AddElementsToLog |
 tkstatus = gotUserToken 
userTokenPresence = present 
Â¬ UserTokenWithOKAuthCert âˆ§ UserTokenOK 
tkstatusâ€² = waitingEntry 
currentDisplayâ€² = insertFinger â”” 

â”€ ValidateUserTokenOK == BioCheckRequired âˆ¨ BioCheckNotRequired â”” 

â”Œ ValidateUserTokenFail 
UserEntryContext 
ÎUserToken 
ÎDoorLatchAlarm 
ÎStats 
AddElementsToLog |
 tkstatus = gotUserToken 
userTokenPresence = present 
Â¬ UserTokenWithOKAuthCert âˆ§ Â¬ UserTokenOK 
tkstatusâ€² = waitingRemoveTokenFail 
currentDisplayâ€² = removeToken â”” 

â”€ TISValidateUserToken == ValidateUserTokenOK âˆ¨ ValidateUserTokenFail âˆ¨ [ UserTokenTorn | tkstatus = gotUserToken ] â”” 

â”Œ ReadFingerOK 
UserEntryContext 
ÎUserToken 
ÎDoorLatchAlarm 
ÎStats 
AddElementsToLog |
 tkstatus = waitingFinger 
fingerPresence = present 
userTokenPresence = present 
tkstatusâ€² = gotFinger 
currentDisplayâ€² = wait â”” 

â”Œ FingerTimeout 
UserEntryContext 
ÎUserToken 
ÎDoorLatchAlarm 
ÎStats 
AddElementsToLog |
 tkstatus = waitingFinger 
userTokenPresence = present 
tkstatusâ€² = waitingRemoveTokenFail 
currentDisplayâ€² = removeToken â”” 

â”Œ NoFinger 
ÎIDStation 
RealWorldChanges 
ÎTISControlledRealWorld |
 tkstatus = waitingFinger 
fingerPresence = absent 
userTokenPresence = present â”” 

â”€ TISReadFinger == ReadFingerOK âˆ¨ FingerTimeout âˆ¨ NoFinger âˆ¨ [ UserTokenTorn | tkstatus = waitingFinger ] â”” 

â”Œ FingerOK 
Finger 
UserToken |
 currentFinger âˆˆ ran goodFP â”” 

â”Œ ValidateFingerOK 
UserEntryContext 
ÎUserToken 
ÎDoorLatchAlarm 
AddSuccessfulBioCheckToStats 
AddElementsToLog |
 tkstatus = gotFinger 
userTokenPresence = present 
FingerOK 
tkstatusâ€² = waitingUpdateToken 
currentDisplayâ€² = wait â”” 

â”Œ ValidateFingerFail 
UserEntryContext 
ÎUserToken 
ÎDoorLatchAlarm 
AddFailedBioCheckToStats 
AddElementsToLog |
 tkstatus = gotFinger 
userTokenPresence = present 
tkstatusâ€² = waitingRemoveTokenFail 
currentDisplayâ€² = removeToken â”” 

â”€ TISValidateFinger == ValidateFingerOK âˆ¨ ValidateFingerFail âˆ¨ [ UserTokenTorn | tkstatus = gotFinger ] â”” 

â”Œ WriteUserTokenOK 
UserEntryContext 
ÎUserToken 
ÎDoorLatchAlarm 
AddAuthCertToUserToken 
AddElementsToLog |
 tkstatus = waitingUpdateToken 
userTokenPresence = present 
tkstatusâ€² = waitingEntry 
currentDisplayâ€² = wait â”” 

â”Œ WriteUserTokenFail 
UserEntryContext 
ÎUserToken 
ÎDoorLatchAlarm 
AddAuthCertToUserToken 
AddElementsToLog |
 tkstatus = waitingUpdateToken 
userTokenPresence = present 
tkstatusâ€² = waitingEntry 
currentDisplayâ€² = tokenUpdateFailed â”” 

â”€ WriteUserToken == WriteUserTokenOK âˆ¨ WriteUserTokenFail â”” 

â”€ theorem rule lConfigEntryPeriodTotalOnFirstArg 
âˆ€ Config ; p : PRIVILEGE ; c : CLASS â¦ c âˆˆ dom ( entryPeriod p ) 
â”” 

â”œ lConfigEntryPeriodTotalOnFirstArg 
invoke Config ;  
invoke ( _ â†’ _ ) ;  
rewrite ;  
instantiate x__0 == p ;  
prove by rewrite ;  
use pairInFunction [ PRIVILEGE , â„™ ( CLASS Ã— â„™ TIME ) ] [ f := entryPeriod , x := p , y := y ] ;  
rearrange ;  
rewrite ;  
equality substitute entryPeriod p ;  
apply inDom ;  
rewrite ;  
instantiate x__1 == c ;  
prenex ;  
instantiate y__4 == y__0 ;  
rewrite ;  
â”” 

â”Œ UserAllowedEntry 
UserToken 
Config 
currentTime : TIME |
 ( âˆƒ ValidToken â¦ goodT ( Î¸ ValidToken ) = currentUserToken âˆ§ currentTime âˆˆ ( entryPeriod privCert . role ) privCert . clearance . class ) âˆ¨ ( âˆƒ TokenWithValidAuth â¦ goodT ( Î¸ TokenWithValidAuth ) = currentUserToken âˆ§ currentTime âˆˆ entryPeriod ( The authCert ) . role ( The authCert ) . clearance . class ) â”” 

â”œ UserAllowedEntry$domainCheck 
prove by rewrite ;  
cases ;  
invoke ValidToken ;  
invoke Token ;  
apply PrivCert$member ;  
prove by rewrite ;  
invoke PrivCert ;  
apply Clearance$member ;  
prove by rewrite ;  
next ;  
invoke TokenWithValidAuth ;  
cases ;  
apply lInTheDomain to predicate authCert__0 âˆˆ dom The ;  
use lOptionalSubtying [ â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; clearance : â¦‰ class : CLASS â¦Š ; isValidatedBy : â„™ KEYPART ; role : PRIVILEGE ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ] [ A := AuthCert , x := authCert__0 ] ;  
prove by rewrite ;  
next ;  
use lInTheDomain [ â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; clearance : â¦‰ class : CLASS â¦Š ; isValidatedBy : â„™ KEYPART ; role : PRIVILEGE ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ] [ x := authCert__0 ] ;  
use lOptionalSubtying [ â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; clearance : â¦‰ class : CLASS â¦Š ; isValidatedBy : â„™ KEYPART ; role : PRIVILEGE ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ] [ A := AuthCert , x := authCert__0 ] ;  
apply inDom to predicate authCert__0 âˆˆ dom The ;  
prenex ;  
rearrange ;  
rewrite ;  
rearrange ;  
use pairInFunction [ â„™ â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; clearance : â¦‰ class : CLASS â¦Š ; isValidatedBy : â„™ KEYPART ; role : PRIVILEGE ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š , â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; clearance : â¦‰ class : CLASS â¦Š ; isValidatedBy : â„™ KEYPART ; role : PRIVILEGE ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ] [ f := The [ â¦‰ baseCertId : â¦‰ issuer : USER â¦Š ; cid : â¦‰ issuer : USER â¦Š ; clearance : â¦‰ class : CLASS â¦Š ; isValidatedBy : â„™ KEYPART ; role : PRIVILEGE ; tokenID : TOKENID ; validityPeriod : â„™ â„¤ â¦Š ] , x := authCert__0 , y := y ] ;  
rearrange ;  
rewrite ;  
equality substitute The authCert__0 ;  
apply PrivCert$inSet ;  
prenex ;  
equality substitute y ;  
rewrite ;  
apply Clearance$inSet ;  
prenex ;  
equality substitute clearance ;  
rewrite ;  
next ;  
â”” 

try lemma UserAllowedEntry\$domainCheck;
prove by rewrite;
cases;
invoke ValidToken;
invoke Token;
apply PrivCert\$member;
prove by rewrite;
invoke PrivCert;
apply Clearance\$member;
prove by rewrite;
next;
invoke TokenWithValidAuth;
cases;
apply lInTheDomain to predicate authCert\_\_0 \in \dom \The;
use
  lOptionalSubtying[\lblot baseCertId: \lblot issuer: USER \rblot;
                           cid: \lblot issuer: USER \rblot;
                           clearance: \lblot class: CLASS \rblot;
                           isValidatedBy: \power KEYPART; role: PRIVILEGE;
                           tokenID: TOKENID;
                           validityPeriod: \power \num \rblot][A := AuthCert,
                                                               x := authCert\_\_0];
prove by rewrite;
next;
use
  lInTheDomain[\lblot baseCertId: \lblot issuer: USER \rblot;
                      cid: \lblot issuer: USER \rblot;
                      clearance: \lblot class: CLASS \rblot;
                      isValidatedBy: \power KEYPART; role: PRIVILEGE;
                      tokenID: TOKENID;
                      validityPeriod: \power \num \rblot][x := authCert\_\_0];
use
  lOptionalSubtying[\lblot baseCertId: \lblot issuer: USER \rblot;
                           cid: \lblot issuer: USER \rblot;
                           clearance: \lblot class: CLASS \rblot;
                           isValidatedBy: \power KEYPART; role: PRIVILEGE;
                           tokenID: TOKENID;
                           validityPeriod: \power \num \rblot][A := AuthCert,
                                                               x := authCert\_\_0];
apply inDom to predicate authCert\_\_0 \in \dom \The;
prenex;
rearrange;
rewrite;
rearrange;
use
  pairInFunction[\power \lblot baseCertId: \lblot issuer: USER \rblot;
                               cid: \lblot issuer: USER \rblot;
                               clearance: \lblot class: CLASS \rblot;
                               isValidatedBy: \power KEYPART; role: PRIVILEGE;
                               tokenID: TOKENID;
                               validityPeriod: \power \num \rblot,
                 \lblot baseCertId: \lblot issuer: USER \rblot;
                        cid: \lblot issuer: USER \rblot;
                        clearance: \lblot class: CLASS \rblot;
                        isValidatedBy: \power KEYPART; role: PRIVILEGE;
                        tokenID: TOKENID;
                        validityPeriod:
                          \power \num \rblot][f
                                                := \The[\lblot baseCertId:
                                                                \lblot issuer:
                                                                         USER \rblot;
                                                              cid:
                                                                \lblot issuer:
                                                                         USER \rblot;
                                                              clearance:
                                                                \lblot class:
                                                                         CLASS \rblot;
                                                              isValidatedBy:
                                                                \power KEYPART;
                                                              role: PRIVILEGE;
                                                              tokenID: TOKENID;
                                                              validityPeriod:
                                                                \power \num \rblot],
                                              x := authCert\_\_0, y := y];
rearrange;
rewrite;
equality substitute \The authCert\_\_0;
apply PrivCert\$inSet;
prenex;
equality substitute y;
rewrite;
apply Clearance\$inSet;
prenex;
equality substitute clearance;
rewrite;
next;



â”Œ EntryOK 
UserEntryContext 
ÎUserToken 
ÎDoorLatchAlarm 
ÎStats 
AddElementsToLog |
 tkstatus = waitingUpdateToken 
userTokenPresence = present 
UserAllowedEntry 
tkstatusâ€² = waitingRemoveTokenSuccess 
currentDisplayâ€² = openDoor 
tokenRemovalTimeoutâ€² = currentTime + tokenRemovalDuration â”” 

â”Œ EntryNotAllowed 
UserEntryContext 
ÎUserToken 
ÎDoorLatchAlarm 
ÎStats 
AddElementsToLog |
 tkstatus = waitingEntry 
userTokenPresence = present 
Â¬ UserAllowedEntry 
tkstatusâ€² = waitingRemoveTokenFail 
currentDisplayâ€² = removeToken 
tokenRemovalTimeoutâ€² = tokenRemovalTimeout â”” 

â”€ TISValidateEntry == EntryOK âˆ¨ EntryNotAllowed âˆ¨ [ UserTokenTorn | tkstatus = waitingEntry ] â”” 

â”Œ UnlockDoorOK 
UserEntryContext 
ÎUserToken 
UnlockDoor 
AddSuccessfulEntryToStats 
AddElementsToLog |
 tkstatus = waitingRemoveTokenSuccess 
userTokenPresence = absent 
tkstatusâ€² = quiescent 
currentDisplayâ€² = doorUnlocked â”” 

â”Œ WaitingTokenRemoval 
ÎIDStation 
RealWorldChanges 
ÎTISControlledRealWorld |
 tkstatus âˆˆ { waitingRemoveTokenSuccess , waitingRemoveTokenFail } 
tkstatus = waitingRemoveTokenSuccess â‡’ currentTime â‰¤ tokenRemovalTimeout 
userTokenPresence = present â”” 

â”Œ TokenRemovalTimeout 
UserEntryContext 
ÎUserToken 
ÎDoorLatchAlarm 
ÎStats 
AddElementsToLog |
 tkstatus = waitingRemoveTokenSuccess 
userTokenPresence = present 
currentTime > tokenRemovalTimeout 
tkstatusâ€² = waitingRemoveTokenFail 
currentDisplayâ€² = removeToken â”” 

â”€ TISUnlockDoor == UnlockDoorOK âˆ¨ [ WaitingTokenRemoval | tkstatus = waitingRemoveTokenSuccess ] âˆ¨ TokenRemovalTimeout â”” 

â”Œ FailedAccessTokenRemoved 
UserEntryContext 
ÎUserToken 
ÎDoorLatchAlarm 
AddFailedEntryToStats 
AddElementsToLog |
 tkstatus = waitingRemoveTokenFail 
userTokenPresence = absent 
tkstatusâ€² = quiescent 
currentDisplayâ€² = welcome â”” 

â”€ TISCompleteFailedAccess == FailedAccessTokenRemoved âˆ¨ [ WaitingTokenRemoval | tkstatus = waitingRemoveTokenFail ] â”” 

â”€ TISUserEntryOp == TISReadUserToken âˆ¨ TISValidateUserToken âˆ¨ TISReadFinger âˆ¨ TISValidateFinger âˆ¨ TISValidateEntry âˆ¨ TISUnlockDoor âˆ¨ TISCompleteFailedAccess â”” 

â•· foo : â„• |
 ã€Š disabled rule dIssuerNotEmpty ã€‹ ISSUER â‰  âˆ… 
ã€Š disabled rule dKeypartNotEmpty ã€‹ KEYPART â‰  âˆ… 
ã€Š disabled rule dTokenIDNotEmpty ã€‹ TOKENID â‰  âˆ… 
ã€Š disabled rule dFingerprintTemplateNotEmpty ã€‹ FINGERPRINTTEMPLATE â‰  âˆ… 
ã€Š disabled rule dAuditNotEmpty ã€‹ Audit â‰  âˆ… â”” 

â”€ theorem tClearanceFeasible 
âˆƒ Clearance â¦ true 
â”” 

â”œ tClearanceFeasible 
instantiate class == unmarked ;  
prove by reduce ;  
â”” 

â”€ theorem tFingerprintTemplateFeasible 
âˆƒ FingerprintTemplate â¦ true 
â”” 

â”œ tFingerprintTemplateFeasible 
use dFingerprintTemplateNotEmpty ;  
prove by rewrite ;  
apply extensionality ;  
prove by rewrite ;  
instantiate template == x ;  
prove by reduce ;  
â”” 

â”€ theorem tCertificateIdFeasible 
âˆƒ CertificateId â¦ true 
â”” 

â”œ tCertificateIdFeasible 
use dIssuerNotEmpty ;  
prove by rewrite ;  
apply extensionality ;  
prove by rewrite ;  
instantiate issuer == x ;  
prove by reduce ;  
â”” 

â”€ theorem tCertificateFeasible 
âˆƒ Certificate â¦ true 
â”” 

â”œ tCertificateFeasible 
use dIssuerNotEmpty ;  
rewrite ;  
apply extensionality to predicate ISSUER = { } ;  
prove by rewrite ;  
instantiate cid == Î¸ ( CertificateId [ issuer := x ] ) , isValidatedBy == { } , validityPeriod == { } ;  
invoke Certificate ;  
invoke ( Optional _ ) ;  
rewrite ;  
invoke CertificateId ;  
rewrite ;  
â”” 

â”€ theorem tIDCertFeasible 
âˆƒ IDCert â¦ true 
â”” 

â”œ tIDCertFeasible 
use dKeypartNotEmpty ;  
use tCertificateFeasible ;  
prenex ;  
rewrite ;  
apply extensionality to predicate KEYPART = { } ;  
prove by rewrite ;  
instantiate cid__0 == cid , isValidatedBy__0 == isValidatedBy , validityPeriod__0 == validityPeriod , subject == cid . issuer , subjectPubK == x ;  
invoke IDCert ;  
rewrite ;  
invoke Certificate ;  
apply CertificateId$member to predicate cid âˆˆ CertificateId ;  
prove by rewrite ;  
â”” 

â”€ theorem tCAIdCertFeasible 
âˆƒ CAIdCert â¦ true 
â”” 

â”œ tCAIdCertFeasible 
use dKeypartNotEmpty ;  
use tCertificateFeasible ;  
prenex ;  
rewrite ;  
apply extensionality to predicate KEYPART = { } ;  
prove by rewrite ;  
instantiate cid__0 == cid , isValidatedBy__0 == { x } , validityPeriod__0 == validityPeriod , subject == cid . issuer , subjectPubK == x ;  
invoke CAIdCert ;  
invoke IDCert ;  
invoke Certificate ;  
apply CertificateId$member to predicate cid âˆˆ CertificateId ;  
prove by rewrite ;  
apply lOptionalMemberElem to predicate { x } âˆˆ Optional KEYPART ;  
rewrite ;  
â”” 

try lemma tCAIdCertFeasible;
use dKeypartNotEmpty;
use tCertificateFeasible;
prenex;
rewrite;
apply extensionality to predicate KEYPART = \{\};
prove by rewrite;
instantiate
  cid\_\_0 == cid, isValidatedBy\_\_0 == \{ x \},
  validityPeriod\_\_0 == validityPeriod, subject == cid.issuer,
  subjectPubK == x;
invoke CAIdCert;
invoke IDCert;
invoke Certificate;
apply CertificateId\$member to predicate cid \in CertificateId;
prove by rewrite;
apply lOptionalMemberElem to predicate \{ x \} \in \Optional KEYPART;
rewrite;


â”€ theorem tAttCertificateFeasible 
âˆƒ AttCertificate â¦ true 
â”” 

â”œ tAttCertificateFeasible 
use tCertificateFeasible ;  
use tCertificateIdFeasible ;  
use dTokenIDNotEmpty ;  
prenex ;  
rewrite ;  
apply extensionality to predicate TOKENID = { } ;  
prove by rewrite ;  
instantiate cid__0 == cid , isValidatedBy__0 == isValidatedBy , validityPeriod__0 == validityPeriod , tokenID == x , baseCertId == Î¸ CertificateId ;  
prove by reduce ;  
â”” 

try lemma tAttCertificateFeasible;
use tCertificateFeasible;
use tCertificateIdFeasible;
use dTokenIDNotEmpty;
prenex;
rewrite;
apply extensionality to predicate TOKENID = \{\};
prove by rewrite;
instantiate
  cid\_\_0 == cid, isValidatedBy\_\_0 == isValidatedBy,
  validityPeriod\_\_0 == validityPeriod, tokenID == x,
  baseCertId == \theta CertificateId;
prove by reduce;
use tCertificateFeasible;
use tCertificateIdFeasible;
use dTokenIDNotEmpty;
prenex;
rewrite;
use tCertificateFeasible;
use tCertificateIdFeasible;
use dTokenIDNotEmpty;
prenex;
rewrite;


â”€ theorem tPrivCertFeasible 
âˆƒ PrivCert â¦ true 
â”” 

â”œ tPrivCertFeasible 
use tClearanceFeasible ;  
use tAttCertificateFeasible ;  
prenex ;  
instantiate baseCertId__0 == baseCertId , isValidatedBy__0 == isValidatedBy , cid__0 == cid , tokenID__0 == tokenID , validityPeriod__0 == validityPeriod , role == userOnly , clearance == Î¸ Clearance ;  
invoke PrivCert ;  
rewrite ;  
â”” 

try lemma tPrivCertFeasible;
use tClearanceFeasible;
use tAttCertificateFeasible;
prenex;
instantiate
  baseCertId\_\_0 == baseCertId, isValidatedBy\_\_0 == isValidatedBy,
  cid\_\_0 == cid, tokenID\_\_0 == tokenID,
  validityPeriod\_\_0 == validityPeriod, role == userOnly,
  clearance == \theta Clearance;
invoke PrivCert;
rewrite;


â”€ theorem tAuthCertFeasible 
âˆƒ AuthCert â¦ true 
â”” 

â”œ tAuthCertFeasible 
use tClearanceFeasible ;  
use tAttCertificateFeasible ;  
prenex ;  
instantiate baseCertId__0 == baseCertId , isValidatedBy__0 == isValidatedBy , cid__0 == cid , tokenID__0 == tokenID , validityPeriod__0 == validityPeriod , role == userOnly , clearance == Î¸ Clearance ;  
invoke AuthCert ;  
rewrite ;  
â”” 

try lemma tAuthCertFeasible;
use tClearanceFeasible;
use tAttCertificateFeasible;
prenex;
instantiate
  baseCertId\_\_0 == baseCertId, isValidatedBy\_\_0 == isValidatedBy,
  cid\_\_0 == cid, tokenID\_\_0 == tokenID,
  validityPeriod\_\_0 == validityPeriod, role == userOnly,
  clearance == \theta Clearance;
invoke AuthCert;
rewrite;


â”€ theorem tIandACertFeasible 
âˆƒ IandACert â¦ true 
â”” 

â”œ tIandACertFeasible 
use tAttCertificateFeasible ;  
use tFingerprintTemplateFeasible ;  
prenex ;  
instantiate baseCertId__0 == baseCertId , isValidatedBy__0 == isValidatedBy , cid__0 == cid , tokenID__0 == tokenID , validityPeriod__0 == validityPeriod , template__0 == Î¸ FingerprintTemplate ;  
invoke IandACert ;  
rewrite ;  
â”” 

try lemma tIandACertFeasible;
use tAttCertificateFeasible;
use tFingerprintTemplateFeasible;
prenex;
instantiate
  baseCertId\_\_0 == baseCertId, isValidatedBy\_\_0 == isValidatedBy,
  cid\_\_0 == cid, tokenID\_\_0 == tokenID,
  validityPeriod\_\_0 == validityPeriod,
  template\_\_0 == \theta FingerprintTemplate;
invoke IandACert;
rewrite;


â”€ theorem tTokenFeasible 
âˆƒ Token â¦ true 
â”” 

â”œ tTokenFeasible 
use tIDCertFeasible ;  
use tPrivCertFeasible ;  
use tIandACertFeasible ;  
use tAuthCertFeasible ;  
prenex ;  
instantiate tokenID__2 == tokenID , idCert == Î¸ ( IDCert [ cid__2 / cid , isValidatedBy__2 / isValidatedBy , validityPeriod__2 / validityPeriod ] ) , privCert == Î¸ ( PrivCert [ baseCertId__1 / baseCertId , cid__1 / cid , clearance__0 / clearance , isValidatedBy__1 / isValidatedBy , role__0 / role , tokenID__1 / tokenID , validityPeriod__1 / validityPeriod ] ) , iandACert == Î¸ ( IandACert [ baseCertId__0 / baseCertId , cid__0 / cid , isValidatedBy__0 / isValidatedBy , tokenID__0 / tokenID , validityPeriod__0 / validityPeriod ] ) , authCert == { Î¸ AuthCert } ;  
invoke Token ;  
rewrite ;  
apply lOptionalMemberElem ;  
rewrite ;  
â”” 

try lemma tTokenFeasible;
use tIDCertFeasible;
use tPrivCertFeasible;
use tIandACertFeasible;
use tAuthCertFeasible;
prenex;
instantiate
  tokenID\_\_2 == tokenID,
  idCert
    == \theta
         IDCert[cid\_\_2/cid, isValidatedBy\_\_2/isValidatedBy,
                validityPeriod\_\_2/validityPeriod],
  privCert
    == \theta
         PrivCert[baseCertId\_\_1/baseCertId, cid\_\_1/cid,
                  clearance\_\_0/clearance, isValidatedBy\_\_1/isValidatedBy,
                  role\_\_0/role, tokenID\_\_1/tokenID,
                  validityPeriod\_\_1/validityPeriod],
  iandACert
    == \theta
         IandACert[baseCertId\_\_0/baseCertId, cid\_\_0/cid,
                   isValidatedBy\_\_0/isValidatedBy, tokenID\_\_0/tokenID,
                   validityPeriod\_\_0/validityPeriod],
  authCert == \{\theta AuthCert\};
invoke Token;
rewrite;
apply lOptionalMemberElem;
rewrite;

â”€ theorem tValidTokenFeasible 
âˆƒ ValidToken â¦ true 
â”” 

â”œ tValidTokenFeasible 
use tPrivCertFeasible ;  
prenex ;  
use dFingerprintTemplateNotEmpty ;  
use dIssuerNotEmpty ;  
use dKeypartNotEmpty ;  
prove by rewrite ;  
apply extensionality ;  
prove by rewrite ;  
instantiate idCert == Î¸ ( IDCert [ cid := baseCertId , subject := x__0 , subjectPubK := x ] ) , iandACert == Î¸ ( IandACert [ cid := baseCertId , template := Î¸ ( FingerprintTemplate [ template := x__1 ] ) ] ) , privCert == Î¸ PrivCert , authCert == { Î¸ PrivCert } , tokenID__0 == tokenID ;  
with enabled ( Optional _ ) prove by reduce ;  
â”” 

â”€ theorem tTokenWithValidAuthFeasible 
âˆƒ TokenWithValidAuth â¦ true 
â”” 

â”œ tTokenWithValidAuthFeasible 
use tPrivCertFeasible ;  
prenex ;  
use dFingerprintTemplateNotEmpty ;  
use dIssuerNotEmpty ;  
use dKeypartNotEmpty ;  
prove by rewrite ;  
apply extensionality ;  
prove by rewrite ;  
instantiate idCert == Î¸ ( IDCert [ cid := baseCertId , subject := x__0 , subjectPubK := x ] ) , iandACert == Î¸ ( IandACert [ cid := baseCertId , template := Î¸ ( FingerprintTemplate [ template := x__1 ] ) ] ) , privCert == Î¸ PrivCert , authCert == { Î¸ PrivCert } , tokenID__0 == tokenID ;  
with disabled ( PrivCert ) prove by reduce ;  
apply lTheAppliesElem ;  
prove by rewrite ;  
with enabled ( Nil , Optional _ ) prove by reduce ;  
â”” 

â”€ theorem tCurrentTokenFeasible 
âˆƒ CurrentToken â¦ true 
â”” 

â”œ tCurrentTokenFeasible 
use tPrivCertFeasible ;  
prenex ;  
use dFingerprintTemplateNotEmpty ;  
use dIssuerNotEmpty ;  
use dKeypartNotEmpty ;  
prove by rewrite ;  
apply extensionality ;  
prove by rewrite ;  
instantiate idCert == Î¸ ( IDCert [ cid := baseCertId , subject := x__0 , subjectPubK := x , validityPeriod := { 0 } ] ) , iandACert == Î¸ ( IandACert [ cid := baseCertId , validityPeriod := { 0 } , template := Î¸ ( FingerprintTemplate [ template := x__1 ] ) ] ) , privCert == Î¸ ( PrivCert [ validityPeriod := { 0 } ] ) , authCert == { } , tokenID__0 == tokenID , now == 0 ;  
prove by reduce ;  
â”” 

â”€ theorem tEnrolFeasible 
âˆƒ Enrol â¦ true 
â”” 

â”œ tEnrolFeasible 
use tIDCertFeasible ;  
prenex ;  
instantiate idStationCert == Î¸ IDCert , issuerCerts == { Î¸ IDCert } ;  
invoke Enrol ;  
rewrite ;  
â”” 

â”€ theorem rule gCAIdCert 
{ CAIdCert | true } âˆˆ â„™ â¦‰ cid : â¦‰ issuer : USER â¦Š ; isValidatedBy : â„™ KEYPART ; subject : USER ; subjectPubK : KEYPART ; validityPeriod : â„™ â„¤ â¦Š 
â”” 

â”œ gCAIdCert 
apply inPower ;  
with enabled ( CAIdCert$member ) prove by reduce ;  
â”” 

â”€ theorem lValidEnrolCAIdCert 
âˆƒ CAIdCert â¦ Î¸ CAIdCert âˆˆ { CAIdCertâ€² | Î¸ CAIdCert . cid . issuer = subjectâ€² } 
â”” 

â”œ lValidEnrolCAIdCert 
use dKeypartNotEmpty ;  
use dIssuerNotEmpty ;  
with predicate ( ( ISSUER â‰  âˆ… â‡” true ) âˆ§ KEYPART â‰  âˆ… ) rewrite ;  
apply extensionality ;  
prenex ;  
apply inNull ;  
instantiate cid == Î¸ ( CertificateId [ issuer := x ] ) , isValidatedBy == { x__0 } , validityPeriod == { } , subjectPubK == x__0 ;  
prove by reduce ;  
invoke ( Optional _ ) ;  
rewrite ;  
â”” 

â”€ theorem tValidEnrolFeasible 
âˆƒ ValidEnrol â¦ true 
â”” 

â”œ tValidEnrolFeasible 
use lValidEnrolCAIdCert ;  
prenex ;  
instantiate idStationCert == Î¸ CAIdCert , issuerCerts == { Î¸ CAIdCert } ;  
invoke ValidEnrol ;  
invoke Enrol ;  
invoke Nil ;  
prove by rewrite ;  
invoke CAIdCert ;  
invoke IDCert ;  
prove by rewrite ;  
apply lTheAppliesElem ;  
prove by reduce ;  
â”” 

â”€ theorem tScreenFeasible 
âˆƒ Screen â¦ true 
â”” 

â”œ tScreenFeasible 
instantiate screenStats == clear , screenMsg == clear , screenConfig == clear ;  
prove by reduce ;  
â”” 

â”€ theorem tAdimFeasible 
âˆƒ Admin â¦ true 
â”” 

â”œ tAdimFeasible 
instantiate availableOps == { } , currentAdminOp == { } , rolePresent == { } ;  
cases ;  
invoke Admin ;  
invoke Nil ;  
rewrite ;  
apply lOptionalMemberElem to predicate { } âˆˆ Optional ADMINOP ;  
rewrite ;  
next ;  
â”” 

â”€ theorem tRealWorldFeasible 
âˆƒ RealWorld â¦ true 
â”” 

â”œ tRealWorldFeasible 
use tScreenFeasible ;  
prenex ;  
instantiate latch == locked , alarm == silent , display == blank , screen == Î¸ Screen , now == 0 , door == closed , finger == noFP , userToken == noT , adminToken == noT , floppy == noFloppy , keyboard == noKB ;  
prove by reduce ;  
â”” 

try lemma tRealWorldFeasible;
use tScreenFeasible;
prenex;
instantiate
  latch == locked, alarm == silent, display == blank, screen == \theta Screen,
  now == 0, door == closed, finger == noFP, userToken == noT,
  adminToken == noT, floppy == noFloppy, keyboard == noKB;
prove by reduce;


â”€ AUTH_PERIOD == ( Î» p : PRIVILEGE â¦ ( Î» t : TIME â¦ âˆ… [ â„¤ ] ) ) â”” 

â”€ ENTRY_PERIOD == ( Î» p : PRIVILEGE â¦ ( Î» c : CLASS â¦ âˆ… [ â„¤ ] ) ) â”” 

â”€ â˜’ theorem rule dMaxSupportedLogSize 
1 â‰¤ maxSupportedLogSize 
â”” 

â”œ dMaxSupportedLogSize 
use maxSupportedLogSize$declaration ;  
apply inNat1 ;  
rewrite ;  
â”” 

â”€ theorem tIDStationFeasible 
âˆƒ IDStation â¦ true 
â”” 

â”œ tIDStationFeasible 
use tScreenFeasible ;  
prenex ;  
instantiate alarmSilentDuration == 0 , latchUnlockDuration == 0 , tokenRemovalDuration == 0 , enclaveClearance == Î¸ ( Clearance [ class := unmarked ] ) , authPeriod == AUTH_PERIOD , entryPeriod == ENTRY_PERIOD , minPreservedLogSize == 1 , alarmThresholdSize == 0 , auditLog == { } , auditAlarm == silent , issuerKey == { } , ownName == { } , successEntry == 0 , failEntry == 0 , successBio == 0 , failBio == 0 , rolePresent == { } , availableOps == { } , currentAdminOp == { } , currentTime == 0 , currentDoor == closed , currentLatch == locked , doorAlarm == silent , latchTimeout == 0 , alarmTimeout == 0 , currentUserToken == noT , userTokenPresence == absent , currentAdminToken == noT , adminTokenPresence == absent , currentFinger == noFP , fingerPresence == absent , currentFloppy == noFloppy , writtenFloppy == noFloppy , floppyPresence == absent , currentKeyedData == noKB , keyedDataPresence == absent , tkstatus == quiescent , enclaveStatus == notEnrolled , tokenRemovalTimeout == 0 , currentDisplay == blank , currentScreen == Î¸ ( Screen [ screenStats := displayStats Î¸ ( Stats [ successEntry := 0 , failEntry := 0 , successBio := 0 , failBio := 0 ] ) , screenConfig := displayConfigData Î¸ ( Config [ alarmSilentDuration := 0 , latchUnlockDuration := 0 , tokenRemovalDuration := 0 , enclaveClearance := Î¸ ( Clearance [ class := unmarked ] ) , authPeriod := AUTH_PERIOD , entryPeriod := ENTRY_PERIOD , minPreservedLogSize := 1 , alarmThresholdSize := 0 ] ) ] ) ;  
with enabled ( Nil , Optional _ ) prove by reduce ;  
apply dMaxSupportedLogSize ;  
simplify ;  
â”” 

â”€ theorem frule fRealWorldNowType 
âˆ€ RealWorld â¦ now â‰¥ 0 
â”” 

â”œ fRealWorldNowType 
prove by reduce ;  
â”” 



We use PollTimeSig to avoid expanding $DoorLatchAlarm$ too early.
â”Œ PollTimeSig 
DoorLatchAlarm 
RealWorld |
 true â”” 

â”€ theorem tPollTimePRE 
âˆ€ PollTimeSig â¦ pre PollTime 
â”” 

â”œ tPollTimePRE 
invoke PollTime ;  
invoke Î”DoorLatchAlarm ;  
rewrite ;  
invoke DoorLatchAlarm ;  
prove by rewrite ;  
instantiate currentDoorâ€² == if ( doorAlarm â‰  alarming ) then closed else open , currentLatchâ€² == if ( doorAlarm â‰  alarming ) then unlocked else locked , alarmTimeoutâ€² == if ( doorAlarm â‰  alarming ) then now + 1 else now , latchTimeoutâ€² == if ( doorAlarm â‰  alarming ) then now + 1 else now , doorAlarmâ€² == doorAlarm ;  
prove by rewrite ;  
invoke TIME ;  
rewrite ;  
â”” 

â”Œ PollDoorSig 
DoorLatchAlarm 
RealWorld |
 true â”” 

â”€ theorem tPollDoorPRE 
âˆ€ PollDoorSig â¦ pre PollDoor 
â”” 

â”œ tPollDoorPRE 
invoke PollDoor ;  
invoke Î”DoorLatchAlarm ;  
invoke DoorLatchAlarm ;  
prove by rewrite ;  
invoke PollDoorSig ;  
invoke DoorLatchAlarm ;  
prove by rewrite ;  
split door = currentDoor ;  
cases ;  
instantiate currentLatchâ€² == currentLatch , currentTimeâ€² == currentTime , doorAlarmâ€² == doorAlarm ;  
prove by rewrite ;  
next ;  
rearrange ;  
rewrite ;  
split door = open ;  
rewrite ;  
cases ;  
instantiate doorAlarmâ€² == alarming ;  
prove by rewrite ;  
instantiate currentLatchâ€² == locked ;  
rewrite ;  
split currentLatch = locked ;  
rewrite ;  
cases ;  
rewrite ;  
instantiate currentTimeâ€² == currentTime ;  
rewrite ;  
instantiate doorAlarmâ€² == silent ;  
rewrite ;  
next ;  
rewrite ;  
instantiate currentTimeâ€² == latchTimeout ;  
invoke TIME ;  
instantiate doorAlarmâ€² == silent ;  
rewrite ;  
next ;  
invoke RealWorld ;  
invoke TISMonitoredRealWorld ;  
apply DOOR$member ;  
prove by rewrite ;  
instantiate currentLatchâ€² == currentLatch , currentTimeâ€² == currentTime ;  
rewrite ;  
instantiate doorAlarmâ€² == silent ;  
rewrite ;  
next ;  
â”” 

An alternative proof using the $DoorLatchAlarm1$ equivalence.
â”€ theorem tPollDoorPREAlternative 
âˆ€ PollDoorSig â¦ pre PollDoor 
â”” 

â”œ tPollDoorPREAlternative 
invoke PollDoor ;  
invoke Î”DoorLatchAlarm ;  
prove by rewrite ;  
invoke PollDoorSig ;  
apply lDoorLatchAlarmEquiv1 ;  
invoke DoorLatchAlarm1 ;  
invoke TIME ;  
prove by rewrite ;  
split door = currentDoor ;  
cases ;  
instantiate currentLatchâ€² == currentLatch , currentTimeâ€² == currentTime , doorAlarmâ€² == doorAlarm ;  
with normalization rewrite ;  
next ;  
rearrange ;  
rewrite ;  
split door = open ;  
rewrite ;  
cases ;  
instantiate doorAlarmâ€² == alarming ;  
prove by rewrite ;  
instantiate currentLatchâ€² == locked ;  
rewrite ;  
split currentLatch = locked ;  
rewrite ;  
cases ;  
instantiate currentTimeâ€² == currentTime ;  
rewrite ;  
next ;  
rewrite ;  
instantiate currentTimeâ€² == latchTimeout ;  
rewrite ;  
next ;  
rewrite ;  
with enabled ( DOOR$member ) prove by reduce ;  
with normalization rewrite ;  
cases ;  
instantiate currentLatchâ€² == currentLatch , currentTimeâ€² == currentTime ;  
rewrite ;  
next ;  
rewrite ;  
cases ;  
instantiate currentLatchâ€² == currentLatch , currentTimeâ€² == currentTime ;  
rewrite ;  
next ;  
rewrite ;  
instantiate currentLatchâ€² == currentLatch , currentTimeâ€² == currentTime ;  
rewrite ;  
next ;  
â”” 

â”€ theorem tPollUserTokenPRE 
âˆ€ UserToken ; RealWorld â¦ pre PollUserToken 
â”” 

â”œ tPollUserTokenPRE 
invoke PollUserToken ;  
invoke Î”UserToken ;  
with normalization prove by rewrite ;  
invoke UserToken ;  
prove by rewrite ;  
split userToken = noT ;  
prove by rewrite ;  
instantiate userTokenPresenceâ€² == absent ;  
prove by rewrite ;  
â”” 

â”€ theorem tPollAdminTokenPRE 
âˆ€ AdminToken ; RealWorld â¦ pre PollAdminToken 
â”” 

â”œ tPollAdminTokenPRE 
invoke PollAdminToken ;  
invoke Î”AdminToken ;  
invoke AdminToken ;  
with normalization prove by rewrite ;  
split adminToken = noT ;  
prove by rewrite ;  
instantiate adminTokenPresenceâ€² == absent ;  
prove by rewrite ;  
â”” 

â”€ theorem tPollFingerPRE 
âˆ€ Finger ; RealWorld â¦ pre PollFinger 
â”” 

â”œ tPollFingerPRE 
invoke PollFinger ;  
invoke Î”Finger ;  
invoke Finger ;  
with normalization prove by rewrite ;  
split finger = noFP ;  
prove by rewrite ;  
instantiate fingerPresenceâ€² == absent ;  
prove by rewrite ;  
â”” 

â”€ theorem tPollFloppyPRE 
âˆ€ Floppy ; RealWorld â¦ pre PollFloppy 
â”” 

â”œ tPollFloppyPRE 
invoke PollFloppy ;  
invoke Î”Floppy ;  
invoke Floppy ;  
with normalization prove by rewrite ;  
split floppy = noFloppy ;  
prove by rewrite ;  
instantiate floppyPresenceâ€² == absent ;  
prove by rewrite ;  
â”” 

â”Œ PollKeyboardSig 
Keyboard 
RealWorld |
 keyedDataPresence = if ( keyboard = noKB ) then absent else present â”” 

â”€ theorem tPollKeyboardPRE 
âˆ€ PollKeyboardSig â¦ pre PollKeyboard 
â”” 

â”œ tPollKeyboardPRE 
invoke PollKeyboard ;  
invoke Î”Keyboard ;  
invoke Keyboard ;  
invoke PollKeyboardSig ;  
with normalization prove by reduce ;  
instantiate keyedDataPresenceâ€² == absent ;  
prove by rewrite ;  
â”” 

â”Œ TISPollSig 
IDStation 
RealWorld |
 PollTimeSig 
PollDoorSig 
PollKeyboardSig â”” 

â”€ theorem lTISPollPREStdUpdLemma 
âˆ€ TISPollSig â¦ TISPoll [ adminToken := adminTokenâ€² , adminTokenPresenceâ€² := ( if ( adminToken = noT ) then absent else present ) , alarm := alarmâ€² , alarmSilentDuration := alarmSilentDurationâ€² , alarmThresholdSize := alarmThresholdSizeâ€² , alarmTimeout := alarmTimeoutâ€² , auditAlarm := auditAlarmâ€² , auditLog := auditLogâ€² , authPeriod := authPeriodâ€² , availableOps := availableOpsâ€² , currentAdminOp := currentAdminOpâ€² , currentAdminTokenâ€² := if ( adminToken = noT ) then currentAdminToken else adminToken , currentDisplay := currentDisplayâ€² , currentDoor := currentDoorâ€² , currentFingerâ€² := if ( finger = noFP ) then currentFinger else finger , currentFloppyâ€² := if ( floppy = noFloppy ) then currentFloppy else floppy , currentKeyedDataâ€² := if ( keyboard = noKB ) then currentKeyedData else keyboard , currentLatchâ€² := if ( currentDisplay = doorUnlocked ) then unlocked else locked , currentScreen := currentScreenâ€² , now := currentTimeâ€² , currentUserTokenâ€² := if ( userToken = noT ) then currentUserToken else userToken , display := displayâ€² , door := doorâ€² , doorAlarm := doorAlarmâ€² , enclaveClearance := enclaveClearanceâ€² , enclaveStatus := enclaveStatusâ€² , entryPeriod := entryPeriodâ€² , failBio := failBioâ€² , failEntry := failEntryâ€² , finger := fingerâ€² , fingerPresenceâ€² := if ( finger = noFP ) then absent else present , floppy := floppyâ€² , floppyPresenceâ€² := if ( floppy = noFloppy ) then absent else present , issuerKey := issuerKeyâ€² , keyboard := keyboardâ€² , keyedDataPresence := keyedDataPresenceâ€² , latch := latchâ€² , latchTimeout := latchTimeoutâ€² , latchUnlockDuration := latchUnlockDurationâ€² , minPreservedLogSize := minPreservedLogSizeâ€² , now := nowâ€² , ownName := ownNameâ€² , rolePresent := rolePresentâ€² , screen := screenâ€² , tkstatus := tkstatusâ€² , successBio := successBioâ€² , successEntry := successEntryâ€² , tokenRemovalDuration := tokenRemovalDurationâ€² , tokenRemovalTimeout := tokenRemovalTimeoutâ€² , userToken := userTokenâ€² , userTokenPresenceâ€² := if ( userToken = noT ) then absent else present , writtenFloppy := writtenFloppyâ€² ] 
â”” 

DoorLatchAlarm[currentLatch
                          := \IF currentDisplay = doorUnlocked
                             \THEN unlocked
                             \ELSE locked, now/currentTime]

 TISPollSig \\
\implies (\IF enclaveStatus = waitingStartAdminOp
          \THEN       currentAdminOp \in \power ADMINOP \\
                \land Nil \in \power ADMINOP \\
                \land \lnot currentAdminOp = Nil
          \ELSE (\IF enclaveStatus = waitingFinishAdminOp
                 \THEN       currentAdminOp \in \power ADMINOP \\
                       \land Nil \in \power ADMINOP \\
                       \land \lnot currentAdminOp = Nil
                 \ELSE                currentAdminOp \in \power ADMINOP \\
                                \land Nil \in \power ADMINOP \\
                       \implies currentAdminOp = Nil))

 TISPollSig \\
\implies (     enclaveStatus
               \in \{waitingStartAdminOp\} \cup \{waitingFinishAdminOp\} \\
          \iff currentAdminOp \neq Nil)
   TISPollSig \\
         \land
          \lnot (\exists ValidToken @ goodT \theta Token = currentUserToken) \\
         \land (     tkstatus = waitingFinger \\
                \lor tkstatus = gotFinger \\
                \lor tkstatus = waitingUpdateToken \\
                \lor tkstatus = waitingEntry) \\
\implies
 (\exists
    TokenWithValidAuth[authCert\_\_0/authCert, iandACert\_\_0/iandACert,
                       idCert\_\_0/idCert, privCert\_\_0/privCert,
                       tokenID\_\_0/tokenID]
    @ goodT
      \theta
        Token[authCert\_\_0/authCert, iandACert\_\_0/iandACert,
              idCert\_\_0/idCert, privCert\_\_0/privCert, tokenID\_\_0/tokenID]
      = currentUserToken)

TISPollSig \\
         \land rolePresent \in \power PRIVILEGE \\
         \land Nil \in \power PRIVILEGE \\
         \land \lnot rolePresent = Nil \\
\implies (\exists TokenWithValidAuth @ goodT \theta Token = currentAdminToken)

 TISPollSig \\
         \land enclaveStatus
               \notin \{notEnrolled\}
                      \cup (\{waitingEnrol\} \cup \{waitingEndEnrol\}) \\
\implies ownName \neq Nil

 TISPollSig \\
         \land currentAdminOp \neq Nil \\
         \land \The currentAdminOp \in \{shutdownOp\} \cup \{overrideLock\} \\
\implies enclaveStatus = waitingStartAdminOp

  TISPollSig \\
         \land enclaveStatus = gotAdminToken \\
\implies rolePresent = Nil

 TISPollSig \\
         \land \lnot (\exists ValidToken
                        @ (\IF userToken = noT
                           \THEN goodT \theta Token = currentUserToken
                           \ELSE goodT \theta Token = userToken)) \\
         \land (     tkstatus = waitingFinger \\
                \lor tkstatus = gotFinger \\
                \lor tkstatus = waitingUpdateToken \\
                \lor tkstatus = waitingEntry) \\
\implies
(\exists
   TokenWithValidAuth[authCert\_\_0/authCert, iandACert\_\_0/iandACert,
                      idCert\_\_0/idCert, privCert\_\_0/privCert,
                      tokenID\_\_0/tokenID]
   @ (\IF userToken = noT
      \THEN
      goodT
      \theta
        Token[authCert\_\_0/authCert, iandACert\_\_0/iandACert,
              idCert\_\_0/idCert, privCert\_\_0/privCert, tokenID\_\_0/tokenID]
      = currentUserToken
      \ELSE
      goodT
      \theta
        Token[authCert\_\_0/authCert, iandACert\_\_0/iandACert,
              idCert\_\_0/idCert, privCert\_\_0/privCert, tokenID\_\_0/tokenID]
      = userToken))

    TISPollSig \\
         \land rolePresent \in \power PRIVILEGE \\
         \land Nil \in \power PRIVILEGE \\
         \land \lnot rolePresent = Nil \\
\implies (\exists TokenWithValidAuth
            @ (\IF adminToken = noT
               \THEN goodT \theta Token = currentAdminToken
               \ELSE goodT \theta Token = adminToken))

TISPollSig \\
         \land enclaveStatus
               \notin \{notEnrolled\}
                      \cup (\{waitingEnrol\} \cup \{waitingEndEnrol\}) \\
\implies ownName \neq Nil

TISPollSig \\
         \land currentAdminOp \neq Nil \\
         \land \The currentAdminOp \in \{shutdownOp\} \cup \{overrideLock\} \\
\implies enclaveStatus = waitingStartAdminOp

  TISPollSig \\
         \land enclaveStatus = gotAdminToken \\
\implies rolePresent = Nil

    TISPollSig \\
\implies (\IF currentDisplay = doorUnlocked
          \THEN       now \geq 0 \\
                \land latchTimeout \geq 0 \\
                \land alarmTimeout \geq 0 \\
                \land (     false \\
                       \iff now \geq latchTimeout) \\
                \land \lnot doorAlarm = alarming
          \ELSE       now \geq 0 \\
                \land latchTimeout \geq 0 \\
                \land alarmTimeout \geq 0 \\
                \land now \geq latchTimeout \\
                \land (\IF currentDoor = open
                       \THEN (\IF now \geq alarmTimeout
                              \THEN doorAlarm = alarming
                              \ELSE \lnot doorAlarm = alarming)
                       \ELSE \lnot doorAlarm = alarming))

    TISPollSig \\
\implies (\IF keyboard = noKB
          \THEN \lnot keyedDataPresence = present
          \ELSE keyedDataPresence = present)


try lemma lTISPollPREStdUpdLemma;
invoke TISPoll;
cases;
invoke \Delta IDStation;
invoke IDStation;
rearrange;
cases;
rewrite;
next;
rewrite;
next;
rewrite;
next;
rewrite;
next;
rewrite;
next;
rewrite;
next;
rewrite;
next;
rewrite;
next;
rewrite;
next;
rewrite;
next;
rewrite;
next;
rewrite;
next;
rewrite;
next;
rewrite;
next;
with disabled (TISPollSig) reduce;
next;
with disabled (TISPollSig) reduce;
next;
with disabled (TISPollSig) reduce;
next;
rewrite;
next;
next;
with disabled (TISPollSig) reduce;
next;
with disabled (TISPollSig) reduce;
next;
rewrite;
next;
rewrite;
next;
rewrite;
next;
rewrite;
next;
rewrite;
next;
rewrite;
next;
rewrite;
next;
with normalization rewrite;
next;
invoke TISPollSig;
invoke IDStation;
rewrite;
next;
invoke TISPollSig;
invoke IDStation;
rewrite;
next;
next;
invoke TISPollSig;
invoke IDStation;
rewrite;
next;
invoke TISPollSig;
invoke IDStation;
rewrite;
next;
prove by rewrite;
next;
prove by rewrite;
next;
next;
next;
next;
prove by rewrite;
next;
prove by rewrite;
next;
next;
next;
next;
next;
with disabled (TISPollSig) prove by reduce;
next;
with disabled (TISPollSig) prove by reduce;
next;
with disabled (TISPollSig) prove by reduce;
next;
with disabled (TISPollSig) prove by reduce;
next;
with disabled (TISPollSig) prove by reduce;
next;
with disabled (TISPollSig) prove by reduce;
next;
with disabled (TISPollSig) prove by reduce;
next;
with disabled (TISPollSig) prove by reduce;
next;
next;
with disabled (TISPollSig) prove by reduce;
next;
with disabled (TISPollSig) prove by reduce;
next;
with disabled (TISPollSig) prove by reduce;
next;
with disabled (TISPollSig) prove by reduce;
next;
with disabled (TISPollSig) prove by reduce;
next;
simplify;
next;
prove by rewrite;
next;

\begin{}[lTISPollPREStdUpdLemma]
invoke TISPoll;
cases;
TODO
next;
invoke \Xi RealWorld;
rewrite;
next;
with disabled (IDStation, RealWorld, PollDoorSig, PollKeyboardSig)
  with normalization prove by reduce;
TODO
next;
with disabled (IDStation, RealWorld, PollTimeSig, PollKeyboardSig)
  with normalization prove by reduce;
TODO
next;
with disabled (IDStation, RealWorld, PollDoorSig, PollTimeSig, PollKeyboardSig)
  with normalization prove by reduce;
next;
with disabled (IDStation, RealWorld, PollDoorSig, PollTimeSig, PollKeyboardSig)
  with normalization prove by reduce;
next;
with disabled (IDStation, RealWorld, PollDoorSig, PollTimeSig, PollKeyboardSig)
  with normalization prove by reduce;
next;
with disabled (IDStation, RealWorld, PollDoorSig, PollTimeSig, PollKeyboardSig)
  with normalization prove by reduce;
next;
with disabled (IDStation, RealWorld, PollDoorSig, PollTimeSig)
  with normalization prove by reduce;
next;
invoke LogChange;
next;
invoke \Xi Config;
rewrite;
next;
invoke \Xi KeyStore;
rewrite;
next;
invoke \Xi Admin;
rewrite;
next;
invoke \Xi Stats;
rewrite;
next;
invoke \Xi Internal;
rewrite;
next;
simplify;
next;
with normalization prove by rewrite;
next;
rearrange;
\end{}

â”€ theorem tTISPollPRE 
âˆ€ TISPollSig â¦ pre TISPoll 
â”” 

\begin{}[tTISPollPRE]
instantiate
  currentTime' == now,
  currentUserToken'
    == \IF userToken = noT \THEN currentUserToken \ELSE userToken,
  userTokenPresence' == \IF userToken = noT \THEN absent \ELSE present,
  currentAdminToken'
    == \IF adminToken = noT \THEN currentAdminToken \ELSE adminToken,
  adminTokenPresence' == \IF adminToken = noT \THEN absent \ELSE present,
  currentFinger' == \IF finger = noFP \THEN currentFinger \ELSE finger,
  fingerPresence' == \IF finger = noFP \THEN absent \ELSE present,
  currentFloppy' == \IF floppy = noFloppy \THEN currentFloppy \ELSE floppy,
  floppyPresence' == \IF floppy = noFloppy \THEN absent \ELSE present,
  currentKeyedData'
    == \IF keyboard = noKB \THEN currentKeyedData \ELSE keyboard,
  currentLatch'
    == \IF currentDisplay = doorUnlocked \THEN unlocked \ELSE locked,
  adminToken' == adminToken, alarm' == alarm,
  alarmSilentDuration' == alarmSilentDuration,
  alarmThresholdSize' == alarmThresholdSize, alarmTimeout' == alarmTimeout,
  auditAlarm' == auditAlarm, auditLog' == auditLog, authPeriod' == authPeriod,
  availableOps' == availableOps, currentAdminOp' == currentAdminOp,
  currentDisplay' == currentDisplay, currentDoor' == currentDoor,
  currentScreen' == currentScreen, display' == display, door' == door,
  doorAlarm' == doorAlarm, enclaveClearance' == enclaveClearance,
  enclaveStatus' == enclaveStatus, entryPeriod' == entryPeriod,
  failBio' == failBio, failEntry' == failEntry, finger' == finger,
  floppy' == floppy, issuerKey' == issuerKey, keyboard' == keyboard,
  keyedDataPresence' == keyedDataPresence, latch' == latch,
  latchTimeout' == latchTimeout, latchUnlockDuration' == latchUnlockDuration,
  minPreservedLogSize' == minPreservedLogSize, now' == now,
  ownName' == ownName, rolePresent' == rolePresent, screen' == screen,
  tkstatus' == tkstatus, successBio' == successBio, successEntry' == successEntry,
  tokenRemovalDuration' == tokenRemovalDuration,
  tokenRemovalTimeout' == tokenRemovalTimeout, userToken' == userToken,
  writtenFloppy' == writtenFloppy;
use lTISPollPREStdUpdLemma;
rearrange;
with predicate (TISPollSig) simplify;
trivial simplify;
with predicate
  (               adminToken \in TOKENTRY \\
            \land alarm \in ALARM \\
            \land alarmSilentDuration \in \num \\
            \land alarmThresholdSize \in \num \\
            \land alarmTimeout \in \num \\
            \land auditAlarm \in ALARM \\
            \land auditLog \in \power Audit \\
            \land
             authPeriod
             \in \power (PRIVILEGE \cross \power (\num \cross \power \num)) \\
            \land availableOps \in \power ADMINOP \\
            \land currentAdminOp \in \power ADMINOP \\
            \land currentDisplay \in DISPLAYMESSAGE \\
            \land currentDoor \in DOOR \\
            \land currentScreen
                  \in \lblot screenConfig: SCREENTEXT; screenMsg: SCREENTEXT;
                             screenStats: SCREENTEXT \rblot \\
            \land now \in \num \\
            \land display \in DISPLAYMESSAGE \\
            \land door \in DOOR \\
            \land doorAlarm \in ALARM \\
            \land enclaveClearance \in \lblot class: CLASS \rblot \\
            \land enclaveStatus \in ENCLAVESTATUS \\
            \land
             entryPeriod
             \in \power (PRIVILEGE \cross \power (CLASS \cross \power \num)) \\
            \land failBio \in \num \\
            \land failEntry \in \num \\
            \land finger \in FINGERPRINTTRY \\
            \land floppy \in FLOPPY \\
            \land issuerKey \in \power (USER \cross KEYPART) \\
            \land keyboard \in KEYBOARD \\
            \land keyedDataPresence \in PRESENCE \\
            \land latch \in LATCH \\
            \land latchTimeout \in \num \\
            \land latchUnlockDuration \in \num \\
            \land minPreservedLogSize \in \num \\
            \land ownName \in \power USER \\
            \land rolePresent \in \power PRIVILEGE \\
            \land screen
                  \in \lblot screenConfig: SCREENTEXT; screenMsg: SCREENTEXT;
                             screenStats: SCREENTEXT \rblot \\
            \land tkstatus \in STATUS \\
            \land successBio \in \num \\
            \land successEntry \in \num \\
            \land tokenRemovalDuration \in \num \\
            \land tokenRemovalTimeout \in \num \\
            \land userToken \in TOKENTRY \\
            \land writtenFloppy \in FLOPPY \\
            \land
             \IF adminToken = noT \THEN absent \ELSE present \in PRESENCE \\
            \land \IF adminToken = noT \THEN currentAdminToken \ELSE adminToken
                  \in TOKENTRY \\
            \land \IF finger = noFP \THEN currentFinger \ELSE finger
                  \in FINGERPRINTTRY \\
            \land \IF floppy = noFloppy \THEN currentFloppy \ELSE floppy
                  \in FLOPPY \\
            \land \IF keyboard = noKB \THEN currentKeyedData \ELSE keyboard
                  \in KEYBOARD \\
            \land \IF currentDisplay = doorUnlocked \THEN unlocked \ELSE locked
                  \in LATCH \\
            \land \IF userToken = noT \THEN currentUserToken \ELSE userToken
                  \in TOKENTRY \\
            \land \IF finger = noFP \THEN absent \ELSE present \in PRESENCE \\
            \land
             \IF floppy = noFloppy \THEN absent \ELSE present \in PRESENCE \\
   \implies \lnot \IF userToken = noT \THEN absent \ELSE present \in PRESENCE)
  with enabled (lOptionalWeakening) rewrite;
use lOptionalWeakening3[PRIVILEGE][S := ADMINPRIVILEGE, x := rolePresent];
rearrange;
rewrite;
\end{}

invoke TISPoll;
rearrange;
invoke \Xi RealWorld;
invoke \Xi Config;
invoke \Xi KeyStore;
invoke \Xi Admin;
invoke \Xi Stats;
invoke \Xi Internal;
rearrange;
invoke TISPollSig;
invoke PollTime;
invoke PollTimeSig;
invoke PollDoor;
invoke PollDoorSig;
invoke PollUserToken;
invoke PollAdminToken;
invoke PollFinger;
invoke PollFloppy;
invoke PollKeyboard;
invoke PollKeyboardSig;
invoke \Delta IDStation;
invoke \Delta UserToken;
invoke \Delta AdminToken;
invoke \Delta Finger;
invoke \Delta Floppy;
invoke \Delta DoorLatchAlarm;
rearrange;
simplify;
invoke Floppy;
invoke DoorLatchAlarm;
invoke IDStation;
simplify;
prove by rewrite;

â”€ theorem tUpdateLatchPRE 
âˆ€ DoorLatchAlarm ; RealWorld â¦ pre UpdateLatch 
â”” 

â”œ tUpdateLatchPRE 
invoke UpdateLatch ;  
invoke RealWorldChanges ;  
invoke ÎDoorLatchAlarm ;  
invoke Î”RealWorld ;  
invoke RealWorld ;  
invoke TISControlledRealWorld ;  
invoke TISMonitoredRealWorld ;  
rewrite ;  
instantiate adminTokenâ€² == adminToken , alarmâ€² == alarm , displayâ€² == display , doorâ€² == door , fingerâ€² == finger , floppyâ€² == floppy , keyboardâ€² == keyboard , userTokenâ€² == userToken , screenâ€² == screen , nowâ€² == now ;  
invoke TIME ;  
rewrite ;  
â”” 

â”€ theorem tUpdateAlarmPRE 
âˆ€ DoorLatchAlarm ; RealWorld ; AuditLog â¦ pre UpdateAlarm 
â”” 

â”œ tUpdateAlarmPRE 
invoke UpdateAlarm ;  
invoke ÎDoorLatchAlarm ;  
invoke RealWorldChanges ;  
invoke AuditLog ;  
invoke Î”RealWorld ;  
rearrange ;  
rewrite ;  
split doorAlarm = alarming ;  
cases ;  
instantiate adminTokenâ€² == adminToken , alarmâ€² == alarming , displayâ€² == display , doorâ€² == door , fingerâ€² == finger , floppyâ€² == floppy , keyboardâ€² == keyboard , userTokenâ€² == userToken , screenâ€² == screen , nowâ€² == now , latchâ€² == latch ;  
invoke RealWorld ;  
invoke TISMonitoredRealWorld ;  
invoke TISControlledRealWorld ;  
invoke TIME ;  
rewrite ;  
next ;  
rearrange ;  
simplify ;  
instantiate adminTokenâ€² == adminToken , alarmâ€² == silent , displayâ€² == display , doorâ€² == door , fingerâ€² == finger , floppyâ€² == floppy , keyboardâ€² == keyboard , userTokenâ€² == userToken , screenâ€² == screen , nowâ€² == now , latchâ€² == latch ;  
invoke RealWorld ;  
invoke TISControlledRealWorld ;  
invoke TISMonitoredRealWorld ;  
invoke TIME ;  
rewrite ;  
simplify ;  
rearrange ;  
instantiate adminTokenâ€² == adminToken , displayâ€² == display , doorâ€² == door , fingerâ€² == finger , floppyâ€² == floppy , keyboardâ€² == keyboard , userTokenâ€² == userToken , screenâ€² == screen , nowâ€² == now , latchâ€² == latch ;  
rewrite ;  
next ;  
â”” 

â”€ theorem lIDStationDoorLatchAlarmInv 
âˆ€ IDStation â¦ DoorLatchAlarm 
â”” 

â”œ lIDStationDoorLatchAlarmInv 
simplify ;  
â”” 

â”€ theorem lIDStationCurrentTimeUpdateLemma 
âˆ€ IDStation ; PollTimeSig â¦ IDStation [ now / currentTime ] 
â”” 

â”œ lIDStationCurrentTimeUpdateLemma 
invoke predicate IDStation [ now / currentTime ] ;  
simplify ;  
cases ;  
use lIDStationDoorLatchAlarmInv ;  
invoke DoorLatchAlarm ;  
rearrange ;  
simplify ;  
invoke PollTimeSig ;  
simplify ;  
next ;  
next ;  
next ;  
next ;  
next ;  
next ;  
next ;  
next ;  
next ;  
invoke IDStation ;  
simplify ;  
â”” 

â”€ theorem tUpdateDisplayPRE 
âˆ€ IDStation ; RealWorld â¦ pre UpdateDisplay 
â”” 

â”œ tUpdateDisplayPRE 
instantiate currentTimeâ€² == currentTime , currentUserTokenâ€² == currentUserToken , userTokenPresenceâ€² == userTokenPresence , currentAdminTokenâ€² == currentAdminToken , adminTokenPresenceâ€² == adminTokenPresence , currentFingerâ€² == currentFinger , fingerPresenceâ€² == fingerPresence , currentFloppyâ€² == currentFloppy , floppyPresenceâ€² == floppyPresence , currentKeyedDataâ€² == currentKeyedData , currentLatchâ€² == currentLatch , adminTokenâ€² == adminToken , alarmâ€² == alarm , alarmSilentDurationâ€² == alarmSilentDuration , alarmThresholdSizeâ€² == alarmThresholdSize , alarmTimeoutâ€² == alarmTimeout , auditAlarmâ€² == auditAlarm , auditLogâ€² == auditLog , authPeriodâ€² == authPeriod , availableOpsâ€² == availableOps , currentAdminOpâ€² == currentAdminOp , currentDoorâ€² == currentDoor , currentScreenâ€² == currentScreen , doorâ€² == door , doorAlarmâ€² == doorAlarm , enclaveClearanceâ€² == enclaveClearance , enclaveStatusâ€² == enclaveStatus , entryPeriodâ€² == entryPeriod , failBioâ€² == failBio , failEntryâ€² == failEntry , fingerâ€² == finger , floppyâ€² == floppy , issuerKeyâ€² == issuerKey , keyboardâ€² == keyboard , keyedDataPresenceâ€² == keyedDataPresence , latchâ€² == latch , latchTimeoutâ€² == latchTimeout , latchUnlockDurationâ€² == latchUnlockDuration , minPreservedLogSizeâ€² == minPreservedLogSize , nowâ€² == now , ownNameâ€² == ownName , rolePresentâ€² == rolePresent , screenâ€² == screen , tkstatusâ€² == tkstatus , successBioâ€² == successBio , successEntryâ€² == successEntry , tokenRemovalDurationâ€² == tokenRemovalDuration , tokenRemovalTimeoutâ€² == tokenRemovalTimeout , userTokenâ€² == userToken , writtenFloppyâ€² == writtenFloppy ;  
with disabled ( IDStation , PollTimeSig ) invoke ;  
rearrange ;  
rewrite ;  
use lOptionalWeakening3 [ PRIVILEGE ] [ S := ADMINPRIVILEGE , x := rolePresent ] ;  
use lOptionalWeakening3 [ USER ] [ S := ISSUER , x := ownName ] ;  
rearrange ;  
rewrite ;  
apply lOptionalWeakening ;  
rewrite ;  
â”” 

â”€ theorem frule fIDStationOwnNameMaxOptType 
âˆ€ IDStation â¦ ownName âˆˆ Optional USER 
â”” 

â”œ fIDStationOwnNameMaxOptType 
use lOptionalWeakening3 [ USER ] [ S := ISSUER , x := ownName ] ;  
prove by rewrite ;  
â”” 

â”€ theorem frule fIDStationRolePresentMaxOptType 
âˆ€ IDStation â¦ rolePresent âˆˆ Optional PRIVILEGE 
â”” 

â”œ fIDStationRolePresentMaxOptType 
use lOptionalWeakening3 [ PRIVILEGE ] [ S := ADMINPRIVILEGE , x := rolePresent ] ;  
prove by rewrite ;  
â”” 

â”€ theorem frule fIDStationCurrentAdminOpMaxOptType 
âˆ€ IDStation â¦ currentAdminOp âˆˆ Optional ADMINOP 
â”” 

â”œ fIDStationCurrentAdminOpMaxOptType 
use lOptionalWeakening3 [ ADMINOP ] [ S := ADMINOP , x := currentAdminOp ] ;  
prove by rewrite ;  
â”” 

â”€ theorem frule fIDStationCurrentScreenType 
âˆ€ IDStation â¦ currentScreen âˆˆ Screen 
â”” 

â”œ fIDStationCurrentScreenType 
invoke IDStation ;  
simplify ;  
â”” 

â”€ theorem fIDStationAdminInv 
âˆ€ IDStation â¦ Admin 
â”” 

â”œ fIDStationAdminInv 
invoke IDStation ;  
simplify ;  
â”” 

Although this precondition is just $true$, it is a rather convoluted because of
the (unhelpful) way conditional and various other invariants were (logically) given.
\The next lemma illustrates this by providing a simpler formulation that is equivalent
to the one in Admin.
â”€ theorem tUpdateScreenPRE 
âˆ€ IDStation ; RealWorld â¦ pre UpdateScreen 
â”” 

â”œ tUpdateScreenPRE 
instantiate currentTimeâ€² == currentTime , currentUserTokenâ€² == currentUserToken , userTokenPresenceâ€² == userTokenPresence , currentAdminTokenâ€² == currentAdminToken , adminTokenPresenceâ€² == adminTokenPresence , currentFingerâ€² == currentFinger , fingerPresenceâ€² == fingerPresence , currentFloppyâ€² == currentFloppy , floppyPresenceâ€² == floppyPresence , currentKeyedDataâ€² == currentKeyedData , currentLatchâ€² == currentLatch , adminTokenâ€² == adminToken , alarmâ€² == alarm , alarmSilentDurationâ€² == alarmSilentDuration , alarmThresholdSizeâ€² == alarmThresholdSize , alarmTimeoutâ€² == alarmTimeout , auditAlarmâ€² == auditAlarm , auditLogâ€² == auditLog , authPeriodâ€² == authPeriod , availableOpsâ€² == availableOps , currentAdminOpâ€² == currentAdminOp , currentDoorâ€² == currentDoor , currentScreenâ€² == currentScreen , doorâ€² == door , doorAlarmâ€² == doorAlarm , enclaveClearanceâ€² == enclaveClearance , enclaveStatusâ€² == enclaveStatus , entryPeriodâ€² == entryPeriod , failBioâ€² == failBio , failEntryâ€² == failEntry , fingerâ€² == finger , floppyâ€² == floppy , issuerKeyâ€² == issuerKey , keyboardâ€² == keyboard , keyedDataPresenceâ€² == keyedDataPresence , latchâ€² == latch , latchTimeoutâ€² == latchTimeout , latchUnlockDurationâ€² == latchUnlockDuration , minPreservedLogSizeâ€² == minPreservedLogSize , nowâ€² == now , ownNameâ€² == ownName , rolePresentâ€² == rolePresent , tkstatusâ€² == tkstatus , successBioâ€² == successBio , successEntryâ€² == successEntry , tokenRemovalDurationâ€² == tokenRemovalDuration , tokenRemovalTimeoutâ€² == tokenRemovalTimeout , userTokenâ€² == userToken , writtenFloppyâ€² == writtenFloppy , currentDisplayâ€² == currentDisplay , displayâ€² == display , screenâ€² == Î¸ ( Screen [ screenMsg := currentScreen . screenMsg , screenConfig := if ( rolePresent â‰  Nil âˆ§ The rolePresent = securityOfficer ) then currentScreen . screenConfig else clear , screenStats := if ( rolePresent â‰  Nil ) then currentScreen . screenStats else clear ] ) ;  
use fIDStationCurrentScreenType ;  
use fIDStationAdminInv ;  
with disabled ( IDStation , ADMINPRIVILEGE ) invoke ;  
invoke Nil ;  
rearrange ;  
apply Screen$member to predicate currentScreen âˆˆ Screen ;  
prenex ;  
with predicate ( IDStation ) simplify ;  
equality substitute currentScreen ;  
with enabled ( lOptionalWeakening ) rewrite ;  
invoke Screen ;  
prove by rewrite ;  
â”” 

â”€ â˜’ theorem rule lSizeLogCup 
âˆ€ log : ğ”½ Audit ; entry : Audit â¦ sizeLog ( log âˆª { entry } ) = sizeLog ( log âˆ– { entry } ) + sizeElement entry 
â”” 

â”œ lSizeLogCup 
apply cupCommutes ;  
with disabled ( cupCommutes ) rewrite ;  
apply dSizeLogInduc ;  
rewrite ;  
â”” 

â”€ â˜’ theorem rule lSizeLogSetDiff 
âˆ€ log : ğ”½ Audit ; entry : Audit â¦ sizeLog ( log âˆ– { entry } ) = sizeLog log âˆ’ ( if ( entry âˆˆ log ) then sizeElement entry else 0 ) 
â”” 

â”œ lSizeLogSetDiff 
rewrite ;  
use dSizeLogInduc ;  
rearrange ;  
apply cupSubsetLeft to expression { entry } âˆª log ;  
rewrite ;  
equality substitute ;  
rewrite ;  
â”” 

â”€ theorem lAuditWitness 
âˆƒ adt : Audit â¦ true 
â”” 

â”œ lAuditWitness 
use dAuditNotEmpty ;  
prove by rewrite ;  
apply extensionality ;  
prove by rewrite ;  
instantiate adt == x ;  
prove by rewrite ;  
â”” 

â”Œ AddElementsToLogSig 
Config 
AuditLog |
 âˆƒ newLog : ğ”½â†˜1â†– Audit â¦ oldestLogTime newLog â‰¥ newestLogTime auditLog â”” 

â”œ AddElementsToLogSig$domainCheck 
prove by rewrite ;  
â”” 

â”€ â˜’ theorem rule lSizeLogSingleton 
âˆ€ x : Audit â¦ sizeLog { x } = sizeElement x 
â”” 

â”œ lSizeLogSingleton 
use dSizeLogInduc [ log := { } , entry := x ] ;  
with enabled ( dSizeLogBase ) prove by rewrite ;  
â”” 

â”€ â˜’ theorem rule lElemUnionDiffAbsorption [ X ] 
âˆ€ x : X ; S : â„™ X | x âˆˆ S â¦ { x } âˆª ( S âˆ– { x } ) = S 
â”” 

â”œ lElemUnionDiffAbsorption 
apply extensionality to predicate { x } ( _ âˆª _ ) [ X ] ( S ( _ âˆ– _ ) [ X ] { x } ) = S ;  
prenex ;  
with normalization rewrite ;  
â”” 

â”€ â˜’ theorem rule lCupDisThroughDiff [ X ] 
âˆ€ x : X ; S , R : â„™ X | Â¬ x âˆˆ S â¦ S âˆª ( R âˆ– { x } ) = S âˆª R âˆ– { x } 
â”” 

â”œ lCupDisThroughDiff 
apply extensionality to predicate S ( _ âˆª _ ) [ X ] ( R ( _ âˆ– _ ) [ X ] { x } ) = ( S ( _ âˆª _ ) [ X ] R ) ( _ âˆ– _ ) [ X ] { x } ;  
prove by rewrite ;  
â”” 

â”€ theorem rule lCapDisThroughDiff [ X ] 
âˆ€ x : X ; S , R : â„™ X â¦ S âˆ© ( R âˆ– { x } ) = S âˆ© R âˆ– { x } 
â”” 

â”œ lCapDisThroughDiff 
apply extensionality to predicate ( _ âˆ© _ ) [ X ] ( S , ( ( _ âˆ– _ ) [ X ] ( R , { x } ) ) ) = ( _ âˆ– _ ) [ X ] ( ( _ âˆ© _ ) [ X ] ( S , R ) , { x } ) ;  
prove by rewrite ;  
â”” 

â”€ theorem lSizeLogCupSumZEves 
ğ”½ Audit âŠ† { v : ğ”½ Audit | âˆ€ r , s : ğ”½ Audit | r âˆª s = v â¦ sizeLog r + sizeLog s = sizeLog ( r âˆª s ) + sizeLog ( r âˆ© s ) } 
â”” 

â”œ lSizeLogCupSumZEves 
apply finiteInduction ;  
with enabled ( dSizeLogBase ) prove by rewrite ;  
apply lSizeLogCup to expression sizeLog ( Y âˆª { x } ) ;  
rewrite ;  
apply lSizeLogSetDiff to expression sizeLog ( Y âˆ– { x } ) ;  
rewrite ;  
split x âˆˆ Y ;  
rewrite ;  
cases ;  
apply cupSubsetRight to expression Y âˆª { x } ;  
instantiate r__0 == r , s__0 == s ;  
prove by rewrite ;  
next ;  
split x âˆˆ r âˆ§ x âˆ‰ s ;  
rewrite ;  
cases ;  
instantiate r__0 == r âˆ– { x } , s__0 == s ;  
rearrange ;  
rewrite ;  
apply lCupDisThroughDiff to expression s âˆª ( r âˆ– { x } ) ;  
rewrite ;  
apply lSizeLogSetDiff ;  
rewrite ;  
split r âˆª s âˆ– { x } = Y ;  
cases ;  
equality substitute ;  
rearrange ;  
apply lSizeLogSetDiff to expression sizeLog ( r âˆª s âˆ– { x } ) ;  
rewrite ;  
next ;  
rearrange ;  
rewrite ;  
apply extensionality to predicate r âˆª s âˆ– { x } = Y ;  
prove by rewrite ;  
next ;  
prove by rewrite ;  
split x âˆˆ r ;  
simplify ;  
cases ;  
instantiate r__0 == r âˆ– { x } , s__0 == s âˆ– { x } ;  
rearrange ;  
rewrite ;  
next ;  
simplify ;  
instantiate r__0 == r , s__0 == s âˆ– { x } ;  
rearrange ;  
rewrite ;  
apply lCupDisThroughDiff to expression r âˆª ( s âˆ– { x } ) ;  
rewrite ;  
apply lSizeLogSetDiff ;  
rewrite ;  
split r âˆª s âˆ– { x } = Y ;  
simplify ;  
cases ;  
equality substitute ;  
rewrite ;  
apply extensionality to predicate r âˆª s = { x } âˆª ( r âˆª s âˆ– { x } ) ;  
prove by rewrite ;  
apply lSizeLogSetDiff to expression sizeLog ( r âˆª s âˆ– { x } ) ;  
instantiate y == x ;  
rewrite ;  
next ;  
apply extensionality to predicate r âˆª s âˆ– { x } = Y ;  
prove by rewrite ;  
next ;  
use distributeDiffOverCupLeft [ Audit ] [ A := s , B := r , C := { x } ] ;  
rearrange ;  
rewrite ;  
equality substitute r âˆ– { x } âˆª ( s âˆ– { x } ) ;  
apply lSizeLogSetDiff ;  
rewrite ;  
split r âˆª s âˆ– { x } = Y ;  
simplify ;  
cases ;  
equality substitute ;  
apply lSizeLogSetDiff to expression sizeLog ( r âˆª s âˆ– { x } ) ;  
rewrite ;  
next ;  
apply extensionality to predicate r âˆª s âˆ– { x } = Y ;  
prove by rewrite ;  
apply distributeDiffOverCupLeft to expression Y âˆª { x } âˆ– { x } ;  
rewrite ;  
equality substitute ;  
rewrite ;  
next ;  
â”” 

â”€ â˜’ theorem rule lSizeLogCupSum 
âˆ€ a , b : ğ”½ Audit â¦ sizeLog a + sizeLog b = sizeLog ( a âˆª b ) + sizeLog ( a âˆ© b ) 
â”” 

â”œ lSizeLogCupSum 
use lSizeLogCupSumZEves ;  
prove by rewrite ;  
apply inPower ;  
prove by rewrite ;  
instantiate r == a , s == b ;  
rearrange ;  
rewrite ;  
â”” 

â”€ theorem tAddElementsToLogPRE 
âˆ€ AddElementsToLogSig â¦ pre AddElementsToLog 
â”” 

â”œ tAddElementsToLogPRE 
use lAuditWitness ;  
invoke AddElementsToLog ;  
invoke Î”AuditLog ;  
prove by rewrite ;  
invoke AddElementsToLogSig ;  
invoke AuditLog ;  
prenex ;  
instantiate newElements == newLog , oldElements == auditLog ;  
prove by rewrite ;  
split sizeLog ( auditLog âˆª newLog ) < alarmThresholdSize ;  
rewrite ;  
cases ;  
instantiate auditAlarmâ€² == auditAlarm , auditLogâ€² == auditLog âˆª newLog ;  
rewrite ;  
next ;  
rearrange ;  
rewrite ;  
instantiate auditLogâ€² == auditLog âˆª newLog , auditAlarmâ€² == alarming ;  
use applyInRanFun [ ğ”½ Audit , TIME ] [ f := sizeLog , a := auditLog âˆª newLog ] ;  
invoke Config ;  
invoke TIME ;  
prove by rewrite ;  
split sizeLog ( auditLog âˆª newLog ) â‰¥ 0 ;  
simplify ;  
next ;  
â”” 

â”€ AddElementsToLogState == Config âˆ§ Î”AuditLog â”” 

â”Œ AddElementsToLog00 
AddElementsToLogState 
newElements : ğ”½â†˜1â†– Audit |
 oldestLogTime newElements â‰¥ newestLogTime auditLog 
auditLogâ€² = auditLog âˆª newElements 
sizeLog auditLogâ€² < alarmThresholdSize 
auditAlarmâ€² = auditAlarm â”” 

â”œ AddElementsToLog00$domainCheck 
prove by rewrite ;  
â”” 

â”Œ AddElementsToLog01 
AddElementsToLogState 
newElements : ğ”½â†˜1â†– Audit |
 oldestLogTime newElements â‰¥ newestLogTime auditLog 
auditLogâ€² = auditLog âˆª newElements 
sizeLog auditLogâ€² â‰¥ alarmThresholdSize 
auditAlarmâ€² = alarming â”” 

â”œ AddElementsToLog01$domainCheck 
prove by rewrite ;  
â”” 

â”€ AddElementsToLog0 == AddElementsToLog00 âˆ¨ AddElementsToLog01 â”” 

â”Œ AddElementsToLog1 
AddElementsToLogState 
newElements : ğ”½â†˜1â†– Audit |
 oldestLogTime newElements â‰¥ newestLogTime auditLog 
sizeLog auditLog + sizeLog newElements > minPreservedLogSize 
âˆƒ oldElements : ğ”½ Audit â¦ oldElements âˆª auditLogâ€² = auditLog âˆª newElements âˆ§ oldestLogTime auditLogâ€² â‰¥ newestLogTime oldElements 
sizeLog auditLogâ€² â‰¥ minPreservedLogSize 
auditAlarmâ€² = alarming â”” 

â”œ AddElementsToLog1$domainCheck 
prove by rewrite ;  
â”” 

â”€ AddElementsToLog20 == AddElementsToLog0 âˆ¨ AddElementsToLog1 â”” 

â”€ AddElementsToLog2 == AddElementsToLog20 âˆ– ( newElements ) â”” 

â”€ â˜’ theorem rule lAddElementsToLogEquiv 
AddElementsToLog â‡” AddElementsToLog2 
â”” 

â”œ lAddElementsToLogEquiv 
split AddElementsToLog ;  
simplify ;  
cases ;  
with disabled ( Config , AuditLog ) prove by reduce ;  
instantiate newElements__0 == newElements , oldElements__0 == oldElements ;  
with normalization rewrite ;  
next ;  
split AddElementsToLog2 ;  
simplify ;  
invoke AddElementsToLog2 ;  
prenex ;  
invoke AddElementsToLog20 ;  
split AddElementsToLog1 ;  
simplify ;  
cases ;  
with disabled ( Config , AuditLog ) prove by reduce ;  
instantiate newElements__0 == newElements , oldElements__0 == oldElements ;  
prove by rewrite ;  
next ;  
invoke AddElementsToLog0 ;  
split AddElementsToLog01 ;  
simplify ;  
cases ;  
with disabled ( Config , AuditLog , AddElementsToLog1 ) prove by reduce ;  
instantiate newElements__0 == newElements ;  
prove by rewrite ;  
next ;  
with disabled ( Config , AuditLog , AddElementsToLog1 , AddElementsToLog01 ) prove by reduce ;  
instantiate newElements__0 == newElements ;  
prove by rewrite ;  
next ;  
â”” 

â”Œ AddElementsToLog00Sig 
Config 
AuditLog |
 âˆƒ newLog : ğ”½â†˜1â†– Audit â¦ oldestLogTime newLog â‰¥ newestLogTime auditLog âˆ§ sizeLog ( auditLog âˆª newLog ) < alarmThresholdSize â”” 

â”œ AddElementsToLog00Sig$domainCheck 
prove by rewrite ;  
â”” 

â”€ theorem tAddElementsToLog00PRE 
âˆ€ AddElementsToLog00Sig â¦ âˆƒ newElements : ğ”½â†˜1â†– Audit â¦ pre AddElementsToLog00 
â”” 

â”œ tAddElementsToLog00PRE 
with disabled ( Config ) prove by reduce ;  
â”” 

â”Œ AddElementsToLog01Sig 
Config 
AuditLog |
 âˆƒ newLog : ğ”½â†˜1â†– Audit â¦ oldestLogTime newLog â‰¥ newestLogTime auditLog âˆ§ sizeLog ( auditLog âˆª newLog ) â‰¥ alarmThresholdSize â”” 

â”œ AddElementsToLog01Sig$domainCheck 
prove by rewrite ;  
â”” 

â”€ theorem tAddElementsToLog01PRE 
âˆ€ AddElementsToLog01Sig â¦ âˆƒ newElements : ğ”½â†˜1â†– Audit â¦ pre AddElementsToLog01 
â”” 

â”œ tAddElementsToLog01PRE 
with disabled ( Config ) prove by reduce ;  
â”” 

â”€ theorem tAddElementsToLog0PRE 
âˆ€ AddElementsToLogSig â¦ âˆƒ newElements : ğ”½â†˜1â†– Audit â¦ pre AddElementsToLog0 
â”” 

â”œ tAddElementsToLog0PRE 
with disabled ( Config ) prove by reduce ;  
instantiate newElements == newLog , auditAlarmâ€² == if ( sizeLog ( auditLog âˆª newLog ) < alarmThresholdSize ) then auditAlarm else alarming , auditLogâ€² == auditLog âˆª newLog ;  
prove by rewrite ;  
invoke Config ;  
invoke TIME ;  
use applyInRanFun [ ğ”½ Audit , â„• ] [ f := sizeLog , a := auditLog âˆª newLog ] ;  
prove by rewrite ;  
split sizeLog ( auditLog âˆª newLog ) â‰¥ 0 ;  
simplify ;  
â”” 

â”Œ AddElementsToLog1Sig 
Config 
AuditLog |
 âˆƒ newLog : ğ”½â†˜1â†– Audit â¦ oldestLogTime newLog â‰¥ newestLogTime auditLog âˆ§ sizeLog auditLog + sizeLog newLog > minPreservedLogSize âˆ§ auditLog âˆ© newLog = âˆ… âˆ§ ( âˆƒ oldLog : ğ”½ Audit â¦ ( oldLog = auditLog âˆª newLog âˆ§ oldestLogTime oldLog â‰¥ newestLogTime ( oldLog âˆ– newLog ) ) ) â”” 

â”œ AddElementsToLog1Sig$domainCheck 
prove by rewrite ;  
â”” 

â”€ â˜’ theorem rule lCupAbsorbsDisjointSetDiff [ X ] 
âˆ€ S , R : â„™ X | S âˆ© R = { } â¦ S âˆª R âˆ– R = S 
â”” 

â”œ lCupAbsorbsDisjointSetDiff 
apply extensionality ;  
prove by rewrite ;  
instantiate x == y ;  
prove by rewrite ;  
â”” 

â”€ theorem tAddElementsToLog1PRE 
âˆ€ AddElementsToLog1Sig â¦ âˆƒ newElements : ğ”½â†˜1â†– Audit â¦ pre AddElementsToLog1 
â”” 

â”œ tAddElementsToLog1PRE 
with disabled ( Config ) prove by reduce ;  
instantiate newElements == newLog , oldElements == auditLog , auditLogâ€² == auditLog âˆª newLog ;  
prove by rewrite ;  
apply cupSubsetLeft to expression auditLog âˆª ( auditLog âˆª newLog ) ;  
prove by rewrite ;  
apply lSizeLogCupSum to expression sizeLog auditLog + sizeLog newLog ;  
prove by rewrite ;  
split auditLog âˆ© newLog = { } ;  
with enabled ( dSizeLogBase ) rewrite ;  
apply lCupAbsorbsDisjointSetDiff to expression auditLog âˆª newLog âˆ– newLog ;  
rewrite ;  
â”” 

â”€ theorem tAddElementsToLog2PRE 
âˆ€ AddElementsToLogSig â¦ pre AddElementsToLog2 
â”” 

â”œ tAddElementsToLog2PRE 
use tAddElementsToLogPRE ;  
prenex ;  
use lAddElementsToLogEquiv ;  
prove by rewrite ;  
instantiate auditAlarm__0â€² == auditAlarmâ€² , auditLog__0â€² == auditLogâ€² ;  
rewrite ;  
â”” 

â”Œ ArchiveLogSig 
Config 
AuditLog 
archive : ğ”½ Audit |
 âˆƒ ignored : ğ”½ Audit â¦ newestLogTime archive â‰¤ oldestLogTime ignored â”” 

â”œ ArchiveLogSig$domainCheck 
prove by rewrite ;  
â”” 

â”€ theorem tArchiveLogPRE 
âˆ€ ArchiveLogSig â¦ pre ArchiveLog 
â”” 

â”œ tArchiveLogPRE 
use tAddElementsToLogPRE ;  
rearrange ;  
prenex ;  
rewrite ;  
invoke ArchiveLogSig ;  
invoke ArchiveLog ;  
invoke Î”AuditLog ;  
invoke AuditLog ;  
with disabled ( subsetDef ) prove by rewrite ;  
instantiate auditAlarm__0â€² == auditAlarmâ€² , auditLog__0â€² == archive âˆª auditLog ;  
with disabled ( subsetDef ) prove by rewrite ;  
instantiate newElements == archive , notArchived == ignored ;  
rewrite ;  
invoke AddElementsToLog ;  
prenex ;  
split sizeLog auditLog + sizeLog newElements > minPreservedLogSize âˆ§ oldElements âˆˆ ğ”½ Audit âˆ§ oldElements âˆª auditLogâ€² = auditLog âˆª newElements âˆ§ oldestLogTime auditLogâ€² â‰¥ newestLogTime oldElements âˆ§ sizeLog auditLogâ€² â‰¥ minPreservedLogSize âˆ§ auditAlarmâ€² = alarming ;  
simplify ;  
cases ;  
rearrange ;  
split auditLogâ€² = auditLog âˆª newElements âˆ§ ( sizeLog auditLogâ€² < alarmThresholdSize âˆ§ auditAlarmâ€² = auditAlarm âˆ¨ sizeLog auditLogâ€² â‰¥ alarmThresholdSize âˆ§ auditAlarmâ€² = alarming ) ;  
simplify ;  
cases ;  
simplify ;  
rewrite ;  
â”” 



