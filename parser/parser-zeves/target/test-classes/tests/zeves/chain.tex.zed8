‚îÄ section chain parents standard_toolkit , zeves_toolkit ‚îî 


\section{Transitive closure}

\begin{LToolkit}[Unit set in $\_\plus$]
‚îÄ ‚òí theorem rule lUnitTransitiveClosure [ X ] 
‚àÄ x , y : X ‚¶Å ( x , y ) ‚àà { ( x , y ) } ‚Üó+‚Üô 
‚îî \end{LToolkit}

\begin{LToolkit}[$\_\plus$ element in $\_\plus$-$\cup$]
‚îÄ ‚òí theorem rule lUnionTransitiveClosure [ X ] 
‚àÄ x , y , z , w : X ; R : X ‚Üî X | ( x , y ) ‚àà R ‚Üó+‚Üô ‚¶Å ( x , y ) ‚àà ( R ‚à™ { ( z , w ) } ) ‚Üó+‚Üô 
‚îî \end{LToolkit}

\begin{LTrivial}[$\_\plus$ element in $\_\plus$-$\cup$]
‚îÄ ‚òí theorem rule lUnionTransitiveClosure2 [ X ] 
‚àÄ x , y , z , w : X ; R : X ‚Üî X | ( x , y ) ‚àà R ‚Üó+‚Üô ‚¶Å ( x , y ) ‚àà ( { ( z , w ) } ‚à™ R ) ‚Üó+‚Üô 
‚îî \end{LTrivial}

\begin{LToolkit}[$R$ element is in $R\plus$]
‚îÄ ‚òí theorem rule lInTransitiveClosure [ X ] 
‚àÄ x , y : X ; R : X ‚Üî X | ( x , y ) ‚àà R ‚¶Å ( x , y ) ‚àà R ‚Üó+‚Üô 
‚îî \end{LToolkit}

\begin{LToolkit}[$R\plus$-$\cup$ links]
‚îÄ ‚òí theorem rule lUnionSingletonTransitiveClosure [ X ] 
‚àÄ x , y , z : X ; R : X ‚Üî X | ¬¨ ( x , y ) ‚àà R ‚Üó+‚Üô ‚àß ( x , z ) ‚àà R ‚Üó+‚Üô ‚¶Å ( x , y ) ‚àà ( R ‚à™ { ( z , y ) } ) ‚Üó+‚Üô 
‚îî \end{LToolkit}

\begin{LTrivial}[$R\plus$-$\cup$ links]
‚îÄ ‚òí theorem rule lUnionSingletonTransitiveClosure2 [ X ] 
‚àÄ x , y , z : X ; R : X ‚Üî X | ¬¨ ( x , y ) ‚àà R ‚Üó+‚Üô ‚àß ( x , z ) ‚àà R ‚Üó+‚Üô ‚¶Å ( x , y ) ‚àà ( { ( z , y ) } ‚à™ R ) ‚Üó+‚Üô 
‚îî \end{LTrivial}

\begin{LToolkit}[$R\plus$ weakening - $\exists$]
‚îÄ ‚òí theorem rule lTransitiveClosureElem [ X ] 
‚àÄ x , y : X ; R : X ‚Üî X | ‚àÉ v : X ‚¶Å ( x , v ) ‚àà R ‚àß ( v , y ) ‚àà R ‚¶Å ( x , y ) ‚àà R ‚Üó+‚Üô 
‚îî \end{LToolkit}

\begin{LRRT}[$R\plus$ element maximal type]
‚îÄ ‚òí theorem rule lTransitiveClosureElemType [ X ] 
‚àÄ R : X ‚Üî X | x ‚àà R ‚Üó+‚Üô ‚¶Å x ‚àà X √ó X 
‚îî \end{LRRT}

The next $5$ lemmas came from Isabelle/HOL's
\texttt{Transitive\_Closure} theory (\texttt{trancl.ML}, 1992).
\begin{LToolkit}[Elements in sequence are transitively closed]
‚îÄ ‚òí theorem rule lIsaHolIntoTransitiveClosure [ X ] 
‚àÄ a , b , c : X ; R : X ‚Üî X | ( a , b ) ‚àà R ‚àß ( b , c ) ‚àà R ‚¶Å ( a , c ) ‚àà R ‚Üó+‚Üô 
‚îî \end{LToolkit}

\begin{LToolkit}[Transitive closure entails element]
‚îÄ ‚òí theorem rule lIsaHolTransitiveClosureEntails [ X ] 
‚àÄ a , b , c : X ; R : X ‚Üî X | ( a , b ) ‚àà R ‚Üó+‚Üô ‚àß ( b , c ) ‚àà R ‚¶Å ( a , c ) ‚àà R ‚Üó+‚Üô 
‚îî \end{LToolkit}

\begin{LToolkit}[Transitive closure (implicitly) entails element]
‚îÄ ‚òí theorem rule lIsaHolTransitiveClosureEntails2 [ X ] 
‚àÄ a , c : X ; R : X ‚Üî X | ‚àÉ b : X ‚¶Å ( a , b ) ‚àà R ‚Üó+‚Üô ‚àß ( b , c ) ‚àà R ‚¶Å ( a , c ) ‚àà R ‚Üó+‚Üô 
‚îî \end{LToolkit}

\begin{LToolkit}[Transitive closure leads to element]
‚îÄ ‚òí theorem rule lIsaHolTransitiveClosureLeadsTo [ X ] 
‚àÄ a , b , c : X ; R : X ‚Üî X | ( a , b ) ‚àà R ‚àß ( b , c ) ‚àà R ‚Üó+‚Üô ‚¶Å ( a , c ) ‚àà R ‚Üó+‚Üô 
‚îî \end{LToolkit}

\begin{LToolkit}[Transitive closure is transitive]
‚îÄ ‚òí theorem rule lIsaHolTransitiveClosureTransitive [ X ] 
‚àÄ a , b , c : X ; R : X ‚Üî X | ( a , b ) ‚àà R ‚Üó+‚Üô ‚àß ( b , c ) ‚àà R ‚Üó+‚Üô ‚¶Å ( a , c ) ‚àà R ‚Üó+‚Üô 
‚îî \end{LToolkit}
\sectionproof{Transitive closure}{theories-transitive-closure}

\begin{LPScript}\begin{forget}[lUnitTransitiveClosure]
apply plusDef to expression \{~(x, y)~\} \plus [X];
prove by rewrite;
\end{forget}
\end{LPScript}

\begin{LPScript}\begin{forget}[lUnionTransitiveClosure]
apply plusDef;
prove by rewrite;
instantiate B\_\_0 == B;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lUnionTransitiveClosure2]
use lUnionTransitiveClosure[X];
prove by rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lInTransitiveClosure]
apply plusDef;
prove by rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lUnionSingletonTransitiveClosure]
apply lInTransitiveClosure;
rewrite;
split (x, z) \in  R;
prove by rewrite;
cases;
apply plusDef to expression (R \cup [(X \cross  X)] \{~(z, y)~\}) \plus [X];
prove by rewrite;
apply inPower to predicate R \in  \power~  B;
apply inPower to predicate B \comp [X, X, X] B \in  \power~  B;
instantiate e == (x, z);
instantiate e\_\_0 == (x, y);
prove by rewrite;
instantiate y\_\_0 == z;
prove by rewrite;
next;
rearrange;
apply plusDef to expression R \plus [X];
rewrite;
prenex;
with disabled (subsetDef) rewrite;
instantiate B\_\_0 == B;
with disabled (subsetDef) rewrite;
apply plusDef to expression (R \cup [(X \cross  X)] \{~(z, y)~\}) \plus [X];
with disabled (subsetDef) rewrite;
prenex;
with disabled (subsetDef) rewrite;
rewrite;
apply inPower to predicate B\_\_0 \comp [X, X, X] B\_\_0 \in  \power~  B\_\_0;
instantiate e == (x, y);
rewrite;
instantiate y\_\_0 == z;
rewrite;
rearrange;
instantiate B\_\_1 == B\_\_0;
rewrite;
apply inPower to predicate B\_\_0 \comp [X, X, X] B\_\_0 \in  \power~  B\_\_0;
rewrite;
next;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lUnionSingletonTransitiveClosure2]
use lUnionSingletonTransitiveClosure[X];
prove by rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lTransitiveClosureElem]
apply plusDef;
prove by rewrite;
apply inPower to predicate B \comp [X, X, X] B \in  \power~  B;
instantiate e == (x, y);
prove by rewrite;
apply inPower to predicate R \in  \power~  B;
instantiate e == (x, v);
instantiate e == (v, y);
instantiate y\_\_0 == v;
prove by rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lTransitiveClosureElemType]
apply plusDef to expression R \plus [X];
prove by rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIsaHolIntoTransitiveClosure]
apply lTransitiveClosureElem to predicate (a, c) \in  R \plus [X];
instantiate v == b;
prove by rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIsaHolTransitiveClosureEntails]
apply plusDef to expression R \plus [X];
prove by rewrite;
instantiate B\_\_0 == B;
rearrange;
rewrite;
apply inPower to predicate R \in  \power~  B;
instantiate e == (b, c);
rearrange;
rewrite;
apply inPower to predicate B \comp [X, X, X] B \in  \power~  B;
instantiate e\_\_0 == (a, c);
rearrange;
rewrite;
instantiate y == b;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIsaHolTransitiveClosureEntails2]
prenex;
use lIsaHolTransitiveClosureEntails[X];
rearrange;
simplify;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIsaHolTransitiveClosureLeadsTo]
apply plusDef to expression R \plus [X];
prove by rewrite;
instantiate B\_\_0 == B;
rearrange;
rewrite;
apply inPower to predicate R \in  \power~  B;
instantiate e == (a, b);
rearrange;
rewrite;
apply inPower to predicate B \comp [X, X, X] B \in  \power~  B;
instantiate e\_\_0 == (a, c);
rearrange;
rewrite;
instantiate y == b;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIsaHolTransitiveClosureTransitive]
apply plusDef to expression R \plus [X];
prove by rewrite;
instantiate B\_\_0 == B;
instantiate B\_\_1 == B;
rewrite;
apply inPower to predicate B \comp [X, X, X] B \in  \power~  B;
instantiate e == (a, c);
rearrange;
rewrite;
instantiate y == b;
rewrite;
\end{forget}\end{LPScript}


\section{Relational iteration}

\begin{LToolkit}[Transitive closure is transitive]
‚îÄ ‚òí theorem rule lIteratedTransitiveClosureType [ X ] 
‚àÄ R : X ‚Üî X ‚¶Å { i : ‚Ñï‚Üò1‚Üñ ‚¶Å iter [ X ] i R } ‚àà ‚Ñô ( ‚Ñô ( X √ó X ) ) 
‚îî \end{LToolkit}

\begin{LTrivial}[Iterative closure:~ base case as a rule]
‚îÄ ‚òí theorem rule lIterBase [ X ] 
‚àÄ R : X ‚Üî X ‚¶Å iter 0 R = id X 
‚îî \end{LTrivial}

\begin{LTrivial}[Iterative closure:~inductive case as a rule]
‚îÄ ‚òí theorem rule lIterInduc [ X ] 
‚àÄ R : X ‚Üî X ; n : ‚Ñï ‚¶Å iter ( n + 1 ) R = if ( n = 0 ) then R else R ‚®æ iter n R 
‚îî \end{LTrivial}

\begin{LTrivial}[$R\bsup n \esup$ ($n \geq 0$):~ all cases as a rule]
‚îÄ ‚òí theorem rule lIterPositive [ X ] 
‚àÄ R : X ‚Üî X ; n : ‚Ñï ‚¶Å iter n R = if ( n = 0 ) then id X else if ( n = 1 ) then R else R ‚®æ iter ( n ‚àí 1 ) R 
‚îî \end{LTrivial}

\begin{LToolkit}[$\id\_$ element in $R\bsup 0 \esup$ (base case)]
‚îÄ ‚òí theorem rule lInIterZero [ X ] 
‚àÄ R : X ‚Üî X | e ‚àà id X ‚¶Å e ‚àà iter 0 R 
‚îî \end{LToolkit}

\begin{LToolkit}[$R$ element in $R\bsup 1 \esup$ (singleton case)]
‚îÄ ‚òí theorem rule lInIterOne [ X ] 
‚àÄ R : X ‚Üî X | e ‚àà R ‚¶Å e ‚àà iter 1 R 
‚îî \end{LToolkit}

\begin{LToolkit}[$R$ element in $R\bsup n \esup$ (general case, $n > 1$)]
‚îÄ ‚òí theorem rule lInIterN [ X ] 
‚àÄ R : X ‚Üî X ; n : ‚Ñï‚Üò1‚Üñ | ¬¨ n = 1 ‚àß e ‚àà R ‚®æ iter ( n ‚àí 1 ) R ‚¶Å e ‚àà iter n R 
‚îî \end{LToolkit}

\begin{LTrivial}[$R\bsup n \esup$ element ($n \geq 0$):~all cases as a rule]
‚îÄ ‚òí theorem rule lInIterAny [ X ] 
‚àÄ R : X ‚Üî X ; n : ‚Ñï | e ‚àà if ( n = 0 ) then id X else if ( n = 1 ) then R else R ‚®æ iter ( n ‚àí 1 ) R ‚¶Å e ‚àà iter n R 
‚îî \end{LTrivial}

\begin{LRRT}[$R\bsup n \esup$ is total on $n \geq 0$]
‚îÄ theorem rule lIterIsTotalOnN [ X ] 
‚àÄ n : ‚Ñï ‚¶Å n ‚àà dom iter [ X ] 
‚îî \end{LRRT}

\begin{LRRT}[$R\bsup n \esup$ ($n \geq 0$) is total on any $R$]
‚îÄ theorem rule lIterIsTotalOnIterN [ X ] 
‚àÄ R : X ‚Üî X ; n : ‚Ñï ‚¶Å R ‚àà dom ( iter n ) 
‚îî \end{LRRT}

The next two rules are extremely helpful!
\begin{LToolkit}[$R\bsup i \esup$-$\comp$ ($i > 1$) to the right]
‚îÄ ‚òí theorem rule lTrivialIterateCompositionPosRight [ X ] 
‚àÄ i : ‚Ñï‚Üò1‚Üñ ; R : X ‚Üî X | ¬¨ i = 1 ‚¶Å iter i R = R ‚®æ iter ( i ‚àí 1 ) R 
‚îî \end{LToolkit}

\begin{LToolkit}[$R\bsup i \esup$-$\comp$ ($i > 1$) to the left]
‚îÄ ‚òí theorem rule lTrivialIterateCompositionPosLeft [ X ] 
‚àÄ i : ‚Ñï‚Üò1‚Üñ ; R : X ‚Üî X | ¬¨ i = 1 ‚¶Å iter i R = iter ( i ‚àí 1 ) R ‚®æ R 
‚îî \end{LToolkit}

\begin{LAbbr}[Example for a $R\bsup i \esup$ ($i \geq 0$) witness]
‚îÄ IterWitness [ X ] == ( Œª i : ‚Ñï ‚¶Å ( Œª Q : X ‚Üî X ‚¶Å iter i Q ) ) ‚îî \end{LAbbr}

\begin{LRRT}[$R\bsup i \esup$ ($n \in \num$) result maximal type]
‚îÄ theorem rule lIterRangeMaxType [ X ] 
‚àÄ R : X ‚Üî X ; n : ‚Ñ§ ‚¶Å iter n R ‚àà ‚Ñô ( X √ó X ) 
‚îî \end{LRRT}

\begin{LRRT}[$R\bsup i \esup$ ($n \in \num$) result maximal relational type]
‚îÄ theorem rule lIterRangeRelType [ X ] 
‚àÄ R : X ‚Üî X ; n : ‚Ñ§ ‚¶Å iter n R ‚àà X ‚Üî X 
‚îî \end{LRRT}

\begin{LLemma}[Transitive $R\bsup i \esup$ ($i > 0$) element weakening]
‚îÄ ‚òí theorem lIteratedTransitiveClosureMember [ X ] 
‚àÄ a , b : X ; R : X ‚Üî X | ( a , b ) ‚àà ‚ãÉ { i : ‚Ñï‚Üò1‚Üñ ‚¶Å ( iter i R ) } ‚¶Å ‚àÉ j : ‚Ñï‚Üò1‚Üñ ‚¶Å ( a , b ) ‚àà iter j R 
‚îî \end{LLemma}

The next $3$ lemmas are similar to those given in the \texttt{transitive\_closure}
theory (see~\thref{theories-transitive-closure}).
\begin{LToolkit}[Transitive $R\bsup i \esup$ ($i > 0$) element entails]
‚îÄ ‚òí theorem rule lIteratedTransitiveClosureElemIsTransitive [ X ] 
‚àÄ a , b , c : X ; R : X ‚Üî X | ( a , b ) ‚àà ‚ãÉ { i : ‚Ñï‚Üò1‚Üñ ‚¶Å ( iter i R ) } ‚àß ( b , c ) ‚àà ‚ãÉ { j : ‚Ñï‚Üò1‚Üñ ‚¶Å ( iter j R ) } ‚¶Å ( a , c ) ‚àà ‚ãÉ { k : ‚Ñï‚Üò1‚Üñ ‚¶Å ( iter k R ) } 
‚îî \end{LToolkit}

\begin{LToolkit}[Transitive $R\bsup i \esup$ ($i > 0$) element (implicitly) entails]
‚îÄ ‚òí theorem rule lIteratedTransitiveClosureElemIsTransitive2 [ X ] 
‚àÄ a , c : X ; R : X ‚Üî X | ‚àÉ b : X ‚¶Å ( a , b ) ‚àà ‚ãÉ { i : ‚Ñï‚Üò1‚Üñ ‚¶Å ( iter i R ) } ‚àß ( b , c ) ‚àà ‚ãÉ { j : ‚Ñï‚Üò1‚Üñ ‚¶Å ( iter j R ) } ‚¶Å ( a , c ) ‚àà ‚ãÉ { k : ‚Ñï‚Üò1‚Üñ ‚¶Å ( iter k R ) } 
‚îî \end{LToolkit}

\begin{LToolkit}[Transitive $R\bsup i \esup$ ($i > 0$) element (implicitly) entails]
‚îÄ ‚òí theorem rule lIterativeClosureIsTransitive [ X ] 
‚àÄ R : X ‚Üî X ‚¶Å ‚ãÉ { i : ‚Ñï‚Üò1‚Üñ ‚¶Å ( iter i R ) } ‚®æ ‚ãÉ { j : ‚Ñï‚Üò1‚Üñ ‚¶Å ( iter j R ) } ‚àà ‚Ñô ( ‚ãÉ { k : ‚Ñï‚Üò1‚Üñ ‚¶Å ( iter k R ) } ) 
‚îî \end{LToolkit}

The next lemma is a $R\bsup n \esup$ ($n > 0$) (\textit{i.e.,} iterated transitive closure)
version of \zeves\ lemma \texttt{plusContainsSelf} (See Section~10.11), but given as an
automatic rewriting rule.
\begin{LToolkit}[$R\bsup n \esup$ ($n > 0$) contains $R$]
‚îÄ ‚òí theorem rule lIterativeClosureIsSelfContained [ X ] 
‚àÄ R : X ‚Üî X ‚¶Å R ‚àà ‚Ñô ( ‚ãÉ { i : ‚Ñï‚Üò1‚Üñ ‚¶Å ( iter i R ) } ) 
‚îî \end{LToolkit}

The next lemma is the most important in this Z section. It enables one
to exchange lemmas between relational transitive closure, and iterated
transitive closure. The latter is more helpful in transitive closure
proofs, since it already provides an inductive argument. Thus, in an
indirect way, this equivalence transformation (implicitly) provides an
induction scheme for transitive closure, yet without the hassle of
inductive sets setup needed for set-theoretical inductive proofs.
Although it does not avoid such inductive setup altogether (\textit{e.g.,}
see the two but the last theorems below), it does simplify transitive
closure proofs considerably. For some evidence of this, see other works
on proving Woodcock and Davies' $Chain$ data type.
\begin{LToolkit}[$R\plus$ equals $R\bsup n \esup$ ($n > 0$)]
‚îÄ ‚òí theorem rule lTransitiveClosureEquivalence [ X ] 
‚àÄ R : X ‚Üî X ‚¶Å R ‚Üó+‚Üô = ‚ãÉ { i : ‚Ñï‚Üò1‚Üñ ‚¶Å ( iter i R ) } 
‚îî \end{LToolkit}

MAYBE GO TO ITERATIVE CLOSURE?
\begin{LToolkit}[$R\plus$ element belongs to $\dom~R$]
‚îÄ ‚òí theorem rule lTransitiveClosureConnectsDom [ X ] 
‚àÄ x , y : X ; R : X ‚Üî X | ( x , y ) ‚àà R ‚Üó+‚Üô ‚¶Å x ‚àà dom R 
‚îî \end{LToolkit}

\begin{LToolkit}[$R\plus$ element belongs to $\ran~R$]
‚îÄ ‚òí theorem rule lTransitiveClosureConnectsRan [ X ] 
‚àÄ x , y : X ; R : X ‚Üî X | ( x , y ) ‚àà R ‚Üó+‚Üô ‚¶Å y ‚àà ran R 
‚îî \end{LToolkit}

\begin{LToolkit}[$R\plus$ element belongs to $\ran~R\plus$]
‚îÄ ‚òí theorem rule lTransitiveClosureConnectsRan2 [ X ] 
‚àÄ x , y : X ; R : X ‚Üî X | ( x , y ) ‚àà R ‚Üó+‚Üô ‚¶Å y ‚àà ran ( R ‚Üó+‚Üô ) 
‚îî \end{LToolkit}


The next $2$ lemmas are a weakened version of the previous one for set membership,
rather than equivalence.
\begin{LToolkit}[$R\plus$ element is  $R\bsup n \esup$ ($n > 0$) element]
‚îÄ ‚òí theorem rule lTransitiveClosureMemberIsIteratedClosureMember [ X ] 
‚àÄ a , c : X ; R : X ‚Üî X | ( a , c ) ‚àà R ‚Üó+‚Üô ‚¶Å ( a , c ) ‚àà ‚ãÉ { i : ‚Ñï‚Üò1‚Üñ ‚¶Å ( iter i R ) } 
‚îî \end{LToolkit}

\begin{LToolkit}[$R\bsup n \esup$ ($n > 0$) element is $R\plus$ element]
‚îÄ ‚òí theorem rule lIteratedTransitiveClosureMemberIsTransitiveClosureMember [ X ] 
‚àÄ a , c : X ; R : X ‚Üî X | ( a , c ) ‚àà ‚ãÉ { i : ‚Ñï‚Üò1‚Üñ ‚¶Å ( iter i R ) } ‚¶Å ( a , c ) ‚àà R ‚Üó+‚Üô 
‚îî \end{LToolkit}

The next $2$ lemmas provide the set-theoretical natural induction scheme/argument needed
for the proofs of the next following $2$ lemmas. The argument is as follows:~ show
that the $R\bsup i \esup$ distributes through $\ndres$/$\nrres$ over a general $i > 0$, and
that this set contains the whole set of strictly positive numbers ($\nat_1$). With that,
and the equivalence between $R\plus$ and $R\bsup i \esup$ ($i>0$) (see lemma
\texttt{lTransitiveClosureEquivalence} above), we can prove that the same property holds
for $R\plus$. In this sense, we have used $R\bsup i \esup$ ($i>0$) to prove properties
about $R\plus$, which we found much easier/simpler than using $R\plus$ definition directly.
\begin{LLemma}
‚îÄ ‚òí theorem lHeadExtractNDresDistTransitiveClosureZEvesInduc [ X ] 
‚àÄ s : X ; R : X ‚Üî X | ¬¨ s ‚àà ran R ‚¶Å ‚Ñï‚Üò1‚Üñ ‚äÜ { i : ‚Ñï‚Üò1‚Üñ | iter i ( { s } ‚©§ R ) = { s } ‚©§ iter i R } 
‚îî \end{LLemma}

\begin{LLemma}
‚îÄ ‚òí theorem lLastExtractNRresDistTransitiveClosureZEvesInduc [ X ] 
‚àÄ e : X ; R : X ‚Üî X | ¬¨ e ‚àà dom R ‚¶Å ‚Ñï‚Üò1‚Üñ ‚äÜ { i : ‚Ñï‚Üò1‚Üñ | iter i ( R ‚©• { e } ) = iter i R ‚©• { e } } 
‚îî \end{LLemma}

The next lemma says that extracting some transitively closed head/start element of
$R$ (\textit{i.e.,} $s \notin \ran~ R$) is irrespective of the closure operation.
In other words, it distributes through the transitive closure.
\begin{LToolkit}[$R\plus$-$\ndres$ head extraction distributes through $R\plus$]
‚îÄ ‚òí theorem rule lHeadExtractNDresDistTransitiveClosure [ X ] 
‚àÄ s : X ; R : X ‚Üî X | ¬¨ s ‚àà ran R ‚¶Å ( { s } ‚©§ R ) ‚Üó+‚Üô = { s } ‚©§ R ‚Üó+‚Üô 
‚îî \end{LToolkit}

Similarly, extracting some transitively closed last/end element of
$R$ (\textit{i.e.,} $e \notin \dom~ R$) is irrespective of the closure
operation. In other words, it distributes through the transitive closure.
\begin{LToolkit}[$R\plus$-$\nrres$ last extraction distributes through $R\plus$]
‚îÄ ‚òí theorem rule lLastExtractNRresDistTransitiveClosure [ X ] 
‚àÄ e : X ; R : X ‚Üî X | ¬¨ e ‚àà dom R ‚¶Å ( R ‚©• { e } ) ‚Üó+‚Üô = R ‚Üó+‚Üô ‚©• { e } 
‚îî \end{LToolkit}

\begin{LRRT}[$R\bsup n \esup$ ($n > 0$) element maximal type]
‚îÄ ‚òí theorem rule lIteratedClosureElemType [ X ] 
‚àÄ i : ‚Ñ§ ; R : X ‚Üî X | x ‚àà iter i R ‚¶Å x ‚àà X √ó X 
‚îî \end{LRRT}\sectionproof{Iterated closure}{theories-iterated-closure}

\begin{LPScript}\begin{forget}[lIteratedTransitiveClosureType]
apply inPower to predicate \{~  i: \nat _1{} @ iter[X]~i~R ~\} \in  \power~  (\power~  (X \cross  X));
prenex;
rewrite;
prenex;
apply inPower to predicate e \in  \power~  (X \cross  X);
prenex;
apply inCross2 to predicate e\_\_0 \in  X \cross  X;
use iterInPlus[X][n := i];
rearrange;
rewrite;
apply inPower to predicate iter[X]~i~R \in  \power~  R \plus [X];
instantiate e\_\_1 == e\_\_0;
rearrange;
rewrite;
use lTransitiveClosureElemType[X][x := e\_\_0];
rearrange;
apply inCross2 to predicate e\_\_0 \in  X \cross  X;
simplify;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIterBase]
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIterInduc]
use iterPositive[X][R\_\_1 := R, n\_\_0 := n];
rearrange;
simplify;
apply oneIteration to expression iter[X]~1~R;
simplify;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIterPositive]
use lIterInduc[X][n := n - 1];
rearrange;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lInIterZero]
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lInIterOne]
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lInIterN]
apply lIterPositive to expression iter[X]~n~R;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lInIterAny]
split n = 0;
rewrite;
split n = 1;
rewrite;
apply lInIterN to predicate e \in  iter[X]~n~R;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIterIsTotalOnN]
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIterIsTotalOnIterN]
with predicate (n \in  \nat ) rewrite;
use applyInRanFun[\num , (X \rel  X) \fun  X \rel  X][f := iter[X], a := n];
rearrange;
simplify;
apply inDom to predicate R \in  \dom~ [(\power~  (X \cross  X)), (\power~  (X \cross  X))] (iter[X]~n);
with predicate (iter[X]~n \in  \power~  (X \cross  X) \rel  \power~  (X \cross  X)) rewrite;
invoke (\_\fun \_);
rewrite;
instantiate x == R;
invoke (\_\rel \_);
simplify;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lTrivialIterateCompositionPosRight]
apply lIterPositive to expression iter[X]~i~R;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lTrivialIterateCompositionPosLeft]
use composePositiveIterates[X][n := i - 1, k := 1, Y := X];
rearrange;
rewrite;
\end{forget}\end{LPScript}

\begin{LDCheck}\begin{forget}[IterWitness\$domainCheck]
rewrite;
\end{forget}\end{LDCheck}

\begin{LPScript}\begin{forget}[lIterRangeMaxType]
use applyInRanFun[\num , (X \rel  X) \fun  X \rel  X][f := iter[X], a := n];
rearrange;
simplify;
use applyInRanFun[X \rel  X, X \rel  X][f := iter[X]~n, a := R];
rearrange;
invoke (\_\rel \_);
simplify;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIterRangeRelType]
invoke (\_\rel \_);
apply lIterRangeMaxType to predicate iter[X]~n~R \in  \power~  (X \cross  X);
invoke (\_\rel \_);
simplify;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIteratedTransitiveClosureMember]
rewrite;
prenex;
rewrite;
prenex;
instantiate j == i;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIteratedTransitiveClosureElemIsTransitive]
rewrite;
prenex;
rewrite;
prenex;
use composePositiveIterates[X][Y := X, n := i, k := i\_\_0, R := R];
rearrange;
rewrite;
instantiate B\_\_1 == B \comp [X, X, X] B\_\_0;
equality substitute;
rewrite;
instantiate i\_\_1 == i + i\_\_0;
rewrite;
instantiate y == b;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIteratedTransitiveClosureElemIsTransitive2]
prenex;
use lIteratedTransitiveClosureElemIsTransitive[X];
rearrange;
simplify;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIterativeClosureIsTransitive]
apply inPower;
prenex;
rewrite;
apply compDef;
rewrite;
prenex;
rewrite;
prenex;
rewrite;
use composePositiveIterates[X][Y := X, n := i, k := i\_\_0, R := R];
rearrange;
rewrite;
instantiate B\_\_1 == B \comp [X, X, X] B\_\_0;
equality substitute;
rewrite;
instantiate i\_\_1 == i + i\_\_0;
rewrite;
instantiate y\_\_0 == y;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIterativeClosureIsSelfContained]
apply inPower;
prenex;
rewrite;
instantiate B == R;
rewrite;
instantiate i == 1;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lTransitiveClosureEquivalence]
apply extensionality2 to predicate
    R \plus [X] =
    \bigcup [(X \cross  X)] \{~  i: \nat _1{} @ (iter[X]~i~R) ~\};
cases;
next;
rewrite;
apply inPower to predicate \{~  i: \nat _1{} @ iter[X]~i~R ~\} \in  \power~  (\power~  R \plus [X]);
prenex;
rewrite;
prenex;
use iterInPlus[X][n := i];
rearrange;
rewrite;
next;
apply plusSubset1 to predicate R \plus [X] \in
    \power~  (\bigcup [(X \cross  X)] \{~  i: \nat _1{} @ (iter[X]~i~R) ~\});
rewrite;
apply lIterativeClosureIsTransitive;
apply lIterativeClosureIsSelfContained;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lTransitiveClosureConnectsDom]
apply lTransitiveClosureEquivalence to expression R \plus [X];
rewrite;
prenex;
rewrite;
prenex;
apply lIterPositive to expression iter[X]~i~R;
rewrite;
apply inDom to predicate x \in  \dom~ [X, X] R;
rearrange;
rewrite;
split i = 1;
rewrite;
cases;
instantiate y\_\_0 == y;
rewrite;
next;
rearrange;
equality substitute;
rewrite;
prenex;
instantiate y\_\_1 == y\_\_0;
rewrite;
next;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lTransitiveClosureConnectsRan]
apply lTransitiveClosureEquivalence;
apply inRan;
prove by rewrite;
apply lTrivialIterateCompositionPosLeft to expression iter[X]~i~R;
prove by rewrite;
split i = 1;
rewrite;
cases;
instantiate x\_\_0 == x;
rewrite;
next;
instantiate x\_\_1 == y\_\_0;
rewrite;
next;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lTransitiveClosureConnectsRan2]
apply lTransitiveClosureEquivalence to expression R \plus [X];
rewrite;
apply inRan to predicate y \in
    \ran~ [X, X] (\bigcup [(X \cross  X)] \{~  i\_\_0: \nat _1{} @ (iter[X]~i\_\_0~R) ~\});
prenex;
rewrite;
prenex;
instantiate x\_\_0 == x;
rewrite;
instantiate B\_\_0 == B;
rewrite;
instantiate i\_\_0 == i;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lTransitiveClosureMemberIsIteratedClosureMember]
use lTransitiveClosureEquivalence[X];
rearrange;
simplify;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIteratedTransitiveClosureMemberIsTransitiveClosureMember]
use lTransitiveClosureEquivalence[X];
rearrange;
simplify;
\end{forget}\end{LPScript}


\begin{LPScript}\begin{forget}[lHeadExtractNDresDistTransitiveClosureZEvesInduc]
apply nat1Induction;
prove by rewrite;
split x = 1;
cases;
apply lIterPositive;
prove by rewrite;
apply extensionality to predicate
    \{~s~\} \ndres [X, X] R \comp [X, X, X] \{~s~\} \ndres [X, X] R =
    \{~s~\} \ndres [X, X] (R \comp [X, X, X] R);
apply compDef;
prove by rewrite;
apply inNdres;
invoke (\_\rel \_);
prove by rewrite;
instantiate y\_\_2 == y\_\_0;
prove by rewrite;
rearrange;
instantiate y == y\_\_0;
rearrange;
rewrite;
apply inRan;
instantiate x\_\_1 == x\_\_0;
prove by rewrite;
next;
apply extensionality to predicate
    iter[X]~(1 + x)~(\{~s~\} \ndres [X, X] R) = \{~s~\} \ndres [X, X] iter[X]~(1 + x)~R;
apply extensionality to predicate
    iter[X]~x~(\{~s~\} \ndres [X, X] R) = \{~s~\} \ndres [X, X] iter[X]~x~R;
prenex;
rewrite;
apply lTrivialIterateCompositionPosRight to
    expression iter[X]~(1 + x)~(\{~s~\} \ndres [X, X] R);
apply lTrivialIterateCompositionPosRight to
    expression iter[X]~(1 + x)~R;
rewrite;
apply compDef;
rewrite;
prenex;
rearrange;
rewrite;
instantiate x\_\_4 == x\_\_1, y\_\_3 == y\_\_0, z\_\_1 == z;
instantiate x\_\_3 == (y, z);
rewrite;
instantiate y\_\_2 == (y\_\_0, z\_\_0);
rearrange;
rewrite;
equality substitute;
rewrite;
instantiate y\_\_3 == y\_\_0;
rewrite;
rearrange;
apply inRan to predicate s \in  \ran~ [X, X] R;
instantiate x\_\_1 == x\_\_0;
rearrange;
rewrite;
next;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lHeadExtractNDresDistTransitiveClosure]
apply extensionality;
prenex;
use lHeadExtractNDresDistTransitiveClosureZEvesInduc[X];
rearrange;
rewrite;
apply inPower;
rewrite;
cases;
use lTransitiveClosureElemType[X][R := \{~s~\} \ndres [X, X] R];
apply inCross2;
prenex;
rearrange;
rewrite;
rearrange;
equality substitute;
apply lTransitiveClosureEquivalence;
rewrite;
prenex;
rewrite;
prenex;
instantiate e == i;
rearrange;
simplify;
split iter[X]~i~(\{~s~\} \ndres [X, X] R) = \{~s~\} \ndres [X, X] iter[X]~i~R;
simplify;
equality substitute iter[X]~i~(\{~s~\} \ndres [X, X] R);
equality substitute B;
rewrite;
instantiate B\_\_0 == iter[X]~i~R;
rewrite;
instantiate i\_\_0 == i;
rewrite;
next;
use lTransitiveClosureElemType[X][x := y];
rearrange;
apply inCross2;
prenex;
rewrite;
rearrange;
equality substitute;
apply lTransitiveClosureEquivalence;
rewrite;
prenex;
rewrite;
prenex;
instantiate e == i;
simplify;
instantiate B\_\_0 == \{~s~\} \ndres [X, X] iter[X]~i~R;
rewrite;
instantiate i\_\_0 == i;
rewrite;
next;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lLastExtractNRresDistTransitiveClosureZEvesInduc]
apply nat1Induction;
prove by rewrite;
split x = 1;
cases;
apply lIterPositive;
prove by rewrite;
apply extensionality to predicate
    R \nrres [X, X] \{e\} \comp [X, X, X] R \nrres [X, X] \{e\} =
    (R \comp [X, X, X] R) \nrres [X, X] \{e\};
apply compDef;
prove by rewrite;
apply inNrres;
invoke (\_\rel \_);
prove by rewrite;
instantiate y\_\_2 == y\_\_0;
prove by rewrite;
rearrange;
instantiate y == y\_\_0;
rearrange;
rewrite;
apply inDom;
instantiate y\_\_1 == z;
prove by rewrite;
next;
apply extensionality to predicate
    iter[X] x (R \nrres [X, X] \{e\}) = iter[X] x R \nrres [X, X] \{e\};
apply extensionality to predicate
    iter[X] (1 + x) (R \nrres [X, X] \{e\}) = iter[X] (1 + x) R \nrres [X, X] \{e\};
prenex;
rewrite;
apply lTrivialIterateCompositionPosLeft
    to expression iter[X] (1 + x) (R \nrres [X, X] \{e\});
apply lTrivialIterateCompositionPosLeft
    to expression iter[X] (1 + x) R;
rewrite;
apply compDef;
rewrite;
prenex;
rearrange;
rewrite;
instantiate x\_\_4 == x\_\_1, y\_\_3 == y\_\_0, z\_\_1 == z;
instantiate x\_\_3 == (x\_\_0, y);
rewrite;
prove by rewrite;
instantiate y\_\_3 == y\_\_0;
rewrite;
instantiate y\_\_2 == (x\_\_0, y);
rearrange;
rewrite;
apply inDom to predicate e \in  \dom~[X, X] R;
instantiate y\_\_2 == z;
rearrange;
rewrite;
next;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lLastExtractNRresDistTransitiveClosure]
apply extensionality;
prenex;
use lLastExtractNRresDistTransitiveClosureZEvesInduc[X];
rearrange;
rewrite;
apply inPower;
rewrite;
cases;
use lTransitiveClosureElemType[X][R := R \nrres [X, X] \{e\}];
apply inCross2;
rearrange;
rewrite;
prenex;
rearrange;
equality substitute;
apply lTransitiveClosureEquivalence;
rewrite;
prenex;
rewrite;
prenex;
instantiate e\_\_0 == i;
rearrange;
simplify;
split iter[X] i (R \nrres [X, X] \{e\}) = iter[X] i R \nrres [X, X] \{e\};
simplify;
equality substitute iter[X] i (R \nrres [X, X] \{e\});
equality substitute B;
rewrite;
instantiate B\_\_0 == iter[X] i R;
rewrite;
instantiate i\_\_0 == i;
rewrite;
next;
use lTransitiveClosureElemType[X][x := y];
rearrange;
apply inCross2;
prenex;
rewrite;
rearrange;
equality substitute;
apply lTransitiveClosureEquivalence;
rewrite;
prenex;
rewrite;
prenex;
instantiate e\_\_0 == i;
simplify;
instantiate B\_\_0 == iter[X] i R \nrres [X, X] \{e\};
rewrite;
instantiate i\_\_0 == i;
rewrite;
next;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIteratedClosureElemType]
apply lIterPositive to expression iter[X]~i~R;
with normalization rewrite;
\end{forget}\end{LPScript}

\section{Function spaces}

\begin{LToolkit}[Partial function point is an element]
‚îÄ ‚òí theorem rule lPfunPointIsPfunElem [ X , Y ] 
‚àÄ x : X ; y : Y ; f : X ‚á∏ Y | x ‚àà dom f ‚àß y = f x ‚¶Å ( x , y ) ‚àà f 
‚îî 
\end{LToolkit}

\begin{LToolkit}[Expose $\pfun$ property]
‚îÄ ‚òí theorem rule lPFunWeakening [ X , Y ] 
f ‚àà X ‚á∏ Y ‚áî f ‚àà X ‚Üî Y ‚àß ( ‚àÄ d : X ; r1 , r2 : Y | ( d , r1 ) ‚àà f ‚àß ( d , r2 ) ‚àà f ‚¶Å r1 = r2 ) 
‚îî \end{LToolkit}


\begin{LTrivial}[Expose $\pfun$ property with fresh names]
‚îÄ ‚òí theorem rule lPFunWeakeningFresh [ X , Y ] 
f ‚àà X ‚á∏ Y ‚áî f ‚àà X ‚Üî Y ‚àß ( ‚àÄ df : X ; rf1 , rf2 : Y | ( df , rf1 ) ‚àà f ‚àß ( df , rf2 ) ‚àà f ‚¶Å rf1 = rf2 ) 
‚îî \end{LTrivial}

The next lemma is laid out for maximal automation.
It is equivalent to $\dom~f = \{\} \implies f = \{\}$,
which cannot be given as a rule.
\begin{LToolkit}[Non empty PFun has non empty $\dom$]
‚îÄ ‚òí theorem rule lEmptyDomIsEmptyPFun [ X , Y ] 
‚àÄ f : X ‚á∏ Y | ¬¨ f = { } ‚¶Å ¬¨ dom f = { } 
‚îî \end{LToolkit}

\begin{LToolkit}[$\dom$ element is specific $\pfun$ element]
‚îÄ ‚òí theorem rule lDomElemIsElemPFun [ X , Y ] 
‚àÄ x : X ; f : X ‚á∏ Y | x ‚àà dom f ‚¶Å ( x , f x ) ‚àà f 
‚îî \end{LToolkit}

\begin{LToolkit}[Member of homogeneous $\pfun$ forms no loop]
‚îÄ ‚òí theorem rule lHomogeneousMemberNoLoop [ X ] 
‚àÄ x : X ; f : X ‚á∏ X | x ‚àà dom f ‚àß ¬¨ x ‚àà ran f ‚¶Å ¬¨ f x = x 
‚îî \end{LToolkit}

\begin{LToolkit}[$\pfun$ non-immediate member]
‚îÄ ‚òí theorem rule lNotImmediateMemberPFun [ X , Y ] 
‚àÄ f : X ‚á∏ Y ; x : X ; y : Y | x ‚àà dom f ‚àß ¬¨ f x = y ‚¶Å ¬¨ ( x , y ) ‚àà f 
‚îî \end{LToolkit}

\begin{LToolkit}[$\pfun$-$\oplus$ containment]
‚îÄ ‚òí theorem rule lPFunSubsetOplus [ X , Y ] 
‚àÄ f , g : X ‚á∏ Y | g ‚äÜ f ‚¶Å f ‚äï g = f ‚äï ( dom g ‚óÅ f ) 
‚îî ~\end{LToolkit}

\begin{LToolkit}[$\pfun$-$\oplus$ pointwise equivalence]
‚îÄ ‚òí theorem rule lPFunElemAbsorbsUnitOplusRight [ X , Y ] 
‚àÄ x : X ; y : Y ; f : X ‚á∏ Y | ( x , y ) ‚àà f ‚¶Å f ‚äï { ( x , y ) } = f 
‚îî \end{LToolkit}

\begin{LToolkit}[$\pfun$-$\dom$ partitions over $\dres$]
‚îÄ ‚òí theorem rule lPFunDomPartitionsPFunDRes [ X , Y ] 
‚àÄ f : X ‚á∏ Y ; s , t : ‚Ñô X | ‚ü® s , t ‚ü© partition dom f ‚¶Å ‚ü® s ‚óÅ f , t ‚óÅ f ‚ü© partition f 
‚îî \end{LToolkit}

\sectionproof{Functions}{theories-function-spaces}

\begin{LPScript}\begin{forget}[lPfunPointIsPfunElem]
apply inDom to predicate x \in  \dom~ [X, Y] f;
prove by rewrite;
use pairInFunction[X, Y][f := f, x := x, y := y\_\_0];
prove by rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lPFunWeakening]
invoke (\_\pfun \_);
prove;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lPFunWeakeningFresh]
apply lPFunWeakening to predicate f \in  X \pfun  Y;
simplify;
\end{forget}\end{LPScript}

\begin{forget}[lEmptyDomIsEmptyPFun]
rewrite;
apply domDefinition;
apply extensionality;
prove;
invoke (\_\pfun \_);
invoke (\_\rel \_);
prove;
apply inPower to predicate f \in  \power  (X \cross  Y);
instantiate e == x;
apply inCross2 to predicate x \in  X \cross  Y;
prenex;
instantiate x\_\_2 == x\_\_0;
rearrange;
rewrite;
rearrange;
instantiate y\_\_0 == y;
rewrite;
\end{forget}


\begin{LPScript}\begin{forget}[lDomElemIsElemPFun]
apply inDom to predicate x \in  \dom~ [X, Y] f;
prove by rewrite;
use pairInFunction[X, Y];
prove by rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lHomogeneousMemberNoLoop]
apply inRanFunction to predicate x \in  \ran~ [X, X] f;
prove by rewrite;
instantiate x\_\_0 == x;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lNotImmediateMemberPFun]
apply inDom to predicate x \in  \dom~ [X, Y] f;
prenex;
rewrite;
use pairInFunction[X, Y][y := y\_\_0];
rearrange;
rewrite;
invoke (\_\pfun \_);
rewrite;
instantiate x\_\_0 == x, y1 == y\_\_0, y2 == y;
rearrange;
rewrite;
\end{forget}\end{LPScript}


\begin{LPScript}\begin{forget}[lPFunSubsetOplus]
    \znote{Expose at once:}
    \znote{1-proof goals from =}
    \znote{2-definition of override}
    \znote{3-definition of dom}
    with enabled (extensionality, oplusDef, inDom) prove by rewrite;
    \znote{Special trick to avoid disjunction}
    split y \in f;
    simplify;
    \znote{Special trick to avoid negation}
    split \lnot  (y.1, y\_\_0) \in  g;
    simplify;
    rearrange;
    \znote{Exposing the set types of f and g}
    invoke (\_\pfun \_);
    invoke (\_\rel \_);
    prove by rewrite;
    \znote{Expose at once all type information about f and g}
    with enabled (inPower, inCross2) prove by rewrite;
    \znote{Type of element from f}
    instantiate e == y;
    \znote{Type of element from g}
    instantiate e\_\_0 == (y.1, y\_\_0);
    \znote{Elements of g are elements of f}
    instantiate e\_\_1 == (y.1, y\_\_0);
    \znote{f is functional}
    instantiate x\_\_3 == y.1, y1 == y\_\_0, y2 == y.2;
    \znote{g is functional}
    instantiate x\_\_4 == y.1, y1\_\_0 == y\_\_0, y2\_\_0 == y.2;
    prove by rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lPFunElemAbsorbsUnitOplusRight]
    with enabled (inDom, dresDef, lPFunSubsetOplus, lPfunPointIsPfunElem)
        prove by rewrite;
    apply oplusDef;
    prove by rewrite;
    cases;
      \znote{Case where the type is correct}
      apply extensionality;
      with enabled (inDom) prove by rewrite;
    next;
      \znote{Case where the type contradictory}
      invoke (\_\rel \_);
      prove by rewrite;
    next;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lPFunDomPartitionsPFunDRes]
    with enabled (disjointCat) prove by rewrite;
    cases;
        apply extensionality to predicate s \dres [X, Y] f \cap [X \cross  Y] t \dres [X, Y] f = \{\};
        apply extensionality to predicate s \cap [X] t = \{\};
        prove by rewrite;
        instantiate x\_\_0 == x.1;
        prove by rewrite;
    next;
        apply extensionality to predicate s \dres [X, Y] f \cup [X \cross  Y] t \dres [X, Y] f = f;
        prove by rewrite;
        apply extensionality to predicate s \cup [X] t = \dom~[X, Y] f;
        prove by rewrite;
        instantiate y\_\_0 == y.1;
        prove by rewrite;
        apply inDom to predicate y.1 \in  \dom~[X, Y] f;
        prove by rewrite;
        instantiate y\_\_1 == y.2;
        invoke (\_\pfun \_);
        invoke (\_\rel \_);
        prove by rewrite;
        apply inPower to predicate f \in  \power  (X \cross  Y);
        instantiate e == y;
        prove by rewrite;
    next;
\end{forget}\end{LPScript} \section{Injections}

Lemmas are toolkit theorems that are not rules (\textit{i.e.,} cannot be automatically applied)
\begin{LLemma}[$\pinj$ element is part of its inverse]
‚îÄ ‚òí theorem lPairInvInPInj [ X , Y ] 
‚àÄ A : ‚Ñô X ; B : ‚Ñô Y ‚¶Å ‚àÄ f : A ‚§î B | ( x , y ) ‚àà f ‚¶Å x ‚àà A ‚àß y ‚àà B ‚àß x = ( f ‚àº ) y ‚àß ( y , x ) ‚àà f ‚àº 
‚îî \end{LLemma}

\begin{LToolkit}[Expose $\pinj$ property]
‚îÄ ‚òí theorem rule lPInjWeakening [ X , Y ] 
f ‚àà X ‚§î Y ‚áî f ‚àà X ‚á∏ Y ‚àß ( ‚àÄ r : Y ; d1 , d2 : X | ( d1 , r ) ‚àà f ‚àß ( d2 , r ) ‚àà f ‚¶Å d1 = d2 ) 
‚îî \end{LToolkit}

\begin{LTrivial}[Expose $\pinj$ property with fresh names]
‚îÄ ‚òí theorem rule lPInjWeakeningFresh [ X , Y ] 
f ‚àà X ‚§î Y ‚áî f ‚àà X ‚á∏ Y ‚àß ( ‚àÄ rf : Y ; df1 , df2 : X | ( df1 , rf ) ‚àà f ‚àß ( df2 , rf ) ‚àà f ‚¶Å df1 = df2 ) 
‚îî \end{LTrivial}

\begin{LLemma}[$\pinj$ element is part of its inverse]
‚îÄ ‚òí theorem lPInjPairIsRanPoint [ X , Y ] 
‚àÄ A : ‚Ñô X ; B : ‚Ñô Y ‚¶Å ‚àÄ f : A ‚§î B | ( x , y ) ‚àà f ‚¶Å x ‚àà A ‚àß y ‚àà B ‚àß x ‚àà dom f ‚àß y ‚àà ran f ‚àß y = f x ‚àß x = ( f ‚àº ) y 
‚îî \end{LLemma}

\begin{LLemma}[$\pinj$ $\ran~$ element $\_\inv$ in $\pinj$]
‚îÄ ‚òí theorem lApplyInvInDomPInj [ X , Y ] 
‚àÄ A : ‚Ñô X ; B : ‚Ñô Y ‚¶Å ‚àÄ f : A ‚§î B ‚¶Å ‚àÄ a : ran f ‚¶Å ( f ‚àº ) a ‚àà A ‚àß ( f ‚àº ) a ‚àà dom f 
‚îî \end{LLemma}

\begin{LToolkit}[$\pinj$-$\dom$ element $\ran~$-$\ndres$ equivalence]
‚îÄ ‚òí theorem rule lHomogeneousElemRanNDresPInj [ X ] 
‚àÄ x : X ; f : X ‚§î X | x ‚àà dom f ‚¶Å ran ( { x } ‚©§ f ) = ran f ‚àñ { f x } 
‚îî \end{LToolkit}

\begin{LToolkit}[$\pinj$-$\ran~$ element $\dom$-$\nrres$ equivalence]
‚îÄ ‚òí theorem rule lHomogeneousElemDomNRresPInj [ X ] 
‚àÄ y : X ; f : X ‚§î X | y ‚àà ran f ‚¶Å dom ( f ‚©• { y } ) = dom f ‚àñ { ( f ‚àº ) y } 
‚îî \end{LToolkit}

\begin{LToolkit}[$\pinj$-$\dom$ element expansion]
‚îÄ ‚òí theorem rule lInDomInjection [ X , Y ] 
‚àÄ f : X ‚§î Y ‚¶Å x ‚àà dom f ‚áî ( ‚àÉ y : ran f ‚¶Å x = ( f ‚àº ) y ) 
‚îî \end{LToolkit}

\begin{LToolkit}[$\pinj$-$\ran~$ element expansion]
‚îÄ ‚òí theorem rule lInRanInjection [ X , Y ] 
‚àÄ f : X ‚§î Y ‚¶Å y ‚àà ran f ‚áî ( ‚àÉ x : X | ( x , y ) ‚àà f ‚¶Å x = ( f ‚àº ) y ) 
‚îî \end{LToolkit}

This lemmas is similar (yet complementary) to \zeves\ toolkit rule \texttt{applyInverse}.
\begin{LToolkit}[$\pinj$-$\_\inv$ application]
‚îÄ ‚òí theorem rule lApplyInverse2 [ X , Y ] 
‚àÄ A : ‚Ñô X ; B : ‚Ñô Y ‚¶Å ‚àÄ f : A ‚§î B ‚¶Å ‚àÄ y : ran f ‚¶Å f ( ( f ‚àº ) y ) = y 
‚îî \end{LToolkit}

\begin{LToolkit}[$\pinj$ point is $\pinj$ element]
‚îÄ ‚òí theorem rule lPInjInvPointIsPInjElem [ X , Y ] 
‚àÄ f : X ‚§î Y | y ‚àà ran f ‚àß ( f ‚àº ) y = x ‚¶Å ( x , y ) ‚àà f 
‚îî \end{LToolkit}

\begin{LToolkit}[Distinct $\pinj$ point is not shared in $\pinj$]
‚îÄ ‚òí theorem rule lPInjPointIsNotShared [ X , Y ] 
‚àÄ x1 , x2 : X ; f : X ‚§î Y | x1 ‚àà dom f ‚àß ¬¨ x1 = x2 ‚¶Å ¬¨ ( x2 , f x1 ) ‚àà f 
‚îî \end{LToolkit}

\begin{LToolkit}[$\pinj$ following application is not $\pinj$ member]
‚îÄ ‚òí theorem rule lFollowingApplicationNoLoopHomogeneousPInj [ X ] 
‚àÄ x : X ; f : X ‚§î X | x ‚àà dom f ‚àß f x ‚àà dom f ‚àß ¬¨ f x = x ‚¶Å ¬¨ ( f x , f x ) ‚àà f 
‚îî \end{LToolkit}


\sectionproof{Injections}{theories-injections}

\begin{LPScript}\begin{forget}[lPairInvInPInj]
use pairInFunction[X, Y];
rearrange;
rewrite;
use applyInverse[X, Y];
rearrange;
rewrite;
apply inDom to predicate x \in  \dom~[X, Y] f;
instantiate y\_\_0 == y;
rewrite;
split y \in  Y;
rewrite;
invoke (\_\pinj \_);
invoke (\_\pfun \_);
invoke (\_\rel \_);
prove by rewrite;
apply inPower;
cases;
instantiate e\_\_1 == (x, f~ x);
prove by rewrite;
next;
rewrite;
instantiate e\_\_1 == (x, f~ x);
prove by rewrite;
instantiate e\_\_0 == f~ x;
prove by rewrite;
next;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lPInjWeakening]
split f \in  X \pinj  Y;
rewrite;
cases;
invoke (\_\pinj \_);
invoke (\_\pfun \_);
prove;
instantiate x\_\_0 == r, y1\_\_0 == d1, y2\_\_0 == d2;
prove;
next;
rearrange;
split \forall  r\_\_0: Y; d1\_\_0: X; d2\_\_0: X | (d1\_\_0, r\_\_0) \in  f
    \land  (d2\_\_0, r\_\_0) \in  f @ d1\_\_0 = d2\_\_0;
rewrite;
invoke (\_\pinj \_);
invoke (\_\pfun \_);
prove;
next;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lPInjWeakeningFresh]
apply lPInjWeakening to predicate f \in  X \pinj  Y;
simplify;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lPInjPairIsRanPoint]
apply ranDefinition to expression \ran~ [X, Y] f;
apply domDefinition to expression \dom~[X, Y] f;
rewrite;
instantiate x\_\_0 == x;
instantiate y\_\_0 == y;
rewrite;
use lPairInvInPInj[X, Y];
rearrange;
rewrite;
use pairInFunction[X, Y];
rearrange;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lApplyInvInDomPInj]
apply inRan to predicate a \in  \ran~ [X, Y] f;
prove by rewrite;
use lPInjPairIsRanPoint[X, Y][y := a];
rearrange;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lHomogeneousElemRanNDresPInj]
apply extensionality;
prove by rewrite;
apply inRan;
prove by rewrite;
cases;
rewrite;
instantiate x\_\_2 == x\_\_1;
rewrite;
use pairInFunction[X, X][x := x\_\_0, y := x\_\_1];
rearrange;
rewrite;
equality substitute;
use pinjApplicationsEqual[X, X][A := X, B := X, f := f, x := x\_\_0, y := x];
rearrange;
rewrite;
apply inDom to predicate x\_\_0 \in  \dom~[X, X] f;
instantiate y == x\_\_1;
rewrite;
invoke (\_\pinj \_);
invoke (\_\pfun \_);
invoke (\_\rel \_);
prove by rewrite;
apply inPower to predicate f \in  \power~  (X \cross  X);
instantiate e == (x\_\_0, f~ x\_\_0);
prove by rewrite;
next;
instantiate x\_\_4 == x\_\_2;
rewrite;
use pairInFunction[X, X];
rearrange;
rewrite;
next;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lHomogeneousElemDomNRresPInj]
use lApplyInvInDomPInj[X, X][A := X, B := X, a := y];
rearrange;
rewrite;
apply extensionality;
prove by rewrite;
apply inDom;
prove by rewrite;
apply inRan;
prove by rewrite;
use lPairInvInPInj[X, X][A := X, B := X, x := x\_\_0, y := y];
rearrange;
rewrite;
equality substitute f \inv[X, X] y;
cases;
cases;
invoke (\_ \pinj \_);
invoke (\_ \pfun \_);
rewrite;
rewrite;
split x = x\_\_0;
rewrite;
equality substitute x\_\_0;
instantiate x\_\_1 == x, y1 == y, y2 == y\_\_2;
rearrange;
rewrite;
next;
instantiate y\_\_4 == y\_\_2;
rewrite;
next;
instantiate y\_\_5 == y\_\_3;
rewrite;
invoke (\_ \pinj \_);
invoke (\_ \pfun \_);
rewrite;
rewrite;
instantiate x\_\_1 == y\_\_1, y1\_\_0 == x, y2\_\_0 == y\_\_2;
rearrange;
rewrite;
invoke (\_ \rel \_);
apply inPower to predicate f \in \power (X \cross X);
instantiate e == (y\_\_2, y\_\_1);
rearrange;
rewrite;
next;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lInDomInjection]
split x \in  \dom~ [X, Y] f;
prove by rewrite;
cases;
apply inDom;
prove by rewrite;
use lPairInvInPInj[X, Y][A := X, B := Y];
rearrange;
rewrite;
instantiate y\_\_0 == y;
rewrite;
apply inRan;
prove by rewrite;
instantiate x\_\_0 == x;
prove by rewrite;
next;
rearrange;
split x = f \inv [X, Y] y;
rewrite;
apply inRanFunction;
prove by rewrite;
use applyInverse[X, Y][A := X, B := Y, x := x\_\_0];
prove by rewrite;
next;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lInRanInjection]
split y \in  \ran~ [X, Y] f;
prove by rewrite;
cases;
use lApplyInvInDomPInj[X, Y][A := X, B := Y, a := y];
rearrange;
rewrite;
apply inRanFunction to predicate y \in  \ran~ [X, Y] f;
prenex;
rewrite;
use applyInverse[X, Y][A := X, B := Y];
rearrange;
rewrite;
equality substitute;
apply inDom to predicate x \in  \dom~  [X, Y] f;
prenex;
rewrite;
use pairInFunction[X, Y][y := y\_\_0];
rearrange;
rewrite;
next;
rearrange;
split f \inv [X, Y] y \in  X;
simplify;
split (f \inv [X, Y] y, y) \in  f;
simplify;
apply inRan to predicate y \in  \ran~ [X, Y] f;
rewrite;
instantiate x == f \inv [X, Y] y;
rewrite;
next;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lApplyInverse2]
apply inRanFunction;
prove by rewrite;
use applyInverse[X, Y];
prove by rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lPInjInvPointIsPInjElem]
apply lInRanInjection to predicate y \in  \ran~ [X, Y] f;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lFollowingApplicationNoLoopHomogeneousPInj]
apply inDom;
prenex;
rewrite;
use pairInFunction[X, X];
use pairInFunction[X, X][x := f~ x, y := y\_\_0];
rearrange;
rewrite;
rearrange;
equality substitute;
invoke (\_\pinj \_);
invoke (\_\pfun \_);
rewrite;
rewrite;
instantiate x\_\_1 == f~ x, y1\_\_0 == x, y2\_\_0 == f~ x;
rearrange;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lPInjPointIsNotShared]
apply lInDomInjection to predicate x1 \in  \dom~[X, Y] f;
prenex;
rewrite;
apply lInRanInjection to predicate y \in  \ran~ [X, Y] f;
prenex;
rewrite;
use pairInFunction[X, Y];
rearrange;
rewrite;
rearrange;
split y = f x;
simplify;
equality substitute y;
equality substitute x1;
equality substitute f \inv [X, Y] (f x);
equality substitute f x;
invoke (\_\pinj \_);
invoke (\_\pfun \_);
rewrite;
rewrite;
instantiate x\_\_1 == y, y1\_\_0 == x, y2\_\_0 == x2;
invoke (\_\rel \_);
apply inPower to predicate f \in  \power  (X \cross  Y);
instantiate e == (x, y);
rearrange;
rewrite;
\end{forget}\end{LPScript}

Toolkit theorems/lemmas are result useful during proofs.
They are divided by category, similarly to the Z mathematical toolkit.
\begin{LToolkit}[Set difference distribute to the right on set difference]
‚îÄ ‚òí theorem rule lRightDiffLeftDistribute [ X ] 
‚àÄ S , T , U : ‚Ñô X ‚¶Å S ‚àñ ( T ‚àñ U ) = S ‚àñ T ‚à™ ( S ‚à© U ) 
‚îî 
\end{LToolkit}

\begin{LToolkit}[Set difference equivalence modulo set intersection]
‚îÄ ‚òí theorem rule lCapEquivWeakensDiffEquiv [ X ] 
‚àÄ S , R , T : ‚Ñô X | S ‚à© T = S ‚à© R ‚¶Å S ‚àñ T = S ‚àñ R 
‚îî 
\end{LToolkit}

Similar to \texttt{computeDiff1/2}
‚îÄ ‚òí theorem rule lElemDiffAbsorbption [ X ] 
‚àÄ x : X ; S : ‚Ñô X | ¬¨ x ‚àà S ‚¶Å S ‚àñ { x } = S 
‚îî 

\begin{LToolkit}[Singleton set union absorbs set difference]
‚îÄ ‚òí theorem rule lElemUnionAbsorbDiffRight [ X ] 
‚àÄ x : X ; S : ‚Ñô X | x ‚àà S ‚¶Å { x } ‚à™ ( S ‚àñ { x } ) = S 
‚îî 
\end{LToolkit}

\begin{LToolkit}[Set union absorbs set intersection]
‚îÄ ‚òí theorem rule lUnionAbsorbInter [ X ] 
‚àÄ S , T : ‚Ñô X ‚¶Å S ‚à™ ( T ‚à© S ) = S 
‚îî 
\end{LToolkit}

\begin{LToolkit}[Set union exchange to the right on set difference]
‚îÄ ‚òí theorem rule lUnionExchangeDiffLeft [ X ] 
‚àÄ S , T , Q : ‚Ñô X | Q ‚à© T = { } ‚¶Å ( S ‚àñ T ) ‚à™ Q = ( S ‚à™ Q ) ‚àñ T 
‚îî 
\end{LToolkit}

\begin{LToolkit}[Smaller disjoint sets subsumption]
‚îÄ ‚òí theorem rule lSmallerDisjointSetSubsumption [ X ] 
‚àÄ S , T , Q : ‚Ñô X | S ‚à© T = { } ‚¶Å S ‚à© ( T ‚àñ Q ) = { } 
‚îî 
\end{LToolkit}

Trivial lemmas are those useful lemmas for algebraic proofs. For instance, where
equations are not in the right shape/order to pattern match available rules.
\begin{LTrivial}[Flipping equality]
‚îÄ ‚òí theorem rule lFlipEquiv 
x = y ‚áî y = x 
‚îî \end{LTrivial}

\begin{LToolkit}[Set with an element is not empty]
‚îÄ ‚òí theorem rule lElemSetNonEmpty [ X ] 
‚àÄ set : ‚Ñô X ‚¶Å ‚àÄ elem : set ‚¶Å ¬¨ set = { } 
‚îî \end{LToolkit}

Trivial lemmas named with a ``\texttt{Backwards}'' (at the end)
are dual versions of original toolkit lemmas. For instance, \zeves\
provides the toolkit rule \texttt{cupAssociates}:
\[
  \forall S, T, V: \power  X @ (S \cup  T) \cup  V = S \cup  (T \cup  V)
\]
Sometimes during a proof, it is useful to have this fact the other
way, round (\textit{i.e.,} backwards), hence the following trivial lemma.
\begin{LTrivial}[Set union associates to the left]
‚îÄ ‚òí theorem rule lCupAssociatesBackwards [ X ] 
‚àÄ S , T , V : ‚Ñô X ‚¶Å S ‚à™ ( T ‚à™ V ) = ( S ‚à™ T ) ‚à™ V 
‚îî 
\end{LTrivial}

\begin{LTrivial}[Set difference distributes over union backwards]
‚îÄ ‚òí theorem rule lDistDiffOverUnionLeftBackwards [ X ] 
‚àÄ A , B , C : ‚Ñô X ‚¶Å ( A ‚àñ C ) ‚à™ ( B ‚àñ C ) = ( A ‚à™ B ) ‚àñ C 
‚îî 
\end{LTrivial}

\begin{LRRT}[Expanding $\bigcup$ without knowing the type of $x$]
‚îÄ ‚òí theorem rule lBigCupElemType [ X ] 
‚àÄ S : ‚Ñô ( ‚Ñô X ) | x ‚àà ‚ãÉ S ‚¶Å x ‚àà X 
‚îî 
\end{LRRT}
Usually, all weakening rules are enabled, as they mostly
always improve the chance to increase the pattern matching
of available rewriting rules. Nevertheless, sometimes we
need ``strengthening'' (w.r.t. implication) rules, like the one above.
That is, knowing a stronger fact, we can deduce a weaker one.






\sectionproof{Sets}{theories-sets}

\begin{LPScript}\begin{forget}[lRightDiffLeftDistribute]
apply extensionality;
prenex;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lCapEquivWeakensDiffEquiv]
apply extensionality to predicate S \setminus [X] T = S \setminus [X] R;
prenex;
rewrite;
cases;
split x \in  R;
rewrite;
apply extensionality to predicate S \cap [X] T = R \cap [X] S;
instantiate y == x;
prove by rewrite;
next;
split y \in  T;
rewrite;
apply extensionality to predicate S \cap [X] T = R \cap [X] S;
instantiate x == y;
prove by rewrite;
next;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lDistDiffOverUnionLeftBackwards]
apply distributeDiffOverCupLeft to expression A \cup [X] B \setminus [X] C;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lElemDiffAbsorbption]
apply extensionality;
prove by rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lElemUnionAbsorbDiffRight]
apply extensionality to predicate \{~x~\} \cup [X] (S \setminus [X] \{~x~\}) = S;
prove by rewrite;
split x\_\_0 \in  S;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lUnionAbsorbInter]
apply extensionality to predicate S \cup [X] T \cap [X] S = S;
prove by rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lCupAssociatesBackwards]
prove by rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lUnionExchangeDiffLeft]
apply extensionality;
prove by rewrite;
with normalization rewrite;
instantiate x\_\_0 == x;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lSmallerDisjointSetSubsumption]
apply extensionality;
prove by rewrite;
instantiate x\_\_0 == x;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lFlipEquiv]
split x = y;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lElemSetNonEmpty]
apply extensionality;
instantiate x == elem;
prove;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lBigCupElemType]
prove by rewrite;
\end{forget}\end{LPScript}


\section{Finiteness}

Leave enabled!
\begin{LTrivial}[Improved version of toolkit rule $crossFinite$]
‚îÄ theorem rule lCrossFinite2 
A √ó B ‚àà ùîΩ ( C √ó D ) ‚áî A = { } ‚à® B = { } ‚à® ( A ‚àà ùîΩ C ‚àß B ‚àà ùîΩ D ) 
‚îî 
\end{LTrivial}

\begin{LTrivial}[Subset of finite set is finite]
‚îÄ ‚òí theorem lFinsetSubset 
X ‚àà ‚Ñô Y ‚àß Y ‚àà ùîΩ Z ‚áí X ‚àà ùîΩ Z 
‚îî 
\end{LTrivial}

\begin{LAbbr}[Inductive definition for $\finset$]
\syndef{\finsetinduc}{pregen}{"&fsetinduc"} \quad\verb'\finsetinduc'

‚îÄ generic ( finsetinduc _ ) ‚îî 

‚îÄ ‚òì finsetinduc X == ‚ãÇ { A : ‚Ñô ( ‚Ñô X ) | ¬¨ { } ‚àà A ‚àß ( ‚àÄ a : A ; x : X ‚¶Å a ‚à™ { x } ‚àà A ) } ‚îî \end{LAbbr}

Leave enabled!
\begin{LRRT}[Inferring finite sets are subset of infinite sets]
‚îÄ theorem rule lIsFinite 
x ‚àà ùîΩ X ‚áí x ‚àà ‚Ñô X 
‚îî 
\end{LRRT}

\sectionproof{Finiteness}{theories-finiteness}

\begin{LPScript}\begin{forget}[lCrossFinite2]
    rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lFinsetSubset]
    rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lIsFinite]
prove by rewrite;
\end{forget}\end{LPScript}
\section{Domain and range anti-restriction}

Leave enabled!
\begin{LToolkit}[Range element of homogeneous $R$ is in $\ndres$]
‚îÄ theorem rule lInHomogeneousElemRanNDres [ X ] 
‚àÄ x , d : X ; R : X ‚Üî X | x ‚àà ran R ‚àß ¬¨ d ‚àà dom R ‚¶Å x ‚àà ran ( { d } ‚©§ R ) 
‚îî 
\end{LToolkit}

The next lemma is obvious, but useful in proofs
\begin{LToolkit}[Not range element of homogeneous $R$ is not in $\ndres$]
‚îÄ ‚òí theorem rule lInHomogeneousNotElemRanNDres [ X ] 
‚àÄ x , d : X ; R : X ‚Üî X | ¬¨ x ‚àà ran R ‚¶Å ¬¨ x ‚àà ran ( { d } ‚©§ R ) 
‚îî 
\end{LToolkit}

\begin{LToolkit}[Absorbtion for range union with $\ndres$ on homogeneous $R$]
‚îÄ ‚òí theorem rule lHomoheneousUnionRanNDres [ X ] 
‚àÄ x : X ; R : X ‚Üî X ‚¶Å ran R ‚à™ ran ( { x } ‚©§ R ) = ran R 
‚îî 
\end{LToolkit}

\begin{LToolkit}[Singleton $\oplus$ absorbs singleton $\ndres$]
‚îÄ ‚òí theorem rule lUnitOplusAbsorbsUnitNDres [ X , Y ] 
‚àÄ x : X ; y : Y ; R : X ‚Üî Y ‚¶Å { x } ‚©§ R ‚äï { ( x , y ) } = R ‚äï { ( x , y ) } 
‚îî 
\end{LToolkit}

For this rule, one needs to use \texttt{with disabled (ndresNdres) rewrite}.
\begin{LToolkit}[$\ndres$ exchange with itself]
‚îÄ ‚òí theorem rule lNDresExchange [ X , Y ] 
‚àÄ S , T : ‚Ñô X ; R : X ‚Üî Y ‚¶Å S ‚©§ ( T ‚©§ R ) = T ‚©§ ( S ‚©§ R ) 
‚îî \end{LToolkit}

\begin{LToolkit}[$\ndres$-$\oplus$ associate, provided no common elements]
‚îÄ ‚òí theorem rule lNDresOplusAssociates [ X , Y ] 
‚àÄ S : ‚Ñô X ; R , Q : X ‚Üî Y | S ‚à© dom Q = { } ‚¶Å ( S ‚©§ R ) ‚äï Q = S ‚©§ ( R ‚äï Q ) 
‚îî \end{LToolkit}

\begin{LToolkit}[$\ndres$-$\oplus$-unit associate, provided distinction]
‚îÄ ‚òí theorem rule lNDresUnitOplusUnitAssociates [ X , Y ] 
‚àÄ a , b : X ; c : Y ; R : X ‚Üî Y | ¬¨ a = b ‚¶Å { a } ‚©§ R ‚äï { ( b , c ) } = { a } ‚©§ ( R ‚äï { ( b , c ) } ) 
‚îî \end{LToolkit}

\begin{LToolkit}[$\ran~$-$\ndres$-unit, provided distinction]
‚îÄ ‚òí theorem rule lInRanNDresUnit [ X , Y ] 
‚àÄ x , d : X ; y : Y ; R : X ‚Üî Y | ( x , y ) ‚àà R ‚àß ¬¨ x = d ‚¶Å y ‚àà ran ( { d } ‚©§ R ) 
‚îî \end{LToolkit}

Just like \texttt{ndresNdres}
\begin{LTrivial}[$\ndres$ absorbs $\cup$ to the right]
‚îÄ ‚òí theorem rule lNDresNDresBackwards [ X , Y ] 
‚àÄ S , T : ‚Ñô X ; R : X ‚Üî Y ‚¶Å ( S ‚à™ T ) ‚©§ R = S ‚©§ ( T ‚©§ R ) 
‚îî \end{LTrivial}

Just like \texttt{nrresNrres}
\begin{LTrivial}[$\nrres$ absorbs $\cup$ to the left]
‚îÄ ‚òí theorem rule lNRresNRresBackwards [ X , Y ] 
‚àÄ S , T : ‚Ñô Y ; R : X ‚Üî Y ‚¶Å R ‚©• ( S ‚à™ T ) = ( R ‚©• S ) ‚©• T 
‚îî \end{LTrivial}

\begin{LToolkit}[$\dres$-$\ndres$-set-difference trading]
‚îÄ ‚òí theorem rule lDResNDresTradingSetminus [ X , Y ] 
‚àÄ f , g : X ‚á∏ Y ; s : ‚Ñô X ‚¶Å s ‚óÅ ( dom g ‚©§ f ) = ( s ‚àñ dom g ) ‚óÅ f 
‚îî \end{LToolkit}\sectionproof{Domain and range restriction}{theories-domran-antirestriction}

\begin{LPScript}\begin{forget}[lInHomogeneousElemRanNDres]
apply inRan;
apply inDom;
prenex;
rewrite;
instantiate y == x;
instantiate x\_\_1 == x\_\_0;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lInHomogeneousNotElemRanNDres]
apply inRan;
rewrite;
\end{forget}\end{LPScript}


\begin{LPScript}\begin{forget}[lHomoheneousUnionRanNDres]
apply extensionality;
prove by rewrite;
split x\_\_0 \in  \ran~ [X, X] R;
prove by rewrite;
rearrange;
apply lInHomogeneousNotElemRanNDres;
prove by rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lUnitOplusAbsorbsUnitNDres]
apply extensionality;
prove by rewrite;
apply oplusDef;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lNDresExchange]
prove by rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lNDresOplusAssociates]
apply  extensionality;
apply  oplusDef ;
prove by rewrite;
with normalization rewrite;
instantiate  x\_\_0 == x.1;
prove by rewrite;
with normalization rewrite;
apply  inDom ;
invoke (\_ \rel  \_);
apply inPower to predicate Q \in  \power  (X \cross  Y);
instantiate  e == x;
apply  inCross2;
prove by rewrite;
instantiate  y\_\_1 == y;
prove by rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lNDresUnitOplusUnitAssociates]
apply  lNDresOplusAssociates;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lInRanNDresUnit]
apply  inRan ;
rewrite;
instantiate  x\_\_0 == x;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lNDresNDresBackwards]
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lNRresNRresBackwards]
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lDResNDresTradingSetminus]
    apply extensionality;
    prove;
\end{forget}\end{LPScript}\section{Basic types}\label{basic-datatype}

‚ï∑ maxpid : ‚Ñï‚Üò1‚Üñ ‚îî 

‚îÄ theorem rule lMaxPIDPositive 
1 ‚â§ maxpid 
‚îî 

‚îÄ ‚òì PID == 1 .. maxpid ‚îî 

‚îÄ theorem rule lPIDNotEmpty 
¬¨ PID = { } 
‚îî 

‚îÄ theorem rule lMinPIDValue 
1 ‚àà PID 
‚îî 

‚îÄ theorem grule gMaxpidMaxType 
maxpid ‚àà ‚Ñ§ 
‚îî 

‚îÄ theorem rule lMaxpidIsPID 
maxpid ‚àà PID 
‚îî 

‚ï∑ nullpid : ‚Ñï |
 ‚àÄ p : PID ‚¶Å p < nullpid ‚îî 

‚îÄ theorem rule lNullpidBound 
maxpid < nullpid 
‚îî 

‚îÄ theorem rule lNullPIDDisjoint 
‚àÄ p : PID ‚¶Å ¬¨ p = nullpid 
‚îî 

‚îÄ ‚òì GPID == PID ‚à™ { nullpid } ‚îî 

‚îÄ theorem grule gPIDMaxType 
PID ‚àà ‚Ñô ‚Ñ§ 
‚îî 

‚îÄ theorem grule gGPIDMaxType 
GPID ‚àà ‚Ñô ‚Ñ§ 
‚îî 

‚îÄ theorem rule lNullIsGPID 
nullpid ‚àà GPID 
‚îî 

‚îÄ theorem rule lNullIsNotPID 
¬¨ nullpid ‚àà PID 
‚îî 

‚îÄ theorem rule lPIDIsGPID 
‚àÄ x : PID ‚¶Å x ‚àà GPID 
‚îî 

‚îÄ theorem rule lMinPIDIsGPID 
1 ‚àà GPID 
‚îî 

‚îÄ theorem rule lMaxPIDIsGPID 
maxpid ‚àà GPID 
‚îî 

‚îÄ theorem rule lNonNullGPIDIsPID 
‚àÄ p : GPID | ¬¨ p = nullpid ‚¶Å p ‚àà PID 
‚îî \section{Chain}\label{chain-datatype-def}

‚îå Chain 
start , end : GPID 
links : PID ‚§î PID 
set : ‚Ñô PID |
 links ‚àà ùîΩ ( PID √ó PID ) 
set ‚àà ùîΩ PID 
set = dom links ‚à™ ran links ‚à™ ( { start } ‚àñ { nullpid } ) 
links = ‚àÖ ‚áí start = end 
links ‚â† ‚àÖ ‚áí { start } = dom links ‚àñ ran links ‚àß { end } = ran links ‚àñ dom links 
‚àÄ e : set | e ‚â† start ‚¶Å start ‚Ü¶ e ‚àà links ‚Üó+‚Üô ‚îî 

\section{Chain data type properties}

‚îÄ ‚òí theorem lEmptySetNullChain 
‚àÄ Chain | set = { } ‚¶Å start = end = nullpid 
‚îî 

‚îÄ ‚òí theorem lEmptySetEmptyLinks 
‚àÄ Chain | set = { } ‚¶Å links = { } 
‚îî 

‚îÄ ‚òí theorem lEmptyLinksSingletonChain 
‚àÄ Chain | links = { } ‚¶Å start = end 
‚îî 

‚îÄ ‚òí theorem rule lNonEmptySetNonNullStart 
‚àÄ Chain | ¬¨ set = { } ‚¶Å ¬¨ start = nullpid 
‚îî 

‚îÄ ‚òí theorem rule lNonEmptyLinksStartLinked 
‚àÄ Chain | ¬¨ links = { } ‚¶Å start ‚àà dom links 
‚îî 

‚îÄ ‚òí theorem rule lNonEmptyLinksStartNotNull 
‚àÄ Chain | ¬¨ links = { } ‚¶Å ¬¨ start = nullpid 
‚îî 

‚îÄ ‚òí theorem rule lNonEmptyLinksStartNotInRan 
‚àÄ Chain | ¬¨ links = { } ‚¶Å ¬¨ start ‚àà ran links 
‚îî 

‚îÄ ‚òí theorem rule lNonEmptyLinksEndNotInDom 
‚àÄ Chain | ¬¨ links = { } ‚¶Å ¬¨ end ‚àà dom links 
‚îî 

‚îÄ ‚òí theorem rule lNonEmptyLinksEndNotNull 
‚àÄ Chain | ¬¨ links = { } ‚¶Å ¬¨ end = nullpid 
‚îî 

‚îÄ ‚òí theorem rule lNonEmptyLinksEndLinked 
‚àÄ Chain | ¬¨ links = { } ‚¶Å end ‚àà ran links 
‚îî 

‚îÄ ‚òí theorem rule lChainLinksHasNoNullPid 
‚àÄ links : PID ‚§î PID ‚¶Å ¬¨ nullpid ‚àà dom links ‚à™ ran links 
‚îî 

‚îÄ ‚òí theorem rule lChainLinksHasNoNullPidInDom 
‚àÄ links : PID ‚§î PID ‚¶Å ¬¨ nullpid ‚àà dom links 
‚îî 

‚îÄ ‚òí theorem rule lChainLinksHasNoNullPidInRan 
‚àÄ links : PID ‚§î PID ‚¶Å ¬¨ nullpid ‚àà ran links 
‚îî 

‚îÄ ‚òí theorem rule lChainElemNonEmptyLinks 
‚àÄ Chain ; p? : PID | p? ‚àà set ‚àß ¬¨ p? = start ‚¶Å ¬¨ links = { } 
‚îî 

‚îÄ ‚òí theorem rule lChainElemInDom 
‚àÄ Chain ; p? : PID | ¬¨ links = { } ‚àß p? ‚àà set ‚àß ¬¨ p? ‚àà ran links ‚¶Å p? ‚àà dom links 
‚îî 

‚îÄ ‚òí theorem lChainMidElemEverywhere 
‚àÄ Chain ; p? : PID | p? ‚àà set ‚àß ¬¨ p? = start ‚àß ¬¨ p? = end ‚¶Å p? ‚àà dom links ‚àß p? ‚àà ran links 
‚îî  \section{Chain operations}

‚îÄ ChainErrorMessage ::= chain_ok | push_known_element_error | pop_empty_error | pop_multiple_error ‚îî 

‚îå ChainInit 
Chain ‚Ä≤ |
 start‚Ä≤ = end‚Ä≤ = nullpid ‚îî 

‚îå PushEmpty 
ŒîChain 
p? : PID |
 end = nullpid 
end‚Ä≤ = p? 
links‚Ä≤ = links ‚îî 

‚îå PushNonEmpty 
ŒîChain 
p? : PID |
 end ‚â† nullpid 
links‚Ä≤ = links ‚à™ { ( end ‚Ü¶ p? ) } ‚îî 

‚îÄ Push0 == PushEmpty ‚à® PushNonEmpty ‚îî 

\znote{We cannot push an known element}
‚îå PushKnownElementError 
ŒûChain 
p? : PID 
msg! : ChainErrorMessage |
 p? ‚àà set 
msg! = push_known_element_error ‚îî 

‚îå ChainSuccess 
msg! : ChainErrorMessage |
 msg! = chain_ok ‚îî 

‚îÄ Push == Push0 ‚àß ChainSuccess ‚à® PushKnownElementError ‚îî 

‚îå PopSingleton 
ŒîChain 
p! : PID |
 start ‚â† nullpid 
links = ‚àÖ 
start‚Ä≤ = nullpid 
links‚Ä≤ = links 
p! = start ‚îî 

‚îå PopMultiple_AtLeastTwoLinks 
ŒîChain 
p! : PID |
 links ‚â† ‚àÖ 
start‚Ä≤ = links start 
links‚Ä≤ = { start } ‚©§ links 
p! = start ‚îî 

‚îÄ Pop0 == PopSingleton ‚à® PopMultiple_AtLeastTwoLinks ‚îî 

‚îå PopEmpty 
ŒûChain 
msg! : ChainErrorMessage |
 start = nullpid 
msg! = pop_empty_error ‚îî 

‚îå PopMultiple_TooFewElements 
ŒûChain 
msg! : ChainErrorMessage |
 links ‚â† ‚àÖ 
links start ‚àâ dom links 
msg! = pop_multiple_error ‚îî 

‚îÄ PopSingletonComplete == ( PopSingleton ‚àß ChainSuccess ) ‚à® PopEmpty ‚îî 

‚îÄ PopMultipleComplete == ( PopMultiple_AtLeastTwoLinks ‚àß ChainSuccess ) ‚à® PopMultiple_TooFewElements ‚îî 

‚îÄ Pop0Okay == Pop0 ‚àß ChainSuccess ‚îî ‚îÄ PopErr == PopEmpty ‚à® PopMultiple_TooFewElements ‚îî ‚îÄ Pop == Pop0Okay ‚à® PopErr ‚îî 

‚îÄ PopComplete == PopMultipleComplete ‚à® PopSingletonComplete ‚îî 

‚îå DeleteStart 
ŒîChain 
p? : PID 
msg! : ChainErrorMessage |
 p? = start 
‚àÉ p! : PID ‚¶Å PopComplete ‚îî 

‚îå DeleteEnd 
ŒîChain 
p? : PID 
ChainSuccess |
 p? ‚â† start 
p? = end 
links‚Ä≤ = links ‚©• { end } ‚îî 

‚îå DeleteMiddle 
ŒîChain 
p? : PID 
ChainSuccess |
 p? ‚â† start 
p? ‚â† end 
p? ‚àà set 
links‚Ä≤ = { p? } ‚©§ links ‚äï { ( ( links ‚àº ) p? ‚Ü¶ links p? ) } ‚îî 

‚îÄ Delete0 == DeleteStart ‚à® DeleteEnd ‚à® DeleteMiddle ‚îî 
\section{Chain operations auxiliary properties}

These are useful for $tPREPushMultiple$
‚îÄ ‚òí theorem rule lLinksPushUpdateIsPInj 
‚àÄ Chain ; p? : PID | end ‚â† nullpid ‚àß p? ‚àâ set ‚¶Å links ‚à™ { ( end , p? ) } ‚àà PID ‚§î PID 
‚îî 

‚îÄ ‚òí theorem rule lLinksDomElemType 
‚àÄ links : PID ‚§î PID | ( x , y ) ‚àà links ‚¶Å x ‚àà PID 
‚îî 

‚îÄ ‚òí theorem rule lLinksRanElemType 
‚àÄ links : PID ‚§î PID | ( x , y ) ‚àà links ‚¶Å y ‚àà PID 
‚îî 

‚îÄ ‚òí theorem rule lLinksElemType 
‚àÄ links : PID ‚§î PID | x ‚àà links ‚¶Å x ‚àà PID √ó PID 
‚îî 


‚îÄ theorem rule lChainStartLeadsToValidPID 
‚àÄ Chain | ¬¨ links = { } ‚¶Å links start ‚àà PID 
‚îî 

These three are useful for $tPREPopMultiple$
‚îÄ ‚òí theorem rule lTransClosureOneStepForwardChainTraversal [ X ] 
‚àÄ s , e : X ; f : X ‚á∏ X | s ‚àà dom f ‚àß ¬¨ f s = e ‚àß ( s , e ) ‚àà f ‚Üó+‚Üô ‚¶Å ( f s , e ) ‚àà f ‚Üó+‚Üô 
‚îî 

‚îÄ ‚òí theorem rule lTransitiveClosureChainHeadExtract [ X ] 
‚àÄ s , e : X ; f : X ‚á∏ X | s ‚àà dom f ‚àß ¬¨ s ‚àà ran f ‚àß f s ‚àà dom f ‚àß ¬¨ f s = e ‚àß ( s , e ) ‚àà f ‚Üó+‚Üô ‚¶Å ( f s , e ) ‚àà ( { s } ‚©§ f ) ‚Üó+‚Üô 
‚îî 

‚îÄ ‚òí theorem lNonEmptyLinksSingleton 
‚àÄ Chain | ( start , end ) ‚àà links ‚¶Å links = { ( start , end ) } 
‚îî 

These three are useful for $tPREDeleteMiddle$
‚îÄ ‚òí theorem rule lHomogeneousPInjMidPointExtractNotInRan [ X ] 
‚àÄ f : X ‚§î X ; x , y , p? : X | ( x , p? ) ‚àà f ‚àß ( p? , y ) ‚àà f ‚àß ¬¨ x = p? ‚àß ¬¨ p? = y ‚¶Å ¬¨ p? ‚àà ran ( { p? } ‚©§ f ‚äï { ( x , y ) } ) 
‚îî 

‚îÄ ‚òí theorem rule lHomogeneousMidPointExtractRanEquiv [ X ] 
‚àÄ f : X ‚§î X ; x , y , p? : X | ( x , p? ) ‚àà f ‚àß ( p? , y ) ‚àà f ‚àß ¬¨ x = p? ‚àß ¬¨ p? = y ‚¶Å { p? } ‚à™ ran ( { p? } ‚©§ f ‚äï { ( x , y ) } ) = { p? , y } ‚à™ ran f 
‚îî 

for fun!
‚îÄ ‚òí theorem rule lHomogeneousMidPointExchangeRanEquiv [ X ] 
‚àÄ f : X ‚§î X ; x , y , p? : X | ( x , p? ) ‚àà f ‚àß ( p? , y ) ‚àà f ‚àß ¬¨ x = p? ‚àß ¬¨ p? = y ‚¶Å ran ( { p? } ‚©§ f ‚äï { ( x , y ) } ) ‚àñ dom f = ran ( { x } ‚©§ f ‚äï { ( p? , y ) } ) ‚àñ dom f 
‚îî 


\section{Chain operation preconditions}

‚îå PushEmptySig 
Chain 
p? : PID |
 end = nullpid ‚îî 

‚îå PushNonEmptySig 
Chain 
p? : PID |
 end ‚â† nullpid 
p? ‚àâ set ‚îî 

We cannot push an known element
‚îå PushKnownElementErrorSig 
Chain 
p? : PID |
 p? ‚àà set ‚îî 

‚îå Push0Sig 
Chain 
p? : PID |
 p? ‚àâ set ‚îî 

‚îå PushSig 
Chain 
p? : PID |
 true ‚îî 

‚îå PopSingletonSig 
Chain |
 start ‚â† nullpid 
links = ‚àÖ ‚îî 

‚îå PopMultiple_AtLeastTwoLinksSig 
Chain |
 links ‚â† ‚àÖ 
links start ‚àà dom links ‚îî 

‚îå Pop0Sig 
Chain |
 links = ‚àÖ ‚áí start ‚â† nullpid 
links ‚â† ‚àÖ ‚áí links start ‚àà dom links ‚îî 

‚îå PopEmptySig 
Chain |
 start = nullpid ‚îî 

‚îå PopMultiple_TooFewElementsSig 
Chain |
 links ‚â† ‚àÖ 
links start ‚àâ dom links ‚îî 

‚îÄ PopErrSig == PopEmptySig ‚à® PopMultiple_TooFewElementsSig ‚îî 

‚îå PopSingletonCompleteSig 
Chain |
 links = ‚àÖ ‚îî 

‚îå PopMultipleCompleteSig 
Chain |
 links ‚â† ‚àÖ ‚îî 

‚îå PopCompleteSig 
Chain |
 true ‚îî 

‚îå PopSig 
Chain |
 true ‚îî 

‚îå DeleteStartSig 
Chain 
p? : PID |
 p? = start ‚îî 

‚îå DeleteEndSig 
Chain 
p? : PID |
 p? ‚â† start 
p? = end ‚îî 

‚îå DeleteMiddleSig 
Chain 
p? : PID |
 p? ‚â† start 
p? ‚â† end 
p? ‚àà set ‚îî 

‚îÄ theorem tPREChainInit 
‚àÉ Chain ‚Ä≤ ‚¶Å ChainInit 
‚îî 

‚îÄ theorem tPREPushEmpty 
‚àÄ PushEmptySig ‚¶Å pre PushEmpty 
‚îî 


Depends on: lLinksPushUpdateIsPInj, lInTransitiveClosure, lUnitTransitiveClosure,
            lUnionTransitiveClosure, lUnionSingletonTransitiveClosure
‚îÄ theorem tPREPushNonEmpty 
‚àÄ PushNonEmptySig ‚¶Å pre PushNonEmpty 
‚îî 

‚îÄ theorem tPREPush0 
‚àÄ Push0Sig ‚¶Å pre Push0 
‚îî 

‚îÄ theorem tPREPushKnownElementError 
‚àÄ PushKnownElementErrorSig ‚¶Å pre PushKnownElementError 
‚îî 

‚îÄ theorem tPREPushIsTotal 
‚àÄ PushSig ‚¶Å pre Push 
‚îî 

‚îÄ theorem tPREPopSingleton 
‚àÄ PopSingletonSig ‚¶Å pre PopSingleton 
‚îî 

‚îÄ theorem tPREPopMultiple_AtLeastTwoLinks 
‚àÄ PopMultiple_AtLeastTwoLinksSig ‚¶Å pre PopMultiple_AtLeastTwoLinks 
‚îî 

‚îÄ theorem tPREPop0 
‚àÄ Pop0Sig ‚¶Å pre Pop0 
‚îî 

‚îÄ theorem tPREPopEmpty 
‚àÄ PopEmptySig ‚¶Å pre PopEmpty 
‚îî 

‚îÄ theorem tPREPopMultiple_TooFewElements 
‚àÄ PopMultiple_TooFewElementsSig ‚¶Å pre PopMultiple_TooFewElements 
‚îî 

‚îÄ theorem tPREPopSinglegonComplete 
‚àÄ PopSingletonCompleteSig ‚¶Å pre PopSingletonComplete 
‚îî 

‚îÄ theorem tPREPopMultipleComplete 
‚àÄ PopMultipleCompleteSig ‚¶Å pre PopMultipleComplete 
‚îî 

‚îÄ theorem tPREPopCompleteIsTotal 
‚àÄ PopCompleteSig ‚¶Å pre PopComplete 
‚îî 

‚îÄ theorem tPREPop0Okay 
‚àÄ Pop0Sig ‚¶Å pre Pop0Okay 
‚îî 

‚îÄ theorem tPREPopErr 
‚àÄ PopErrSig ‚¶Å pre PopErr 
‚îî 

‚îÄ theorem tPREPopIsTotal 
‚àÄ PopSig ‚¶Å pre Pop 
‚îî 

‚îÄ theorem tPREDeleteStart 
‚àÄ DeleteStartSig ‚¶Å pre DeleteStart 
‚îî 

‚îÄ theorem tPREDeleteEnd 
‚àÄ DeleteEndSig ‚¶Å pre DeleteEnd 
‚îî 

‚îÄ ‚òí theorem rule lDeleteTransitiveClosureLinksUpdateLemma 
‚àÄ links : PID ‚§î PID ; p? , x , y : PID | ¬¨ x = p? ‚àß ( p? , y ) ‚àà links ‚¶Å { p? } ‚©§ links ‚äï { ( x , y ) } ‚àà PID ‚§î PID 
‚îî 

‚îÄ ‚òí theorem rule lEndEquivalenceLemma 
‚àÄ DeleteMiddleSig ; x , y : PID | ¬¨ links = { } ‚àß y ‚àà ran links ‚àß ¬¨ p? = y ‚àß ¬¨ x = p? ‚àß ( p? , y ) ‚àà links ‚àß ( x , p? ) ‚àà links ‚¶Å { end } = ran ( { p? } ‚©§ links ‚äï { ( x , y ) } ) ‚àñ dom links 
‚îî 

‚îå ChainMidPoint 
Chain 
x , y , p? : PID |
 ¬¨ links = { } 
p? ‚àà dom links 
p? ‚àà ran links 
x ‚àà PID 
y ‚àà PID 
y = links p? 
x = ( links ‚àº ) p? 
¬¨ p? ‚àà { start , end , x , y } 
( x , p? ) ‚àà links 
( p? , y ) ‚àà links 
¬¨ ( x , y ) ‚àà links ‚îî 

‚îÄ theorem frule lChainLinks 
‚àÄ Chain ‚¶Å links ‚àà PID ‚§î PID 
‚îî 

‚îÄ ‚òí theorem rule lChainMidPointLinksMidPointEquiv 
‚àÄ ChainMidPoint ‚¶Å ( { p? } ‚à™ { x } ) ‚óÅ links = { ( x , p? ) , ( p? , y ) } 
‚îî 

‚îå LinksFilterSets 
ChainMidPoint 
links_upto_midpoint , last_link_before_midpoint , links_at_midpoint , links_from_midpoint , all_links : ‚Ñô PID 
all_links_filters_segments : seq ( ‚Ñô PID ) |
 links_upto_midpoint = { i : PID | x ‚àà ran links ‚àß ( i , ( links ‚àº ) x ) ‚àà links ‚Üó+‚Üô } 
last_link_before_midpoint = { l : PID | x ‚àà ran links ‚àß l = ( links ‚àº ) x } 
links_at_midpoint = { x , p? } 
links_from_midpoint = { j : PID | ( y , j ) ‚àà links ‚Üó+‚Üô ‚àß ( j , end ) ‚àà links ‚Üó+‚Üô } 
all_links = links_upto_midpoint ‚à™ last_link_before_midpoint ‚à™ links_at_midpoint ‚à™ ( { y } ‚à™ links_from_midpoint ) 
all_links_filters_segments = ‚ü® links_upto_midpoint ‚à™ last_link_before_midpoint , links_at_midpoint , { y } ‚à™ links_from_midpoint ‚ü© ‚îî 

‚îå LinksPartition 
LinksFilterSets 
links_before , links_midpoint , links_after : PID ‚§î PID 
all_links_segments : seq ( PID ‚§î PID ) |
 links_before = ( links_upto_midpoint ‚à™ last_link_before_midpoint ) ‚óÅ links 
links_midpoint = { x , p? } ‚óÅ links 
links_after = ( { y } ‚à™ links_from_midpoint ) ‚óÅ links 
all_links_segments = ‚ü® links_before , links_midpoint , links_after ‚ü© ‚îî 

‚îÄ ‚òí theorem lChainMidPointFilterSetsEquivalence 
‚àÄ LinksFilterSets ‚¶Å all_links = ‚ãÉ ( ran all_links_filters_segments ) 
‚îî 

‚îÄ ‚òí theorem lChainMidPointFilterSetsDisjoint 
‚àÄ LinksFilterSets ‚¶Å disjoint all_links_filters_segments 
‚îî 

‚îÄ ‚òí theorem lChainMidPointFilterSetsEncompassAllLinks 
‚àÄ LinksFilterSets ‚¶Å dom links ‚äÜ all_links 
‚îî 

‚îÄ ‚òí theorem lChainMidPointLinksPartition 
‚àÄ LinksPartition ‚¶Å all_links_segments partition links 
‚îî 

‚îå DeleteTransitiveClosureCase 
links : PID ‚§î PID 
start , p? , x , y : PID |
 ‚àÄ elem : dom links ‚àñ { p? } ‚à™ ran ( { p? } ‚©§ links ‚äï { ( x , y ) } ) | ¬¨ elem = start ‚¶Å ( start , elem ) ‚àà ( { p? } ‚©§ links ‚äï { ( x , y ) } ) ‚Üó+‚Üô ‚îî 

‚îÄ ‚òí theorem rule lDeleteTransitiveClosureLemma 
‚àÄ DeleteMiddleSig ; x , y : PID | ¬¨ links = { } ‚àß y ‚àà ran links ‚àß ¬¨ p? = y ‚àß ¬¨ x = p? ‚àß y = links p? ‚àß ( p? , y ) ‚àà links ‚àß ( x , p? ) ‚àà links ‚àß ¬¨ ( x , y ) ‚àà links ‚àß ¬¨ p? ‚àà ran ( { p? } ‚©§ links ‚äï { ( x , y ) } ) ‚àß { end } = ran ( { p? } ‚©§ links ‚äï { ( x , y ) } ) ‚àñ dom links ‚¶Å DeleteTransitiveClosureCase 
‚îî 


‚îÄ theorem tPREDeleteMiddle 
‚àÄ DeleteMiddleSig ‚¶Å pre DeleteMiddle 
‚îî  \sectionproof{Basic data types}{basic-datatype}

\begin{forget}[lMaxPIDPositive]
use maxpid\$declaration;
apply inNat1;
simplify;
\end{forget}

\begin{forget}[lPIDNotEmpty]
apply extensionality;
invoke PID;
prove by rewrite;
instantiate x == 1;
rewrite;
\end{forget}

\begin{forget}[lMinPIDValue]
with enabled (PID) prove by reduce;
\end{forget}

\begin{forget}[gMaxpidMaxType]
rewrite;
\end{forget}

\begin{forget}[lMaxpidIsPID]
with enabled (PID) prove by reduce;
\end{forget}


\begin{forget}[lNullpidBound]
use dNullPID[p := maxpid];
invoke PID;
rewrite;
\end{forget}

\begin{forget}[lNullPIDDisjoint]
use dNullPID;
rearrange;
rewrite;
\end{forget}

\begin{forget}[gPIDMaxType]
invoke PID;
rewrite;
\end{forget}

\begin{forget}[gGPIDMaxType]
invoke GPID;
invoke PID;
prove by rewrite;
\end{forget}

\begin{forget}[lNullIsGPID]
invoke GPID;
rewrite;
\end{forget}

\begin{forget}[lNullIsNotPID]
use lNullpidBound;
invoke PID;
apply inRange;
simplify;
\end{forget}

\begin{forget}[lPIDIsGPID]
with enabled (GPID) prove by reduce;
\end{forget}

\begin{forget}[lMinPIDIsGPID]
rewrite;
\end{forget}

\begin{forget}[lMaxPIDIsGPID]
rewrite;
\end{forget}

\begin{forget}[lNonNullGPIDIsPID]
   invoke GPID;
   prove by rewrite;
\end{forget} \sectionproof{Chain data type properties}{chain-datatype-properties}

\begin{forget}[lEmptySetNullChain]
invoke Chain;
prove by rewrite;
\end{forget}

\begin{forget}[lEmptyLinksSingletonChain]
invoke Chain;
prove by rewrite;
\end{forget}

\begin{forget}[lEmptySetEmptyLinks]
invoke Chain;
prove by rewrite;
\end{forget}

\begin{forget}[lNonEmptySetNonNullStart]
invoke Chain;
rearrange;
rewrite;
split links = \{\};
rewrite;
invoke GPID;
rearrange;
rewrite;
rearrange;
with normalization rewrite;
apply extensionality to predicate \{start\} = \dom~ links \setminus  \ran~  links;
rewrite;
\end{forget}

\begin{forget}[lNonEmptyLinksStartLinked]
invoke Chain;
rearrange;
rewrite;
apply extensionality to predicate \{~start~\} = \dom~  links \setminus  \ran~  links;
rewrite;
\end{forget}

\begin{forget}[lNonEmptyLinksStartNotNull]
invoke Chain;
rearrange;
rewrite;
apply extensionality to predicate \{~start~\} = \dom~  links \setminus  \ran~  links;
invoke GPID;
rewrite;
\end{forget}

\begin{forget}[lNonEmptyLinksStartNotInRan]
invoke Chain;
rearrange;
rewrite;
apply extensionality to predicate \{~start~\} = \dom~  links \setminus  \ran~  links;
rewrite;
\end{forget}

\begin{forget}[lNonEmptyLinksEndNotInDom]
invoke Chain;
rearrange;
rewrite;
apply extensionality to predicate \{~end~\} = \ran~  links \setminus  \dom~  links;
rewrite;
\end{forget}

\begin{forget}[lNonEmptyLinksEndNotNull]
invoke Chain;
rearrange;
rewrite;
apply extensionality to predicate \{~end~\} = \ran~  links \setminus  \dom~  links;
invoke GPID;
rewrite;
\end{forget}

\begin{forget}[lNonEmptyLinksEndLinked]
invoke Chain;
rearrange;
rewrite;
apply extensionality to predicate \{~end~\} = \ran~  links \setminus  \dom~  links;
rewrite;
\end{forget}

\begin{forget}[lChainLinksHasNoNullPid]
split links = \emptyset;
rewrite;
apply inDom to predicate nullpid \in  \dom~  links;
apply inRan to predicate nullpid \in  \ran~  links;
rewrite;
prenex;
rewrite;
invoke (\_\pinj \_);
invoke (\_\pfun \_);
invoke (\_\rel \_);
rewrite;
rewrite;
apply inPower to predicate links \in  \power~  (PID \cross  PID);
cases;
rewrite;
instantiate e == (nullpid, y);
apply tupleInCross2;
rewrite;
next;
instantiate e == (x, nullpid);
apply tupleInCross2;
rewrite;
next;
\end{forget}

\begin{forget}[lChainLinksHasNoNullPidInDom]
use lChainLinksHasNoNullPid;
rearrange;
apply inCup;
rewrite;
\end{forget}

\begin{forget}[lChainLinksHasNoNullPidInRan]
use lChainLinksHasNoNullPid;
rearrange;
apply inCup;
rewrite;
\end{forget}

\begin{forget}[lChainElemNonEmptyLinks]
invoke Chain;
invoke GPID;
equality substitute;
rewrite;
rearrange;
split start = nullpid;
rewrite;
cases;
split end = nullpid;
rewrite;
apply extensionality to predicate links = \{\};
rewrite;
split p? \in  \dom~ links;
simplify;
cases;
apply inDom to predicate p? \in  \dom~ links;
prenex;
instantiate x\_\_0 == (p?, y);
rearrange;
rewrite;
next;
apply inRan to predicate p? \in  \ran~  links;
prenex;
instantiate x\_\_1 == (x, p?);
rewrite;
next;
split end = nullpid;
rewrite;
rearrange;
rewrite;
rearrange;
rewrite;
apply extensionality to predicate links = \{\};
rewrite;
prenex;
split p? \in  \dom~ links;
simplify;
cases;
apply inDom to predicate p? \in  \dom~ links;
prenex;
rearrange;
instantiate x\_\_1 == (p?, y);
rewrite;
next;
apply inRan to predicate p? \in  \ran~  links;
prenex;
instantiate x\_\_2 == (x\_\_0, p?);
rewrite;
next;
\end{forget}

\begin{forget}[lChainElemInDom]
invoke Chain;
equality substitute;
rearrange;
rewrite;
split start = nullpid;
rewrite;
split p? = start;
rewrite;
apply extensionality to predicate \{start\} = \dom~ links \setminus  \ran~  links;
rewrite;
\end{forget}

\begin{forget}[lChainMidElemEverywhere]
use lChainElemNonEmptyLinks;
rearrange;
simplify;
use lChainElemInDom;
use lNonEmptyLinksStartNotNull;
use lNonEmptyLinksEndNotNull;
rearrange;
simplify;
invoke Chain;
invoke GPID;
rearrange;
rewrite;
instantiate e == p?;
rearrange;
rewrite;
split
       p? \in \dom~links \\
  \lor p? \in \ran~ links;
simplify;
rearrange;
use lTransitiveClosureConnectsRan[\num][R := links, x := start, y := p?];
rearrange;
rewrite;
apply extensionality to predicate \{ end \} = \ran~ links \setminus \dom~links;
rewrite;
instantiate y == p?;
rearrange;
rewrite;
\end{forget}


\sectionproof{Chain operations}{chain-operations}

\begin{forget}[PopMultiple\_AtLeastTwoLinks\$domainCheck]
use lNonEmptyLinksStartLinked;
prove by rewrite;
\end{forget}

\begin{forget}[PopMultiple\_TooFewElements\$domainCheck]
use lNonEmptyLinksStartLinked;
prove by rewrite;
\end{forget}

\begin{forget}[DeleteMiddle\$domainCheck]
use lChainMidElemEverywhere;
rearrange;
rewrite;
\end{forget}
\begin{forget}[lLinksPushUpdateIsPInj]
use lNonEmptyLinksEndNotInDom;
rearrange;
simplify;
split links = \{\};
cases;
invoke Chain;
prove by rewrite;
next;
simplify;
invoke Chain;
rearrange;
rewrite;
apply cupInPinj;
invoke GPID;
prove by rewrite;
split start = nullpid;
prove by rewrite;
next;
\end{forget}

\begin{forget}[lLinksDomElemType]
invoke (\_\pinj \_);
invoke (\_\pfun \_);
invoke (\_\rel \_);
prove by rewrite;
apply inPower;
instantiate e == (x, y);
prove by rewrite;
\end{forget}

\begin{forget}[lLinksRanElemType]
invoke (\_\pinj \_);
invoke (\_\pfun \_);
invoke (\_\rel \_);
prove by rewrite;
apply inPower;
instantiate e == (x, y);
prove by rewrite;
\end{forget}

\begin{forget}[lLinksElemType]
invoke (\_\pinj \_);
invoke (\_\pfun \_);
invoke (\_\rel \_);
prove by rewrite;
\end{forget}

\begin{forget}[lChainStartLeadsToValidPID]
use lNonEmptyLinksStartLinked;
use lNonEmptyLinksStartNotNull;
rearrange;
rewrite;
apply inDom;
prenex;
use pairInFunction[\num, \num][f := links, x := start, y := y];
rearrange;
rewrite;
rearrange;
rewrite;
use lLinksRanElemType[x := start];
rearrange;
rewrite;
\end{forget}

\begin{forget}[lTransClosureOneStepForwardChainTraversal]
use lNotImmediateMemberPFun[X, X][f := f, x := s, y := e];
rearrange;
rewrite;
apply lTransitiveClosureEquivalence to expression f \plus [X];
rewrite;
apply inDom to predicate s \in  \dom~[X, X] f;
prenex;
rewrite;
prenex;
equality substitute;
apply lIterPositive to expression iter[X] i f;
rewrite;
split i = 1;
rewrite;
prenex;
instantiate B\_\_0 == iter[X] (- 1 + i) f;
rewrite;
instantiate i\_\_0 == - 1 + i;
rewrite;
use pairInFunction[X, X][f := f, x := s, y := y];
rearrange;
rewrite;
invoke (\_\pfun \_);
rewrite;
instantiate x == s, y1 == y, y2 == y\_\_0;
rearrange;
rewrite;
\end{forget}

\begin{forget}[lTransitiveClosureChainHeadExtract]
use lTransClosureOneStepForwardChainTraversal[X];
use lHeadExtractNDresDistTransitiveClosure[X][s := s, R := f];
rearrange;
rewrite;
equality substitute (\{s\} \ndres [X, X] f) \plus [X];
rewrite;
apply inRanFunction;
rewrite;
instantiate x == s;
rewrite;
\end{forget}

\begin{forget}[lNonEmptyLinksSingleton]
use lNonEmptyLinksStartNotNull;
use lNonEmptyLinksEndNotNull;
rearrange;
simplify;
invoke Chain;
rearrange;
rewrite;
split links = \{\};
rewrite;
apply extensionality to predicate links = \{(start, end)\};
prenex;
rearrange;
rewrite;
use lLinksElemType;
rearrange;
apply inCross2 to predicate x \in  PID \cross  PID;
prenex;
rewrite;
equality substitute x;
rewrite;
invoke GPID;
rewrite;
rearrange;
rewrite;
instantiate e == y;
rearrange;
rewrite;
equality substitute set;
rewrite;
with normalization rewrite;
cases;
rearrange;
apply extensionality to predicate \{start\} = \dom~ links \setminus  \ran~  links;
rewrite;
apply inRan to predicate start \in  \ran~  links;
instantiate x\_\_1 == x;
rewrite;
next;
cases;
next;
cases;
apply extensionality to predicate \{end\} = \ran~  links \setminus  \dom~ links;
instantiate y\_\_0 == y;
rearrange;
rewrite;
invoke (\_\pinj \_);
invoke (\_\pfun \_);
rewrite;
rewrite;
instantiate x\_\_2 == end, y1\_\_0 == x, y2\_\_0 == start;
rearrange;
rewrite;
next;
apply inRan to predicate y \in  \ran~  links;
instantiate x\_\_1 == x;
rewrite;
next;
use lTransClosureOneStepForwardChainTraversal[\num ][f := links, s := start, e := y];
rearrange;
rewrite;
apply extensionality to predicate \{start\} = \dom~ links \setminus  \ran~  links;
rewrite;
use pairInFunction[\num , \num ][f := links, x := start, y := end];
rearrange;
rewrite;
equality substitute x\_\_0;
equality substitute links start;
split end = y;
rewrite;
cases;
invoke (\_\pinj \_);
invoke (\_\pfun \_);
rewrite;
rewrite;
instantiate x\_\_2 == y, y1\_\_0 == x, y2\_\_0 == start;
rearrange;
rewrite;
next;
rearrange;
apply extensionality to predicate \{end\} = \ran~  links \setminus  \dom~ links;
rewrite;
instantiate y\_\_0 == x;
rewrite;
rearrange;
apply inDom to predicate x \in  \dom~ links;
rewrite;
instantiate y\_\_2 == y;
rewrite;
split x = start;
rewrite;
cases;
invoke (\_\pinj \_);
invoke (\_\pfun \_);
rewrite;
rewrite;
instantiate x\_\_1 == start, y1 == y, y2 == end;
rearrange;
rewrite;
next;
instantiate e\_\_0 == x;
instantiate e == end;
rearrange;
rewrite;
use lTransitiveClosureConnectsDom[\num ][R := links, x := end, y := y];
rearrange;
rewrite;
next;
\end{forget}

\begin{LPScript}\begin{forget}[lHomogeneousPInjMidPointExtractNotInRan]
use lPInjPairIsRanPoint[X, X][A := X, B := X, x := p?];
use lPairInvInPInj[X, X][A := X, B := X, y := p?];
rearrange;
rewrite;
rearrange;
apply oplusDef to expression \{p?\} \ndres [X, X] f \oplus [X, X] \{(x, y)\};
rewrite;
apply inRanFunction to predicate p? \in  \ran~ [X, X] ((\{p?\} \cup [X] \{x\}) \ndres [X, X] f);
prenex;
rewrite;
rearrange;
split \lnot  x\_\_0 = x;
simplify;
split \lnot  x\_\_0 = p?;
simplify;
split p? = f x\_\_0;
simplify;
rearrange;
use pairInFunction[X, X][y := p?];
rearrange;
rewrite;
use pinjApplicationsEqual[X, X][A := X, B := X, y := x\_\_0];
rearrange;
rewrite;
apply inDom to predicate x \in  \dom~[X, X] f;
instantiate y\_\_0 == p?;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lHomogeneousMidPointExtractRanEquiv]
use lPInjPointIsNotShared[X, X][x1 := p?, x2 := x];
rearrange;
rewrite;
apply inDom to predicate p? \in  \dom~[X, X] f;
instantiate y\_\_0 == y;
rewrite;
use pairInFunction[X, X][x := p?];
rearrange;
rewrite;
rearrange;
equality substitute f p?;
apply extensionality to predicate \{p?\} \cup [X] \ran~ [X, X] (\{p?\} \ndres [X, X] f \oplus [X, X] \{(x, y)\}) = \{p?\} \cup [X] (\{y\} \cup [X] \ran~ [X, X] f);
prenex;
rewrite;
rearrange;
rewrite;
cases;
apply inRan;
apply oplusDef to expression \{p?\} \ndres [X, X] f \oplus [X, X] \{(x, y)\};
prenex;
rewrite;
instantiate x\_\_2 == x\_\_1;
rewrite;
next;
split y\_\_0 = y;
cases;
equality substitute y\_\_0;
apply inRan to predicate y \in  \ran~ [X, X] (\{p?\} \ndres [X, X] f \oplus [X, X] \{(x, y)\});
apply oplusDef to expression \{p?\} \ndres [X, X] f \oplus [X, X] \{(x, y)\};
rewrite;
instantiate x\_\_0 == x;
rewrite;
next;
simplify;
apply oplusDef to expression \{p?\} \ndres [X, X] f \oplus [X, X] \{(x, y)\};
rewrite;
apply inRanFunction to predicate y\_\_0 \in  \ran~ [X, X] f;
apply inRanFunction to predicate y\_\_0 \in  \ran~ [X, X] ((\{p?\} \cup [X] \{x\}) \ndres [X, X] f);
rewrite;
prenex;
instantiate x\_\_1 == x\_\_0;
rewrite;
rearrange;
equality substitute x\_\_0;
use pairInFunction[X, X][y := p?];
rearrange;
rewrite;
next;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[lHomogeneousMidPointExchangeRanEquiv]
apply oplusDef;
with disabled (ranCup) rewrite;
with disabled (ranSingleton) rewrite;
apply distributeDiffOverCupLeft;
with disabled (unitDiff) rewrite;
\end{forget}\end{LPScript}\sectionproof{Chain operations preconditions}{chain-operations-pre}
\begin{forget}[PopMultiple\_AtLeastTwoLinksSig\$domainCheck]
use lNonEmptyLinksStartLinked;
prove by rewrite;
\end{forget}

\begin{forget}[Pop0Sig\$domainCheck]
use lNonEmptyLinksStartLinked;
prove by rewrite;
\end{forget}

\begin{forget}[PopMultiple\_TooFewElementsSig\$domainCheck]
use lNonEmptyLinksStartLinked;
prove by rewrite;
\end{forget}

\begin{forget}[tPREChainInit]
invoke ChainInit;
rewrite;
instantiate set' == \{\}, links' == \{\};
invoke Chain;
rewrite;
\end{forget}

\begin{forget}[tPREPushEmpty]
invoke PushEmpty;
invoke PushEmptySig;
invoke \Delta Chain;
prove by rewrite;
invoke Chain;
invoke GPID;
prove by rewrite;
split links = \{\};
prove by rewrite;
apply extensionality to predicate \{nullpid\} = \ran~  links \setminus  \dom~ links;
rewrite;
apply lChainLinksHasNoNullPidInRan;
rewrite;
\end{forget}

\begin{forget}[tPREPushNonEmpty]
use lLinksPushUpdateIsPInj;
rearrange;
simplify;
rewrite;
invoke PushNonEmpty;
invoke PushNonEmptySig;
invoke \Delta Chain;
prove by rewrite;
split links = \{\};
prove by rewrite;
cases;
invoke Chain;
invoke GPID;
prove by rewrite;
equality substitute p?;
apply lUnitTransitiveClosure;
rewrite;
next;
use lNonEmptyLinksStartLinked;
use lNonEmptyLinksStartNotNull;
use lNonEmptyLinksStartNotInRan;
use lNonEmptyLinksEndNotInDom;
use lNonEmptyLinksEndNotNull;
use lNonEmptyLinksEndLinked;
rearrange;
simplify;
invoke Chain;
invoke GPID;
prove by rewrite;
split start = nullpid;
cases;
equality substitute;
apply extensionality to predicate
  \{ nullpid \} = \dom~links \setminus \ran~ links;
rewrite;
apply lChainLinksHasNoNullPidInDom;
rewrite;
next;
prove by rewrite;
split \{ start \} = \dom~links \setminus \ran~ links;
rewrite;
split \{ end \} = \ran~ links \setminus \dom~links;
rewrite;
equality substitute \ran~ links \setminus \dom~links;
rewrite;
rearrange;
apply distributeDiffOverCupRight;
rewrite;
equality substitute \dom~links \setminus \ran~ links;
rewrite;
equality substitute \ran~ links \setminus \dom~links;
rewrite;
rearrange;
prenex;
equality substitute \{ start \} \cup (\dom~links \cup \ran~ links);
instantiate e\_\_0 == e;
rearrange;
rewrite;
apply inCup to predicate e \in \{ end \} \cup (\{ p? \} \cup set);
rearrange;
rewrite;
apply cupSubset to predicate \{ p? \} \cup set \in \power \num;
rewrite;
split set \in \power \num;
rewrite;
cases;
split e \in set;
rewrite;
cases;
apply lUnionTransitiveClosure to predicate
  (start, e) \in (links \cup \{(end, p?)\}) \plus;
rewrite;
next;
prove by rewrite;
equality substitute p?;
apply lUnionTransitiveClosure to predicate
  (start, e) \in (links \cup \{(end, e)\}) \plus;
rewrite;
apply lUnionSingletonTransitiveClosure to predicate
  (start, e) \in (links \cup \{(end, e)\}) \plus;
rewrite;
apply lInTransitiveClosure to predicate (start, e) \in links \plus;
rewrite;
apply lInTransitiveClosure to predicate (start, end) \in links \plus;
rewrite;
instantiate e\_\_0 == end;
rewrite;
split (start, end) \in links \plus;
rewrite;
next;
prove by rewrite;
next;
\end{forget}


\begin{forget}[tPREPush0]
invoke Push0Sig;
invoke Push0;
split end = nullpid;
cases;
use tPREPushEmpty;
invoke PushEmptySig;
prenex;
rearrange;
simplify;
invoke PushEmpty;
invoke PushNonEmpty;
invoke \Delta Chain;
rewrite;
rearrange;
rewrite;
instantiate set\_\_0' == set', start\_\_0' == start';
rewrite;
next;
use tPREPushNonEmpty;
invoke PushNonEmptySig;
prenex;
rearrange;
rewrite;
invoke PushEmpty;
invoke PushNonEmpty;
invoke \Delta Chain;
rewrite;
rearrange;
rewrite;
instantiate end\_\_0' == end', set\_\_0' == set', start\_\_0' == start';
rewrite;
next;
\end{forget}

\begin{forget}[tPREPushKnownElementError]
invoke PushKnownElementError;
invoke PushKnownElementErrorSig;
invoke \Xi Chain;
rewrite;
\end{forget}


\begin{forget}[tPREPushIsTotal]
invoke Push;
invoke PushSig;
split p? \notin  set;
cases;
use tPREPush0;
invoke Push0Sig;
invoke ChainSuccess;
rearrange;
prenex;
rewrite;
instantiate end\_\_0' == end',
    links\_\_0' == links',
    msg! == chain\_ok,
    set\_\_0' == set',
    start\_\_0' == start';
rewrite;
next;
use tPREPushKnownElementError;
invoke PushKnownElementErrorSig;
rearrange;
prenex;
rewrite;
instantiate end\_\_0' == end',
    links\_\_0' == links',
    msg\_\_0! == msg!,
    set\_\_0' == set',
    start\_\_0' == start';
rewrite;
next;
\end{forget}

\begin{forget}[tPREPopSingleton]
invoke PopSingleton;
invoke PopSingletonSig;
invoke \Delta Chain;
prove by rewrite;
invoke Chain;
invoke GPID;
prove by rewrite;
\end{forget}

\begin{forget}[tPREPopMultiple\_AtLeastTwoLinks]
invoke PopMultiple\_AtLeastTwoLinks;
invoke PopMultiple\_AtLeastTwoLinksSig;
invoke \Delta Chain;
prove by rewrite;
use lNonEmptyLinksStartNotNull;
use lNonEmptyLinksStartNotInRan;
use lNonEmptyLinksStartLinked;
use lNonEmptyLinksEndNotNull;
use lNonEmptyLinksEndNotInDom;
use lNonEmptyLinksEndLinked;
rearrange;
simplify;
apply inDom to predicate start \in \dom~links;
prenex;
with predicate (links \in \num \rel \num) rewrite;
use lNonEmptyLinksStartLinked;
rearrange;
simplify;
invoke Chain;
invoke GPID;
prove by rewrite;
equality substitute \dom~links \setminus \ran~ links;
use pairInFunction[\num, \num][x := start, y := y, f := links];
rearrange;
rewrite;
apply lHomogeneousElemRanNDresPInj;
rewrite;
equality substitute links start;
use lLinksDomElemType[links := links, x := start, y := y];
use lLinksRanElemType[links := links, x := start, y := y];
use
  lPInjPairIsRanPoint[\num, \num][A := PID, B := PID, f := links, x := start,
                                  y := y];
rearrange;
simplify;
rearrange;
apply distributeDiffOverCupRight;
rewrite;
apply lRightDiffLeftDistribute to expression
  \dom~links \setminus (\ran~ links \setminus \{ y \});
apply lRightDiffLeftDistribute to expression
  \ran~ links \setminus (\dom~links \setminus \{ start \});
rewrite;
equality substitute \dom~links \setminus \ran~ links;
equality substitute \ran~ links \setminus \dom~links;
rewrite;
apply cupPermutes to expression
  \{ y \}
  \cup (\dom~links \setminus \{ start \} \cup (\ran~ links \setminus \{ y \}));
with predicate
  (      \{ y \} \in \power \num \\
   \land \dom~links \setminus \{ start \} \in \power \num \\
   \land \ran~ links \setminus \{ y \} \in \power \num) rewrite;
apply lElemUnionAbsorbDiffRight to expression
  \{ y \} \cup (\ran~ links \setminus \{ y \});
rewrite;
split \{ start \} \ndres links = \{\};
cases;
rewrite;
prenex;
rewrite;
split
        e \in \dom~links \\
  \land \lnot e = start;
rewrite;
cases;
apply inDom to predicate e \in \dom~links;
rearrange;
prenex;
rewrite;
apply extensionality to predicate \{ start \} \ndres links = \{\};
rewrite;
instantiate x == (e, y\_\_0);
rewrite;
next;
apply inRan to predicate e \in \ran~ links;
prenex;
rewrite;
use lLinksRanElemType[y := e];
rearrange;
simplify;
apply extensionality to predicate \{ start \} \ndres links = \{\};
rearrange;
rewrite;
invoke (\_ \pinj \_);
invoke (\_ \pfun \_);
rewrite;
rewrite;
instantiate x\_\_2 == (x, e);
rearrange;
rewrite;
instantiate x\_\_0 == start, y1 == e, y2 == y;
rearrange;
rewrite;
next;
rewrite;
prenex;
rearrange;
rewrite;
instantiate e\_\_0 == e;
rearrange;
rewrite;
use lTransitiveClosureConnectsRan[\num][R := links, x := start, y := e];
rearrange;
rewrite;
use lTransitiveClosureElemType[\num][R := links, x := (start, e)];
rearrange;
rewrite;
use lTransitiveClosureChainHeadExtract[\num][f := links, s := start, e := e];
rearrange;
rewrite;
next;
\end{forget}

\begin{forget}[tPREPop0]
split links = \emptyset;
cases;
use tPREPopSingleton;
invoke Pop0Sig;
invoke Pop0;
invoke PopSingletonSig;
rearrange;
rewrite;
rearrange;
prenex;
rewrite;
invoke PopMultiple\_AtLeastTwoLinks;
invoke PopSingleton;
rewrite;
invoke \Delta Chain;
rewrite;
invoke Chain;
rewrite;
next;
invoke Pop0Sig;
invoke Pop0;
use tPREPopMultiple\_AtLeastTwoLinks;
rearrange;
invoke PopMultiple\_AtLeastTwoLinksSig;
invoke PopSingleton;
rewrite;
next;
\end{forget}

\begin{forget}[tPREPopEmpty]
invoke PopEmpty;
invoke \Xi Chain;
invoke PopEmptySig;
rewrite;
\end{forget}

\begin{forget}[tPREPopMultiple\_TooFewElements]
invoke PopMultiple\_TooFewElements;
invoke PopMultiple\_TooFewElementsSig;
invoke \Xi Chain;
rewrite;
\end{forget}

\begin{forget}[tPREPopSinglegonComplete]
invoke PopSingletonComplete;
invoke PopSingletonCompleteSig;
split start = nullpid;
cases;
use tPREPopEmpty;
invoke PopEmptySig;
rearrange;
prenex;
invoke PopEmpty;
rewrite;
instantiate end\_\_0' == end', links\_\_0' == links', p! == nullpid, set\_\_0' == set', start\_\_0' == start', msg\_\_0! == pop\_empty\_error;
rewrite;
next;
use tPREPopSingleton;
prenex;
invoke PopSingletonSig;
rearrange;
rewrite;
instantiate end\_\_0' == end', links\_\_0' == links', p\_\_0! == start, set\_\_0' == set', start\_\_0' == start', msg! == chain\_ok;
rewrite;
invoke PopSingleton;
invoke ChainSuccess;
rewrite;
next;
\end{forget}

\begin{forget}[tPREPopMultipleComplete]
invoke PopMultipleComplete;
invoke PopMultipleCompleteSig;
split links start \in  \dom~ links;
cases;
use tPREPopMultiple\_AtLeastTwoLinks;
rearrange;
invoke PopMultiple\_AtLeastTwoLinksSig;
prenex;
rewrite;
invoke PopMultiple\_AtLeastTwoLinks;
invoke ChainSuccess;
instantiate end\_\_0' == end', links\_\_0' == links', msg! == chain\_ok, p\_\_0! == start, set\_\_0' == set', start\_\_0' == start';
rewrite;
next;
use tPREPopMultiple\_TooFewElements;
rearrange;
invoke PopMultiple\_TooFewElementsSig;
prenex;
rewrite;
split links start \in  \num ;
cases;
rewrite;
instantiate end\_\_0' == end', links\_\_0' == links', msg\_\_0! == pop\_multiple\_error, p! == nullpid, set\_\_0' == set', start\_\_0' == start';
rewrite;
invoke PopMultiple\_TooFewElements;
rewrite;
next;
rewrite;
use lNonEmptyLinksStartLinked;
rearrange;
simplify;
rearrange;
apply inDom to predicate start \in  \dom~ links;
prenex;
rewrite;
use pairInFunction[\num , \num ][f := links, x := start];
rearrange;
rewrite;
next;
\end{forget}

\begin{forget}[tPREPopCompleteIsTotal]
invoke PopComplete;
invoke PopCompleteSig;
split links = \emptyset;
cases;
use tPREPopSinglegonComplete;
invoke PopSingletonCompleteSig;
rearrange;
prenex;
rewrite;
split start = nullpid;
cases;
instantiate end\_\_0' == end', links\_\_0' == links', p\_\_0! == nullpid, set\_\_0' == set', start\_\_0' == start', msg\_\_0! == pop\_empty\_error;
rewrite;
invoke PopSingletonComplete;
invoke PopEmpty;
invoke PopSingleton;
rewrite;
next;
simplify;
instantiate end\_\_0' == end', links\_\_0' == links', p\_\_0! == start, set\_\_0' == set', start\_\_0' == start', msg\_\_0! == chain\_ok;
rewrite;
invoke PopSingletonComplete;
invoke PopSingleton;
invoke PopEmpty;
invoke ChainSuccess;
rewrite;
next;
use tPREPopMultipleComplete;
rearrange;
invoke PopMultipleCompleteSig;
prenex;
rewrite;
use lNonEmptyLinksStartLinked;
rearrange;
simplify;
rearrange;
invoke PopSingletonComplete;
invoke PopSingleton;
invoke PopEmpty;
rewrite;
split \lnot  links = \{\};
rewrite;
invoke PopMultipleComplete;
split PopMultiple\_TooFewElements;
rewrite;
cases;
instantiate end\_\_0' == end', links\_\_0' == links', msg\_\_0! == pop\_multiple\_error, set\_\_0' == set', start\_\_0' == start', p\_\_0! == p!;
rewrite;
invoke PopMultiple\_TooFewElements;
rewrite;
next;
rearrange;
simplify;
instantiate end\_\_0' == end', links\_\_0' == links', msg\_\_0! == chain\_ok, set\_\_0' == set', start\_\_0' == start', p\_\_0! == p!;
rearrange;
rewrite;
invoke ChainSuccess;
rewrite;
next;
\end{forget}

\begin{forget}[tPREPop0Okay]
use tPREPop0;
rearrange;
prenex;
instantiate end\_\_0' == end', links\_\_0' == links', msg! == chain\_ok, set\_\_0' == set', start\_\_0' == start', p\_\_0! == p!;
invoke Pop0Okay;
invoke ChainSuccess;
rewrite;
\end{forget}

\begin{forget}[tPREPopErr]
invoke PopErrSig;
invoke PopErr;
split PopEmptySig;
cases;
use tPREPopEmpty;
rearrange;
prenex;
instantiate end\_\_0' == end', links\_\_0' == links', set\_\_0' == set', start\_\_0' == start', msg\_\_0! == pop\_empty\_error;
invoke PopEmpty;
rewrite;
next;
use tPREPopMultiple\_TooFewElements;
rearrange;
prenex;
instantiate end\_\_0' == end', links\_\_0' == links', set\_\_0' == set', start\_\_0' == start', msg\_\_0! == pop\_multiple\_error;
rearrange;
rewrite;
rearrange;
invoke PopMultiple\_TooFewElements;
rewrite;
next;
\end{forget}

\begin{forget}[tPREPopIsTotal]
invoke Pop;
invoke PopSig;
split Pop0Sig;
cases;
use tPREPop0Okay;
rearrange;
prenex;
instantiate end\_\_0' == end', links\_\_0' == links', set\_\_0' == set', start\_\_0' == start', msg\_\_0! == msg!, p\_\_0! == p!;
rewrite;
next;
split PopErrSig;
cases;
use tPREPopErr;
rearrange;
prenex;
instantiate end\_\_0' == end', links\_\_0' == links', set\_\_0' == set', start\_\_0' == start', msg\_\_0! == msg!, p! == 1;
rewrite;
next;
invoke Pop0Sig;
rearrange;
invoke PopErrSig;
invoke PopMultiple\_TooFewElementsSig;
invoke PopEmptySig;
rewrite;
rearrange;
rewrite;
use lNonEmptyLinksStartLinked;
rearrange;
rewrite;
apply inDom to predicate start \in  \dom~ links;
prenex;
rewrite;
use pairInFunction[\num , \num ][f := links, x := start, y := y];
rearrange;
rewrite;
next;
\end{forget}

\begin{forget}[tPREDeleteStart]
invoke DeleteStart;
invoke DeleteStartSig;
invoke \Delta Chain;
rewrite;
use tPREPopCompleteIsTotal;
invoke PopCompleteSig;
prenex;
rearrange;
rewrite;
instantiate end\_\_0' == end', links\_\_0' == links', msg\_\_0! == msg!, set\_\_0' == set', start\_\_0' == start';
rewrite;
invoke PopComplete;
split PopMultipleComplete;
simplify;
cases;
next;
invoke PopSingletonComplete;
split PopEmpty;
simplify;
cases;
instantiate p\_\_0! == p?;
rewrite;
next;
invoke PopSingleton;
instantiate p\_\_0! == p!;
rewrite;
next;
invoke PopMultipleComplete;
split PopMultiple\_TooFewElements;
simplify;
cases;
instantiate p\_\_0! == p?;
rewrite;
next;
invoke PopMultiple\_AtLeastTwoLinks;
instantiate p\_\_0! == p!;
rewrite;
next;
\end{forget}

\begin{LPScript}\begin{forget}[tPREDeleteEnd]
invoke DeleteEnd;
invoke DeleteEndSig;
invoke \Delta Chain;
invoke ChainSuccess;
rewrite;
split links = \{\};
cases;
rewrite;
invoke Chain;
rewrite;
next;
use lNonEmptyLinksEndNotNull;
use lNonEmptyLinksStartNotNull;
use lNonEmptyLinksStartLinked;
use lNonEmptyLinksEndLinked;
use lNonEmptyLinksStartNotInRan;
use lNonEmptyLinksEndNotInDom;
rearrange;
simplify;
apply inRan to predicate end \in  \ran~  links;
prenex;
with predicate (links \in  \num  \rel  \num ) rewrite;
use lNonEmptyLinksEndLinked;
rearrange;
simplify;
invoke Chain;
invoke GPID;
rearrange;
split \lnot  start = nullpid;
simplify;
split \lnot  end = nullpid;
rewrite;
rearrange;
rewrite;
apply lRightDiffLeftDistribute;
rewrite;
split links \nrres  \{end\} = \{\};
rewrite;
cases;
rearrange;
equality substitute;
rewrite;
apply lRightDiffLeftDistribute to expression \ran~  links \setminus  (\ran~  links \setminus  \dom~ links);
rewrite;
apply diffSuperset to expression \ran~  links \setminus  \ran~  links;
rewrite;
apply extensionality to predicate links \nrres  \{end\} = \{\};
rewrite;
rewrite;
instantiate end' == end;
prenex;
rewrite;
apply inRan to predicate e \in  \ran~  links;
prenex;
rewrite;
instantiate x\_\_1 == (x\_\_0, e);
rewrite;
next;
use lLinksDomElemType[x := x, y := end];
rearrange;
rewrite;
use lPInjPairIsRanPoint[\num , \num ][A := PID, B := PID, f := links, x := x, y := end];
rearrange;
rewrite;
apply lHomogeneousElemDomNRresPInj;
rewrite;
apply distributeDiffOverCupRight to expression \dom~ links \setminus  (\ran~  links \cup  \{links \inv  end\});
rewrite;
equality substitute \dom~ links \setminus  \ran~  links;
rewrite;
equality substitute links \inv  end;
apply distributeDiffOverCupRight to expression \ran~  links \setminus  (\{end\} \cup  (\dom~ links \setminus  \{x\}));
rewrite;
equality substitute \{end\};
apply lRightDiffLeftDistribute to expression \ran~  links \setminus  (\ran~  links \setminus  \dom~ links);
rewrite;
apply diffSuperset to expression \ran~  links \setminus  \ran~  links;
rewrite;
apply capSubsetRight to expression \ran~  links \cap  (\ran~  links \setminus  (\dom~ links \setminus  \{x\}));
rewrite;
apply lRightDiffLeftDistribute to expression \ran~  links \setminus  (\dom~ links \setminus  \{x\});
rewrite;
equality substitute \ran~  links \setminus  \dom~ links;
apply capUnit to expression \dom~ links \cap  \{end\};
rewrite;
cases;
prove by rewrite;
next;
prove by rewrite;
next;
next;
use lNonEmptyLinksSingleton;
invoke Chain;
invoke GPID;
rearrange;
rewrite;
instantiate e == x;
prove by rewrite;
split links \inv  end = start;
cases;
next;
simplify;
use lTransitiveClosureConnectsRan[\num ][R := links, x := start, y := links \inv  end];
rearrange;
rewrite;
next;
equality substitute links \inv  end;
with predicate ((start, end) \in  links) simplify;
rearrange;
equality substitute links;
rewrite;
next;
use lHomogeneousElemDomNRresPInj[\num ][f := links, y := end];
rearrange;
apply lLastExtractNRresDistTransitiveClosure to expression (links \nrres  \{end\}) \plus ;
rewrite;
prenex;
apply distributeCupOverCapRight to expression \dom~ links \setminus  \{x\} \cup  \dom~ links \cap  \ran~  links;
with predicate (\dom~ links \setminus  \{x\} \in  \power  \num  \land  \dom~ links \in  \power  \num  \land  \ran~  links \in  \power  \num ) rewrite;
apply cupSubsetLeft to expression \dom~ links \setminus  \{x\} \cup  \dom~ links;
with predicate (\dom~ links \setminus  \{x\} \subseteq  \dom~ links) rewrite;
apply distributeCapOverCupRight to expression \dom~ links \cap  (\dom~ links \setminus  \{x\} \cup  \ran~  links);
with predicate (\dom~ links \in  \power  \num  \land  \dom~ links \setminus  \{x\} \in  \power  \num  \land  \ran~  links \in  \power  \num ) rewrite;
apply capSubsetRight to expression \dom~ links \cap  (\dom~ links \setminus  \{x\});
with predicate (\dom~ links \setminus  \{x\} \subseteq  \dom~ links) rewrite;
equality substitute x;
equality substitute \dom~ links \setminus  \{links \inv  end\};
apply cupPermutes to expression \{start\} \cup  (\dom~ (links \nrres  \{end\}) \cup  \dom~ links \cap  \ran~  links);
with predicate (\{start\} \in  \power  \num  \land  \dom~ (links \nrres  \{end\}) \in  \power  \num  \land  \dom~ links \cap  \ran~  links \in  \power  \num ) rewrite;
equality substitute \{start\};
apply distributeCupOverCapRight to expression \dom~ links \setminus  \ran~  links \cup  \dom~ links \cap  \ran~  links;
with predicate (\dom~ links \setminus  \ran~  links \in  \power  \num  \land  \dom~ links \in  \power  \num  \land  \ran~  links \in  \power  \num ) rewrite;
apply cupSubsetLeft to expression \dom~ links \setminus  \ran~  links \cup  \dom~ links;
with predicate (\dom~ links \setminus  \ran~  links \subseteq  \dom~ links) rewrite;
apply distributeCupOverCapRight to expression \dom~ (links \nrres  \{end\}) \cup  \dom~ links \cap  (\dom~ links \setminus  \ran~  links \cup  \ran~  links);
with predicate (\dom~ (links \nrres  \{end\}) \in  \power  \num  \land  \dom~ links \in  \power  \num  \land  \dom~ links \setminus  \ran~  links \cup  \ran~  links \in  \power  \num ) rewrite;
apply cupSubsetLeft to expression \dom~ (links \nrres  \{end\}) \cup  \dom~ links;
with predicate (\dom~ (links \nrres  \{end\}) \subseteq  \dom~ links) rewrite;
apply domSubset to predicate \dom~ (links \nrres  \{end\}) \in  \power  (\dom~ links);
apply nrres\_result to predicate links \nrres  \{end\} \in  \power  links;
with predicate (links \in  \num  \rel  \num  \land  (\{end\} \in  \power  \num  \land  links \in  \num  \rel  \num  \land  \power  links \in  \power  (\power  links) \lor  links \nrres  \{end\} \in  \power  links)) rewrite;
apply cupPermutes to expression \dom~ (links \nrres  \{end\}) \cup  (\dom~ links \setminus  \ran~  links \cup  \ran~  links);
with predicate (\dom~ (links \nrres  \{end\}) \in  \power  \num  \land  \dom~ links \setminus  \ran~  links \in  \power  \num  \land  \ran~  links \in  \power  \num ) rewrite;
equality substitute \dom~ links \setminus  \ran~  links;
split \lnot  e = start;
simplify;
rewrite;
rearrange;
instantiate e\_\_0 == e;
rearrange;
equality substitute set;
rewrite;
next;
\end{forget}\end{LPScript}

\begin{forget}[lDeleteTransitiveClosureLinksUpdateLemma]
apply lPInjWeakening to predicate \{p?\} \ndres  links \oplus  \{(x, y)\} \in  PID \pinj  PID;
apply lPInjWeakeningFresh to predicate links \in  PID \pinj  PID;
rewrite;
prenex;
apply lNDresUnitOplusUnitAssociates to expression \{p?\} \ndres  links \oplus  \{(x, y)\};
rewrite;
apply oplusDef to expression links \oplus  \{(x, y)\};
rewrite;
rearrange;
with normalization rewrite;
cases;
instantiate rf == r, df1 == d2, df2 == p?;
rearrange;
rewrite;
next;
cases;
instantiate rf == r, df1 == d1, df2 == p?;
rearrange;
rewrite;
next;
instantiate rf == r, df1 == d1, df2 == d2;
rearrange;
rewrite;
next;
\end{forget}

\begin{LPScript}\begin{forget}[lEndEquivalenceLemma]
invoke DeleteMiddleSig;
use lChainMidElemEverywhere;
rearrange;
rewrite;
use lNonEmptyLinksEndLinked;
use lNonEmptyLinksEndNotNull;
use lNonEmptyLinksEndNotInDom;
use lNonEmptyLinksStartNotNull;
rearrange;
simplify;
invoke Chain;
invoke GPID;
rearrange;
split \lnot  end = nullpid;
rewrite;
apply oplusDef to expression \{p?\} \ndres links \oplus \{(x, y)\} ;
rewrite;
apply extensionality to predicate \{end\} = \{y\} \cup  \ran~  ((\{p?\} \cup  \{x\}) \ndres  links) \setminus  \dom~ links;
prenex;
rewrite;
cases;
equality substitute x\_\_0;
apply inRan to predicate end \in  \ran~  ((\{p?\} \cup  \{x\}) \ndres  links);
apply inRan to predicate end \in  \ran~  links;
prenex;
rewrite;
instantiate x\_\_2 == x\_\_1;
rewrite;
split x\_\_0 = p?;
rewrite;
cases;
equality substitute x\_\_0;
apply lPInjWeakening to predicate links \in  PID \pinj  PID;
apply lPFunWeakening to predicate links \in  PID \pfun  PID;
instantiate d == p?, r1 == end, r2 == y;
rearrange;
rewrite;
next;
rearrange;
equality substitute x\_\_0;
apply lPInjWeakening to predicate links \in  PID \pinj  PID;
apply lPFunWeakening to predicate links \in  PID \pfun  PID;
instantiate d == x, r1 == end, r2 == p?;
rearrange;
rewrite;
next;
rearrange;
apply extensionality to predicate \{end\} = \ran~  links \setminus  \dom~ links;
rewrite;
split y\_\_0 = y;
rewrite;
cases;
equality substitute y\_\_0;
instantiate y\_\_1 == y;
rearrange;
rewrite;
next;
simplify;
apply inRan to predicate y\_\_0 \in  \ran~  ((\{p?\} \cup  \{x\}) \ndres  links);
prenex;
rewrite;
instantiate y\_\_1 == y\_\_0;
rearrange;
rewrite;
apply inRan to predicate y \in  \ran~  links;
instantiate x\_\_1 == x\_\_0;
rewrite;
next;
\end{forget}\end{LPScript}

\begin{forget}[ChainMidPoint\$domainCheck]
rewrite;
\end{forget}

\begin{forget}[lChainLinks]
invoke Chain;
simplify;
\end{forget}

\begin{forget}[lChainMidPointLinksMidPointEquiv]
apply extensionality;
prenex;
rewrite;
cases;
next;
invoke ChainMidPoint;
split y\_\_0 = (p?, y);
rewrite;
next;
use lLinksElemType[x := x\_\_0];
rearrange;
apply inCross2;
prenex;
simplify;
rearrange;
equality substitute;
invoke ChainMidPoint;
rewrite;
with normalization rewrite;
invoke Chain;
apply lPInjWeakening to predicate links \in  PID \pinj  PID;
apply lPFunWeakening to predicate links \in  PID \pfun  PID;
cases;
instantiate d == p?, r1 == y, r2 == y\_\_0;
rearrange;
rewrite;
next;
instantiate d == x, r1 == p?, r2 == y\_\_0;
rearrange;
rewrite;
next;
\end{forget}

\begin{forget}[LinksFilterSets\$domainCheck]
rewrite;
\end{forget}

\begin{forget}[lChainMidPointFilterSetsEquivalence]
invoke LinksFilterSets;
equality substitute;
rewrite;
\end{forget}

\begin{forget}[lChainMidPointFilterSetsDisjoint]
instantiate end\_\_0 == end,
    links\_\_0 == links,
    p\_\_0? == p?,
    set\_\_0 == set,
    start\_\_0 == start,
    x\_\_0 == x,
    y\_\_0 == y,
    links\_upto\_midpoint == \{  i: PID | x \in  \ran~  links \land  (i, links \inv  x) \in  links \plus  \},
    last\_link\_before\_midpoint == \{  l: PID | x \in  \ran~  links \land  l = links \inv  x \},
    links\_at\_midpoint == \{x, p?\},
    links\_from\_midpoint == \{  j: PID | (y, j) \in  links \plus  \land  (j, end) \in  links \plus  \},
    all\_links == \{  i: PID | x \in  \ran~  links \land  (i, links \inv  x) \in  links \plus  \}
        \cup  \{  l: PID | x \in  \ran~  links \land  l = links \inv  x \}
        \cup  \{x, p?\}
        \cup  \{y\} \cup  \{  j: PID | (y, j) \in  links \plus  \land  (j, end) \in  links \plus  \},
    all\_links\_filters\_segments == \langle
        \{  i: PID | x \in  \ran~  links \land  (i, links \inv  x) \in  links \plus  \} \cup
        \{  l: PID | x \in  \ran~  links \land  l = links \inv  x \},
        \{x, p?\},
        \{y\} \cup  \{  j: PID | (y, j) \in  links \plus  \land  (j, end) \in  links \plus  \}
        \rangle;
invoke LinksFilterSets;
rewrite;
\end{forget}

\begin{forget}[lChainMidPointLinksPartition]
use lChainMidPointFilterSetsDisjoint;
use lChainMidPointFilterSetsEncompassAllLinks;
rearrange;
simplify;
invoke LinksPartition;
invoke LinksFilterSets;
equality substitute;
with enabled (disjointCat) rewrite;
apply lDresFilterCup;
rewrite;
apply lDresDisjointFiltering;
rewrite;
apply lDresFilterCup;
rewrite;
apply dresElimination;
rewrite;
\end{forget}

\begin{LPScript}\begin{forget}[lDeleteTransitiveClosureLemma]
invoke DeleteMiddleSig;
use lChainMidElemEverywhere;
rearrange;
rewrite;
use lNonEmptyLinksEndLinked;
use lNonEmptyLinksEndNotNull;
use lNonEmptyLinksEndNotInDom;
use lNonEmptyLinksStartLinked;
use lNonEmptyLinksStartNotNull;
use lNonEmptyLinksStartNotInRan;
rearrange;
simplify;
invoke Chain;
invoke GPID;
rearrange;
split \lnot  start = nullpid;
split \lnot  end = nullpid;
rewrite;
invoke DeleteTransitiveClosureCase;
rewrite;
prenex;
instantiate e == elem;
rearrange;
rewrite;
equality substitute set;
rearrange;
rewrite;
apply lNDresUnitOplusUnitAssociates to expression \{p?\} \ndres  links \oplus  \{(x, y)\};
rewrite;
apply lHeadExtractNDresDistTransitiveClosure to expression (\{p?\} \ndres  (links \oplus  \{(x, y)\})) \plus ;
rewrite;
cases;
apply inRan to predicate p? \in  \ran~  (\{p?\} \ndres  (links \oplus  \{(x, y)\}));
apply inRan to predicate p? \in  \ran~  (links \oplus  \{(x, y)\});
prenex;
rewrite;
instantiate x\_\_1 == x\_\_0;
rearrange;
rewrite;
apply oplusDef to expression links \oplus  \{(x, y)\};
rewrite;
apply lPInjWeakening to predicate links \in  PID \pinj  PID;
instantiate r == p?, d1 == x, d2 == p?;
rearrange;
rewrite;
next;
use lRelElemInDom[\num , \num ][R := links, y := p?];
rearrange;
rewrite;
instantiate e == x;
instantiate e == y;
rearrange;
rewrite;
rearrange;
apply oplusDef to expression links \oplus  \{(x, y)\};
rewrite;
split \lnot  elem \in  PID;
cases;
rearrange;
split elem \in  \dom~ links \land  \lnot  elem = p?;
cases;
rewrite;
next;
rearrange;
simplify;
apply inRan to predicate elem \in  \ran~  ((\{p?\} \cup  \{x\}) \ndres  links);
prenex;
rewrite;
use lLinksRanElemType[x := x\_\_0, y := elem];
rearrange;
simplify;
next;
apply lUnionTransitiveClosure;
rewrite;
use lUnionSingletonTransitiveClosure[\num ][R := \{x\} \ndres  links, x := start, y := elem, z := start];
rearrange;
rewrite;
split (start, start) \in  (\{x\} \ndres  links) \plus ;
simplify;
split x = start;
rewrite;
cases;
apply lHeadExtractNDresDistTransitiveClosure to expression (\{x\} \ndres  links) \plus ;
equality substitute x;
with predicate (start \in  \num  \land  links \in  \num  \rel  \num  \land  \lnot  start \in  \ran~  links) rewrite;
apply inNdres to predicate (start, elem) \in  \{start\} \ndres  links \plus ;
with predicate ((start, elem).1 \in  \{start\}) rewrite;
with predicate (\{start\} \in  \power  \num  \land  links \plus  \in  \num  \rel  \num ) rewrite;
rewrite;
rewrite;
cases;
rewrite;
rewrite;
split x = start;
rewrite;
split y = start;
rewrite;
cases;
split elem \in  \dom~ links \land  \lnot  elem = p?;
rewrite;
cases;
next;
rearrange;
apply lInHomogeneousNotElemRanNDres to predicate elem \in  \ran~  (\{p?\} \ndres  (links \oplus  \{(x, y)\}));
rearrange;
rewrite;
apply oplusDef to expression links \oplus  \{(x, y)\};
rewrite;
rewrite;
apply lInHomogeneousElemRanNDres to predicate elem \in  \ran~  (\{p?\} \ndres  (links \oplus  \{(x, y)\}));
rewrite;
apply lInHomogeneousElemRanNDres to predicate elem \in  \ran~  (\{p?\} \ndres  (links \oplus  \{(x, y)\}));
rearrange;
rewrite;
apply oplusDef to expression links \oplus  \{(x, y)\};
rewrite;
with normalization rewrite;
rewrite;
cases;
with predicate (\{(x, y)\} \in  \power  (\num  \cross  \num ) \land  \{x\} \ndres  links \in  \power  (\num  \cross  \num )) rewrite;
apply lInOplusUnit to predicate (x\_\_0, p?) \in  links \oplus  \{(x, y)\};
rewrite;
rearrange;
rewrite;
\end{forget}\end{LPScript}

\begin{LPScript}\begin{forget}[tPREDeleteMiddle]
invoke DeleteMiddle;
invoke DeleteMiddleSig;
use lChainMidElemEverywhere;
invoke \Delta Chain;
invoke ChainSuccess;
prove;
apply lInRanInjection to predicate p? \in  \ran~  links;
apply inDom to predicate p? \in  \dom~ links;
prenex;
rewrite;
use lPInjPairIsRanPoint[\num , \num ][A := PID, B := PID, f := links, x := p?, y := y];
use lApplyInvInDomPInj[\num , \num ][A := PID, B := PID, f := links, a := p?];
use lChainMidElemEverywhere;
rearrange;
rewrite;
rearrange;
split links = \{\};
cases;
rewrite;
next;
use lNonEmptyLinksEndNotNull;
use lNonEmptyLinksStartNotNull;
use lNonEmptyLinksStartLinked;
use lNonEmptyLinksEndLinked;
use lNonEmptyLinksStartNotInRan;
use lNonEmptyLinksEndNotInDom;
rearrange;
simplify;
invoke Chain;
invoke GPID;
rearrange;
split \lnot  start = nullpid;
simplify;
split \lnot  end = nullpid;
rewrite;
rearrange;
rewrite;
apply lUnionExchangeDiffLeft to expression \dom~ links \setminus  \{p?\} \cup  \{links \inv  p?\};
rewrite;
split links \inv  p? = p?;
rewrite;
cases;
apply lElemUnionAbsorbDiffRight to expression \{p?\} \cup  (\dom~ links \setminus  \{p?\});
apply lUnitOplusAbsorbsUnitNDres to expression \{p?\} \ndres  links \oplus  \{(p?, links p?)\};
apply lPFunElemAbsorbsUnitOplusRight to expression links \oplus  \{(p?, links p?)\};
rewrite;
apply lCupAssociatesBackwards to expression \{p?\} \cup  (\dom~ links \setminus  \{p?\} \cup  \ran~  links);
apply lElemUnionAbsorbDiffRight to expression \{p?\} \cup  (\dom~ links \setminus  \{p?\});
rewrite;
equality substitute \dom~ links \setminus  \ran~  links;
equality substitute \ran~  links \setminus  \dom~ links;
rewrite;
cases;
prove;
next;
prove;
next;
prenex;
apply cupPermutes to expression \{p?\} \cup  (\{start\} \cup  (\dom~ links \setminus  \{p?\} \cup  \ran~  links));
apply lCupAssociatesBackwards to expression \{p?\} \cup  (\dom~ links \setminus  \{p?\} \cup  \ran~  links);
apply lElemUnionAbsorbDiffRight to expression \{p?\} \cup  (\dom~ links \setminus  \{p?\});
rewrite;
instantiate e\_\_0 == e;
equality substitute set;
rearrange;
rewrite;
next;
simplify;
apply lCupAssociatesBackwards to expression \dom~ links \setminus  \{p?\} \cup  (\{links \inv  p?\} \cup  \ran~  (\{p?\} \ndres  links \oplus  \{(links \inv  p?, links p?)\}));
apply lUnionExchangeDiffLeft to expression \dom~ links \setminus  \{p?\} \cup  \{links \inv  p?\};
apply cupSubsetRight to expression \dom~ links \cup  \{links \inv  p?\};
rewrite;
apply lPFunElemAbsorbsUnitOplusRight to expression \{p?\} \ndres  links \oplus  \{(links \inv  p?, links p?)\};
rewrite;
rearrange;
use lPInjPointIsNotShared[\num , \num ][f := links, x1 := p?, x2 := x];
rearrange;
rewrite;
equality substitute links \inv  p?;
equality substitute links p?;
split \{p?\} \ndres  links \oplus  \{(x, y)\} = \{\};
cases;
apply oplusDef to expression \{p?\} \ndres  links \oplus  \{(x, y)\};
rearrange;
rewrite;
next;
rearrange;
rewrite;
split p? = y;
rewrite;
apply lUnionExchangeDiffLeft to expression \dom~ links \setminus  \{p?\} \cup  \ran~  (\{p?\} \ndres  links \oplus  \{(x, y)\});
apply lRightDiffLeftDistribute to expression \ran~  (\{p?\} \ndres  links \oplus  \{(x, y)\}) \setminus  (\dom~ links \setminus  \{p?\});
apply capUnit to expression \ran~  (\{p?\} \ndres  links \oplus  \{(x, y)\}) \cap  \{p?\};
rewrite;
apply lHomogeneousPInjMidPointExtractNotInRan to predicate p? \in  \ran~  (\{p?\} \ndres  links \oplus  \{(x, y)\});
rewrite;
use lHomogeneousPInjMidPointExtractNotInRan[\num ][f := links, p? := p?, x := x, y := y];
rearrange;
simplify;
with predicate (links \in  \num  \pinj  \num  \land  p? \in  \num ) rewrite;
apply distributeDiffOverCupLeft to expression \dom~ links \cup  \ran~  (\{p?\} \ndres  links \oplus  \{(x, y)\}) \setminus  \{p?\};
apply lElemDiffAbsorbption to expression \ran~  (\{p?\} \ndres  links \oplus  \{(x, y)\}) \setminus  \{p?\};
rewrite;
apply lHomogeneousMidPointExtractRanEquiv to expression \{p?\} \cup  \ran~  (\{p?\} \ndres  links \oplus  \{(x, y)\});
rewrite;
apply cupPermutes to expression \{p?\} \cup  (\{y\} \cup  \ran~  links);
apply cupSubsetLeft to expression \{p?\} \cup  \ran~  links;
rewrite;
apply cupSubsetLeft to expression \{y\} \cup  \ran~  links;
rewrite;
equality substitute \dom~ links \setminus  \ran~  links;
rewrite;
apply lUnionExchangeDiffLeft to expression \dom~ links \setminus  \{p?\} \cup  \ran~  (\{p?\} \ndres  links \oplus  \{(x, y)\});
apply distributeDiffOverCupLeft to expression \dom~ links \cup  \ran~  (\{p?\} \ndres  links \oplus  \{(x, y)\}) \setminus  \{p?\};
apply lElemDiffAbsorbption to expression \ran~  (\{p?\} \ndres  links \oplus  \{(x, y)\}) \setminus  \{p?\};
rewrite;
apply lCupAssociatesBackwards to expression \{start\} \cup  (\dom~ links \setminus  \{p?\} \cup  \ran~  (\{p?\} \ndres  links \oplus  \{(x, y)\}));
apply cupSubsetLeft to expression \{start\} \cup  (\dom~ links \setminus  \{p?\});
rewrite;
use lEndEquivalenceLemma;
use lDeleteTransitiveClosureLinksUpdateLemma;
use lDeleteTransitiveClosureLemma;
rearrange;
simplify;
invoke DeleteMiddleSig;
invoke Chain;
invoke GPID;
rearrange;
rewrite;
rearrange;
invoke DeleteTransitiveClosureCase;
simplify;
instantiate end' == end;
rewrite;
rearrange;
cases;
prove;
next;
equality substitute set;
rewrite;
use lFinsetSubset[X := \ran~  (\{p?\} \ndres  links \oplus  \{(x, y)\}), Y := \ran~  links, Z := PID];
rearrange;
simplify;
apply ranInPower to predicate \ran~  (\{p?\} \ndres  links \oplus  \{(x, y)\}) \in  \power  (\ran~  links);
apply overrideInRel to predicate \{p?\} \ndres  links \oplus  \{(x, y)\} \in  \num  \rel  \ran~  links;
apply ndres\_result to predicate \{p?\} \ndres  links \in  \num  \rel  \ran~  links;
apply rel\_ideal to predicate \power  links \in  \power  (\num  \rel  \ran~  links);
apply lRelWithinRan to predicate links \in  \num  \rel  \ran~  links;
rewrite;
next;
apply oplusDef to expression \{p?\} \ndres  links \oplus  \{(x, y)\};
rewrite;
next;
\end{forget}\end{LPScript}