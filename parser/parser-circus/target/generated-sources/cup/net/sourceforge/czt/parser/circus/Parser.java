
//----------------------------------------------------
// The following code was generated by CUP v0.11a czt01 beta
// Sun Oct 18 08:40:40 UTC 2020
//----------------------------------------------------

package net.sourceforge.czt.parser.circus;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Properties;
import java.util.Collection;
import java.util.Collections;
import java_cup.runtime.*;
import net.sourceforge.czt.util.CztException;
import net.sourceforge.czt.util.Section;
import net.sourceforge.czt.util.CztLogger;
import net.sourceforge.czt.base.ast.*;
import net.sourceforge.czt.base.util.PerformanceSettings;
import net.sourceforge.czt.z.ast.*;
import net.sourceforge.czt.z.util.*;
import net.sourceforge.czt.session.*;
import net.sourceforge.czt.parser.util.*;
import net.sourceforge.czt.parser.z.*;
import net.sourceforge.czt.circus.ast.*;
import net.sourceforge.czt.circus.util.CircusUtils;
import net.sourceforge.czt.circus.util.Factory;
import net.sourceforge.czt.session.Dialect;

/** CUP v0.11a czt01 beta generated parser.
  * @version Sun Oct 18 08:40:40 UTC 2020
  */
public class Parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\u0204\000\002\002\004\000\002\002\004\000\002\002" +
    "\004\000\002\002\004\000\002\002\004\000\002\004\002" +
    "\000\002\004\003\000\002\003\004\000\002\003\003\000" +
    "\002\006\003\000\002\007\002\000\002\011\004\000\002" +
    "\011\003\000\002\005\004\000\002\010\006\000\002\013" +
    "\002\000\002\013\003\000\002\013\004\000\002\012\005" +
    "\000\002\012\003\000\002\014\004\000\002\014\004\000" +
    "\002\014\004\000\002\014\004\000\002\014\002\000\002" +
    "\017\003\000\002\017\003\000\002\017\003\000\002\017" +
    "\004\000\002\021\003\000\002\015\005\000\002\015\005" +
    "\000\002\015\005\000\002\015\005\000\002\016\005\000" +
    "\002\016\003\000\002\020\003\000\002\020\003\000\002" +
    "\020\003\000\002\020\010\000\002\020\005\000\002\020" +
    "\003\000\002\160\003\000\002\073\005\000\002\025\007" +
    "\000\002\025\010\000\002\023\006\000\002\075\003\000" +
    "\002\075\002\000\002\074\006\000\002\022\005\000\002" +
    "\024\005\000\002\024\006\000\002\024\005\000\002\027" +
    "\005\000\002\027\003\000\002\030\005\000\002\051\005" +
    "\000\002\051\003\000\002\052\003\000\002\052\006\000" +
    "\002\031\004\000\002\031\003\000\002\032\004\000\002" +
    "\032\004\000\002\032\004\000\002\033\003\000\002\033" +
    "\003\000\002\033\003\000\002\033\003\000\002\044\003" +
    "\000\002\044\003\000\002\044\005\000\002\044\003\000" +
    "\002\043\003\000\002\043\003\000\002\034\007\000\002" +
    "\034\006\000\002\035\007\000\002\036\010\000\002\037" +
    "\006\000\002\040\002\000\002\040\005\000\002\042\003" +
    "\000\002\042\003\000\002\041\003\000\002\174\005\000" +
    "\002\174\005\000\002\174\005\000\002\173\005\000\002" +
    "\173\003\000\002\167\003\000\002\167\003\000\002\167" +
    "\003\000\002\167\003\000\002\175\005\000\002\175\003" +
    "\000\002\170\003\000\002\170\003\000\002\170\003\000" +
    "\002\170\010\000\002\170\005\000\002\170\003\000\002" +
    "\170\003\000\002\170\003\000\002\170\003\000\002\223" +
    "\005\000\002\223\003\000\002\161\004\000\002\161\004" +
    "\000\002\161\005\000\002\161\005\000\002\202\005\000" +
    "\002\202\003\000\002\201\005\000\002\201\003\000\002" +
    "\203\006\000\002\203\005\000\002\203\003\000\002\203" +
    "\007\000\002\203\006\000\002\203\006\000\002\203\005" +
    "\000\002\204\005\000\002\204\004\000\002\162\007\000" +
    "\002\162\010\000\002\162\007\000\002\162\006\000\002" +
    "\205\003\000\002\171\007\000\002\171\003\000\002\206" +
    "\004\000\002\206\005\000\002\206\003\000\002\206\003" +
    "\000\002\206\003\000\002\207\005\000\002\207\006\000" +
    "\002\207\011\000\002\207\006\000\002\207\006\000\002" +
    "\207\006\000\002\207\006\000\002\207\007\000\002\207" +
    "\012\000\002\207\007\000\002\207\007\000\002\207\007" +
    "\000\002\210\005\000\002\210\006\000\002\210\011\000" +
    "\002\210\006\000\002\210\006\000\002\210\006\000\002" +
    "\210\006\000\002\210\007\000\002\210\012\000\002\210" +
    "\007\000\002\210\007\000\002\210\007\000\002\213\003" +
    "\000\002\213\005\000\002\213\005\000\002\213\007\000" +
    "\002\213\005\000\002\213\005\000\002\213\005\000\002" +
    "\213\003\000\002\213\003\000\002\211\004\000\002\211" +
    "\005\000\002\211\004\000\002\211\005\000\002\211\004" +
    "\000\002\211\003\000\002\212\005\000\002\212\005\000" +
    "\002\212\006\000\002\212\010\000\002\212\005\000\002" +
    "\212\006\000\002\212\010\000\002\212\006\000\002\212" +
    "\006\000\002\212\006\000\002\217\003\000\002\221\003" +
    "\000\002\221\005\000\002\224\003\000\002\224\003\000" +
    "\002\220\003\000\002\222\003\000\002\222\005\000\002" +
    "\225\006\000\002\226\003\000\002\226\003\000\002\226" +
    "\003\000\002\214\003\000\002\214\005\000\002\214\006" +
    "\000\002\235\004\000\002\166\006\000\002\166\004\000" +
    "\002\176\005\000\002\177\005\000\002\200\005\000\002" +
    "\216\007\000\002\165\006\000\002\252\003\000\002\172" +
    "\005\000\002\230\004\000\002\230\003\000\002\230\003" +
    "\000\002\231\005\000\002\231\011\000\002\231\006\000" +
    "\002\231\013\000\002\231\010\000\002\231\006\000\002" +
    "\231\006\000\002\231\006\000\002\231\007\000\002\232" +
    "\003\000\002\232\003\000\002\232\005\000\002\232\003" +
    "\000\002\236\003\000\002\236\003\000\002\236\003\000" +
    "\002\236\006\000\002\236\005\000\002\236\011\000\002" +
    "\236\005\000\002\236\013\000\002\236\011\000\002\236" +
    "\016\000\002\236\014\000\002\236\005\000\002\236\005" +
    "\000\002\236\005\000\002\236\005\000\002\236\007\000" +
    "\002\236\005\000\002\236\003\000\002\236\004\000\002" +
    "\233\004\000\002\233\003\000\002\234\005\000\002\234" +
    "\005\000\002\234\006\000\002\234\011\000\002\234\006" +
    "\000\002\237\003\000\002\241\004\000\002\241\007\000" +
    "\002\241\005\000\002\242\003\000\002\242\002\000\002" +
    "\243\004\000\002\243\003\000\002\246\004\000\002\246" +
    "\010\000\002\246\004\000\002\246\004\000\002\246\007" +
    "\000\002\246\006\000\002\246\006\000\002\246\006\000" +
    "\002\247\005\000\002\247\005\000\002\247\005\000\002" +
    "\247\006\000\002\247\011\000\002\247\010\000\002\247" +
    "\005\000\002\247\005\000\002\250\005\000\002\250\003" +
    "\000\002\251\005\000\002\215\005\000\002\163\007\000" +
    "\002\164\007\000\002\227\003\000\002\227\003\000\002" +
    "\227\003\000\002\227\004\000\002\047\005\000\002\047" +
    "\003\000\002\046\005\000\002\046\003\000\002\065\002" +
    "\000\002\065\003\000\002\066\003\000\002\064\003\000" +
    "\002\064\005\000\002\072\003\000\002\072\003\000\002" +
    "\045\005\000\002\045\005\000\002\045\003\000\002\071" +
    "\003\000\002\071\003\000\002\067\005\000\002\067\005" +
    "\000\002\070\005\000\002\077\003\000\002\077\003\000" +
    "\002\053\005\000\002\053\003\000\002\055\003\000\002" +
    "\054\005\000\002\054\005\000\002\054\005\000\002\054" +
    "\003\000\002\054\003\000\002\054\003\000\002\153\003" +
    "\000\002\153\003\000\002\153\003\000\002\153\003\000" +
    "\002\153\003\000\002\153\003\000\002\153\003\000\002" +
    "\153\003\000\002\153\003\000\002\153\003\000\002\153" +
    "\003\000\002\153\003\000\002\153\003\000\002\153\003" +
    "\000\002\153\003\000\002\153\003\000\002\153\003\000" +
    "\002\153\003\000\002\153\003\000\002\153\003\000\002" +
    "\056\003\000\002\056\003\000\002\060\005\000\002\060" +
    "\003\000\002\057\003\000\002\057\003\000\002\057\005" +
    "\000\002\124\003\000\002\124\003\000\002\124\003\000" +
    "\002\124\003\000\002\125\004\000\002\125\004\000\002" +
    "\125\006\000\002\125\006\000\002\126\004\000\002\126" +
    "\004\000\002\126\006\000\002\126\006\000\002\127\005" +
    "\000\002\127\005\000\002\127\007\000\002\127\007\000" +
    "\002\130\005\000\002\130\005\000\002\136\002\000\002" +
    "\136\004\000\002\151\004\000\002\151\004\000\002\147" +
    "\004\000\002\147\004\000\002\146\004\000\002\146\004" +
    "\000\002\150\004\000\002\150\004\000\002\152\004\000" +
    "\002\152\004\000\002\131\003\000\002\131\003\000\002" +
    "\131\003\000\002\131\003\000\002\132\004\000\002\132" +
    "\007\000\002\133\004\000\002\133\007\000\002\134\005" +
    "\000\002\134\010\000\002\135\006\000\002\137\002\000" +
    "\002\137\005\000\002\156\003\000\002\156\003\000\002" +
    "\154\003\000\002\154\003\000\002\155\003\000\002\155" +
    "\003\000\002\107\005\000\002\107\003\000\002\116\003" +
    "\000\002\101\005\000\002\101\003\000\002\100\010\000" +
    "\002\100\006\000\002\100\006\000\002\100\006\000\002" +
    "\100\006\000\002\100\006\000\002\100\006\000\002\100" +
    "\005\000\002\100\005\000\002\100\005\000\002\100\005" +
    "\000\002\100\004\000\002\100\005\000\002\100\005\000" +
    "\002\100\007\000\002\100\005\000\002\100\004\000\002" +
    "\100\004\000\002\100\003\000\002\100\003\000\002\100" +
    "\003\000\002\100\003\000\002\100\005\000\002\100\004" +
    "\000\002\245\005\000\002\245\003\000\002\102\004\000" +
    "\002\102\003\000\002\103\005\000\002\103\007\000\002" +
    "\103\005\000\002\103\007\000\002\103\006\000\002\103" +
    "\003\000\002\103\003\000\002\103\005\000\002\103\004" +
    "\000\002\103\005\000\002\103\005\000\002\103\005\000" +
    "\002\103\004\000\002\103\004\000\002\103\007\000\002" +
    "\103\006\000\002\103\006\000\002\103\003\000\002\103" +
    "\005\000\002\103\003\000\002\103\003\000\002\103\003" +
    "\000\002\104\003\000\002\104\002\000\002\105\004\000" +
    "\002\105\003\000\002\106\003\000\002\106\005\000\002" +
    "\106\004\000\002\106\004\000\002\121\005\000\002\121" +
    "\005\000\002\122\002\000\002\122\003\000\002\123\005" +
    "\000\002\123\003\000\002\120\002\000\002\120\003\000" +
    "\002\117\005\000\002\117\003\000\002\050\005\000\002" +
    "\050\003\000\002\026\005\000\002\076\003\000\002\076" +
    "\003\000\002\076\003\000\002\076\003\000\002\061\003" +
    "\000\002\062\005\000\002\062\003\000\002\063\005\000" +
    "\002\110\003\000\002\110\003\000\002\110\003\000\002" +
    "\113\004\000\002\113\007\000\002\113\007\000\002\114" +
    "\004\000\002\114\007\000\002\114\007\000\002\111\003" +
    "\000\002\111\010\000\002\111\010\000\002\112\005\000" +
    "\002\112\005\000\002\112\005\000\002\112\005\000\002" +
    "\112\005\000\002\112\005\000\002\115\006\000\002\115" +
    "\006\000\002\140\003\000\002\140\003\000\002\140\003" +
    "\000\002\141\004\000\002\141\007\000\002\141\007\000" +
    "\002\142\004\000\002\142\007\000\002\142\007\000\002" +
    "\143\005\000\002\143\010\000\002\143\010\000\002\144" +
    "\006\000\002\144\006\000\002\145\002\000\002\145\005" +
    "\000\002\145\005\000\002\157\002\000\002\157\003" });

  /** Access to production table. */
  @Override
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    loadTableFromFile("action_table");

  /** Access to parse-action table. */
  @Override
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u040b\000\010\002\005\004\003\031\006\001\001\000" +
    "\016\003\u01c3\005\u01c8\006\u01c2\007\u01c6\010\u01c4\011\u01c7" +
    "\001\001\000\044\057\042\100\121\102\016\103\060\110" +
    "\032\111\015\112\047\113\034\114\030\115\033\116\u01c1" +
    "\121\012\140\044\141\054\142\050\143\027\144\051\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\012\017\u019e\022\u01a3\023\u01a4\025\u019d\001\001\000" +
    "\044\057\042\100\041\102\016\103\060\107\024\110\032" +
    "\111\015\112\047\113\034\114\030\115\033\121\012\140" +
    "\044\141\054\142\050\143\027\144\051\001\001\000\002" +
    "\001\001\000\006\241\u0176\245\u0174\001\001\000\042\057" +
    "\042\100\u0172\102\016\103\060\110\032\111\015\112\047" +
    "\113\034\114\030\115\033\121\012\140\044\141\054\142" +
    "\050\143\027\144\051\001\001\000\002\001\001\000\012" +
    "\057\042\103\u0171\115\033\144\051\001\001\000\110\041" +
    "\232\047\u016e\054\226\055\207\056\203\057\042\064\201" +
    "\065\170\066\213\067\204\070\214\071\175\072\230\100" +
    "\121\102\016\103\060\110\032\111\015\112\047\113\034" +
    "\114\030\115\033\116\222\121\012\124\231\125\165\126" +
    "\171\127\224\130\212\140\044\141\054\142\050\143\027" +
    "\144\051\153\211\001\001\000\064\041\232\057\042\100" +
    "\u0162\101\u0160\102\016\103\060\110\032\111\015\112\047" +
    "\113\034\114\030\115\033\116\113\121\012\123\u0163\124" +
    "\373\125\165\126\171\127\224\130\212\140\044\141\054" +
    "\142\050\143\027\144\051\001\001\000\042\057\042\100" +
    "\u015d\102\016\103\060\110\032\111\015\112\047\113\034" +
    "\114\030\115\033\121\012\140\044\141\054\142\050\143" +
    "\027\144\051\001\001\000\004\145\320\001\001\000\042" +
    "\057\042\100\317\102\016\103\060\110\032\111\015\112" +
    "\047\113\034\114\030\115\033\121\012\140\044\141\054" +
    "\142\050\143\027\144\051\001\001\000\004\077\354\001" +
    "\001\000\042\057\042\100\u015c\102\016\103\060\110\032" +
    "\111\015\112\047\113\034\114\030\115\033\121\012\140" +
    "\044\141\054\142\050\143\027\144\051\001\001\000\004" +
    "\145\341\001\001\000\002\001\001\000\002\001\001\000" +
    "\044\057\042\100\041\102\016\103\060\107\u0157\110\032" +
    "\111\015\112\047\113\034\114\030\115\033\121\012\140" +
    "\044\141\054\142\050\143\027\144\051\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\012\057" +
    "\042\103\u0150\115\033\144\051\001\001\000\110\041\232" +
    "\047\u014b\054\226\055\207\056\203\057\042\064\201\065" +
    "\170\066\213\067\204\070\214\071\175\072\230\100\121" +
    "\102\016\103\060\110\032\111\015\112\047\113\034\114" +
    "\030\115\033\116\222\121\012\124\231\125\165\126\171" +
    "\127\224\130\212\140\044\141\054\142\050\143\027\144" +
    "\051\153\211\001\001\000\002\001\001\000\110\041\232" +
    "\047\u0148\054\226\055\207\056\203\057\042\064\201\065" +
    "\170\066\213\067\204\070\214\071\175\072\230\100\121" +
    "\102\016\103\060\110\032\111\015\112\047\113\034\114" +
    "\030\115\033\116\222\121\012\124\231\125\165\126\171" +
    "\127\224\130\212\140\044\141\054\142\050\143\027\144" +
    "\051\153\211\001\001\000\002\001\001\000\002\001\001" +
    "\000\030\041\232\055\207\056\203\070\u0144\117\u0142\120" +
    "\u0143\124\u0116\125\165\126\171\127\224\130\212\001\001" +
    "\000\002\001\001\000\116\041\232\045\u0138\047\u0137\054" +
    "\226\055\207\056\203\057\042\064\u0103\065\u0136\066\213" +
    "\067\204\070\214\071\u0101\072\230\100\121\102\016\103" +
    "\060\110\032\111\015\112\047\113\034\114\030\115\033" +
    "\116\u0106\121\012\122\u0139\123\u013a\124\231\125\165\126" +
    "\171\127\224\130\212\140\044\141\054\142\050\143\027" +
    "\144\051\153\211\001\001\000\110\041\232\045\u0134\054" +
    "\226\055\207\056\203\057\042\064\u0103\065\377\066\213" +
    "\067\204\070\214\071\u0101\072\230\100\121\102\016\103" +
    "\060\110\032\111\015\112\047\113\034\114\030\115\033" +
    "\116\222\121\012\124\231\125\165\126\171\127\224\130" +
    "\212\140\044\141\054\142\050\143\027\144\051\153\211" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\026\026\u0126\041\232\050\u0124\055\207\056\u0125" +
    "\124\u0116\125\165\126\171\127\224\130\212\001\001\000" +
    "\002\001\001\000\002\001\001\000\110\041\232\047\u0121" +
    "\054\226\055\207\056\203\057\042\064\201\065\170\066" +
    "\213\067\204\070\214\071\175\072\230\100\121\102\016" +
    "\103\060\110\032\111\015\112\047\113\034\114\030\115" +
    "\033\116\222\121\012\124\231\125\165\126\171\127\224" +
    "\130\212\140\044\141\054\142\050\143\027\144\051\153" +
    "\211\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\076\362\001\001\000\002\001\001\000\110\041\232\047" +
    "\202\054\226\055\207\056\203\057\042\064\201\065\170" +
    "\066\213\067\204\070\214\071\175\072\230\100\121\102" +
    "\016\103\060\110\032\111\015\112\047\113\034\114\030" +
    "\115\033\116\222\121\012\124\231\125\165\126\171\127" +
    "\224\130\212\140\044\141\054\142\050\143\027\144\051" +
    "\153\211\001\001\000\042\057\042\100\064\102\016\103" +
    "\060\110\032\111\015\112\047\113\034\114\030\115\033" +
    "\121\012\140\044\141\054\142\050\143\027\144\051\001" +
    "\001\000\002\001\001\000\042\057\042\100\160\102\016" +
    "\103\060\110\032\111\015\112\047\113\034\114\030\115" +
    "\033\121\012\140\044\141\054\142\050\143\027\144\051" +
    "\001\001\000\004\145\147\001\001\000\042\057\042\100" +
    "\146\102\016\103\060\110\032\111\015\112\047\113\034" +
    "\114\030\115\033\121\012\140\044\141\054\142\050\143" +
    "\027\144\051\001\001\000\042\057\042\100\145\102\016" +
    "\103\060\110\032\111\015\112\047\113\034\114\030\115" +
    "\033\121\012\140\044\141\054\142\050\143\027\144\051" +
    "\001\001\000\042\057\042\100\144\102\016\103\060\110" +
    "\032\111\015\112\047\113\034\114\030\115\033\121\012" +
    "\140\044\141\054\142\050\143\027\144\051\001\001\000" +
    "\042\057\042\100\143\102\016\103\060\110\032\111\015" +
    "\112\047\113\034\114\030\115\033\121\012\140\044\141" +
    "\054\142\050\143\027\144\051\001\001\000\042\057\042" +
    "\100\142\102\016\103\060\110\032\111\015\112\047\113" +
    "\034\114\030\115\033\121\012\140\044\141\054\142\050" +
    "\143\027\144\051\001\001\000\042\057\042\100\141\102" +
    "\016\103\060\110\032\111\015\112\047\113\034\114\030" +
    "\115\033\121\012\140\044\141\054\142\050\143\027\144" +
    "\051\001\001\000\042\057\042\100\140\102\016\103\060" +
    "\110\032\111\015\112\047\113\034\114\030\115\033\121" +
    "\012\140\044\141\054\142\050\143\027\144\051\001\001" +
    "\000\002\001\001\000\042\057\042\100\131\102\016\103" +
    "\060\110\032\111\015\112\047\113\034\114\030\115\033" +
    "\121\012\140\044\141\054\142\050\143\027\144\051\001" +
    "\001\000\004\145\111\001\001\000\002\001\001\000\002" +
    "\001\001\000\042\057\042\100\110\102\016\103\060\110" +
    "\032\111\015\112\047\113\034\114\030\115\033\121\012" +
    "\140\044\141\054\142\050\143\027\144\051\001\001\000" +
    "\042\057\042\100\107\102\016\103\060\110\032\111\015" +
    "\112\047\113\034\114\030\115\033\121\012\140\044\141" +
    "\054\142\050\143\027\144\051\001\001\000\042\057\042" +
    "\100\106\102\016\103\060\110\032\111\015\112\047\113" +
    "\034\114\030\115\033\121\012\140\044\141\054\142\050" +
    "\143\027\144\051\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\050\057\042\100\114\102\016" +
    "\103\060\110\032\111\015\112\047\113\034\114\030\115" +
    "\033\116\113\121\012\122\112\123\115\140\044\141\054" +
    "\142\050\143\027\144\051\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\044" +
    "\057\042\100\121\102\016\103\060\110\032\111\015\112" +
    "\047\113\034\114\030\115\033\116\120\121\012\140\044" +
    "\141\054\142\050\143\027\144\051\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\042\057\042" +
    "\100\125\102\016\103\060\110\032\111\015\112\047\113" +
    "\034\114\030\115\033\121\012\140\044\141\054\142\050" +
    "\143\027\144\051\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\042\057\042\100\130\102\016" +
    "\103\060\110\032\111\015\112\047\113\034\114\030\115" +
    "\033\121\012\140\044\141\054\142\050\143\027\144\051" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\060\134\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\050\057\042\100\151\102\016\103\060" +
    "\110\032\111\015\112\047\113\034\114\030\115\033\116" +
    "\113\121\012\122\150\123\115\140\044\141\054\142\050" +
    "\143\027\144\051\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\042\057\042\100\154\102\016" +
    "\103\060\110\032\111\015\112\047\113\034\114\030\115" +
    "\033\121\012\140\044\141\054\142\050\143\027\144\051" +
    "\001\001\000\002\001\001\000\002\001\001\000\042\057" +
    "\042\100\157\102\016\103\060\110\032\111\015\112\047" +
    "\113\034\114\030\115\033\121\012\140\044\141\054\142" +
    "\050\143\027\144\051\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\136\312\145\341\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\077\337\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\136" +
    "\306\145\320\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\044\041\305\057\042\100\317" +
    "\102\016\103\060\110\032\111\015\112\047\113\034\114" +
    "\030\115\033\121\012\140\044\141\054\142\050\143\027" +
    "\144\051\001\001\000\002\001\001\000\044\041\316\057" +
    "\042\100\064\102\016\103\060\110\032\111\015\112\047" +
    "\113\034\114\030\115\033\121\012\140\044\141\054\142" +
    "\050\143\027\144\051\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\041\271\001\001\000\004\136\257\001\001" +
    "\000\004\136\242\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\041\241\001\001\000\002\001\001\000\010" +
    "\147\246\150\244\151\245\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\041\253\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\146\261\151\245\152" +
    "\262\001\001\000\002\001\001\000\004\041\266\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\020\041\232\124\304\125" +
    "\165\126\171\127\224\130\212\153\303\001\001\000\044" +
    "\057\042\100\121\102\016\103\060\110\032\111\015\112" +
    "\047\113\034\114\030\115\033\116\274\121\012\140\044" +
    "\141\054\142\050\143\027\144\051\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\041\316" +
    "\001\001\000\004\136\312\001\001\000\004\136\306\001" +
    "\001\000\004\041\305\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\147\310\150\307\151" +
    "\245\001\001\000\002\001\001\000\004\041\311\001\001" +
    "\000\002\001\001\000\010\146\313\151\245\152\314\001" +
    "\001\000\004\041\315\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\050\057" +
    "\042\100\322\102\016\103\060\110\032\111\015\112\047" +
    "\113\034\114\030\115\033\116\113\121\012\122\321\123" +
    "\115\140\044\141\054\142\050\143\027\144\051\001\001" +
    "\000\002\001\001\000\002\001\001\000\042\057\042\100" +
    "\325\102\016\103\060\110\032\111\015\112\047\113\034" +
    "\114\030\115\033\121\012\140\044\141\054\142\050\143" +
    "\027\144\051\001\001\000\002\001\001\000\002\001\001" +
    "\000\042\057\042\100\330\102\016\103\060\110\032\111" +
    "\015\112\047\113\034\114\030\115\033\121\012\140\044" +
    "\141\054\142\050\143\027\144\051\001\001\000\002\001" +
    "\001\000\002\001\001\000\044\057\042\100\121\102\016" +
    "\103\060\110\032\111\015\112\047\113\034\114\030\115" +
    "\033\116\332\121\012\140\044\141\054\142\050\143\027" +
    "\144\051\001\001\000\002\001\001\000\042\057\042\100" +
    "\334\102\016\103\060\110\032\111\015\112\047\113\034" +
    "\114\030\115\033\121\012\140\044\141\054\142\050\143" +
    "\027\144\051\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\100\041\232\054\226\055\207\056" +
    "\203\057\042\067\204\070\214\071\175\072\340\100\121" +
    "\102\016\103\060\110\032\111\015\112\047\113\034\114" +
    "\030\115\033\116\222\121\012\124\231\125\165\126\171" +
    "\127\224\130\212\140\044\141\054\142\050\143\027\144" +
    "\051\153\211\001\001\000\002\001\001\000\050\057\042" +
    "\100\343\102\016\103\060\110\032\111\015\112\047\113" +
    "\034\114\030\115\033\116\113\121\012\122\342\123\115" +
    "\140\044\141\054\142\050\143\027\144\051\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\042" +
    "\057\042\100\346\102\016\103\060\110\032\111\015\112" +
    "\047\113\034\114\030\115\033\121\012\140\044\141\054" +
    "\142\050\143\027\144\051\001\001\000\002\001\001\000" +
    "\002\001\001\000\042\057\042\100\351\102\016\103\060" +
    "\110\032\111\015\112\047\113\034\114\030\115\033\121" +
    "\012\140\044\141\054\142\050\143\027\144\051\001\001" +
    "\000\002\001\001\000\044\057\042\100\041\102\016\103" +
    "\060\107\353\110\032\111\015\112\047\113\034\114\030" +
    "\115\033\121\012\140\044\141\054\142\050\143\027\144" +
    "\051\001\001\000\004\077\354\001\001\000\042\057\042" +
    "\100\355\102\016\103\060\110\032\111\015\112\047\113" +
    "\034\114\030\115\033\121\012\140\044\141\054\142\050" +
    "\143\027\144\051\001\001\000\002\001\001\000\120\041" +
    "\232\045\u0105\054\226\055\207\056\u0104\057\042\061\376" +
    "\062\u0100\063\u0102\064\u0103\065\377\066\213\067\204\070" +
    "\214\071\u0101\072\230\100\121\102\016\103\060\110\032" +
    "\111\015\112\047\113\034\114\030\115\033\116\u0106\121" +
    "\012\123\u0107\124\231\125\165\126\171\127\224\130\212" +
    "\140\044\141\054\142\050\143\027\144\051\153\211\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\057\367\001" +
    "\001\000\002\001\001\000\016\041\232\124\373\125\165" +
    "\126\171\127\224\130\212\001\001\000\002\001\001\000" +
    "\004\136\312\001\001\000\004\041\316\001\001\000\004" +
    "\136\306\001\001\000\002\001\001\000\004\041\305\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\077\u011a\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\012\076\u010f\104\u010c\105\u010b\106\u010e\001\001\000\030" +
    "\041\232\055\207\056\u0114\061\u0113\062\u0100\063\u0102\124" +
    "\u0116\125\165\126\171\127\224\130\212\001\001\000\006" +
    "\076\u010f\106\u0112\001\001\000\002\001\001\000\004\057" +
    "\u0111\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\057\u0118\001\001\000\002\001\001\000\002\001" +
    "\001\000\100\041\232\054\226\055\207\056\203\057\042" +
    "\067\204\070\214\071\175\072\u011b\100\121\102\016\103" +
    "\060\110\032\111\015\112\047\113\034\114\030\115\033" +
    "\116\222\121\012\124\231\125\165\126\171\127\224\130" +
    "\212\140\044\141\054\142\050\143\027\144\051\153\211" +
    "\001\001\000\002\001\001\000\024\041\232\055\207\056" +
    "\u0114\063\u011d\124\u0116\125\165\126\171\127\224\130\212" +
    "\001\001\000\002\001\001\000\044\057\042\100\041\102" +
    "\016\103\060\107\u011f\110\032\111\015\112\047\113\034" +
    "\114\030\115\033\121\012\140\044\141\054\142\050\143" +
    "\027\144\051\001\001\000\004\077\354\001\001\000\002" +
    "\001\001\000\002\001\001\000\042\057\042\100\u0123\102" +
    "\016\103\060\110\032\111\015\112\047\113\034\114\030" +
    "\115\033\121\012\140\044\141\054\142\050\143\027\144" +
    "\051\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\044\057\042\100\121\102" +
    "\016\103\060\110\032\111\015\112\047\113\034\114\030" +
    "\115\033\116\u0128\121\012\140\044\141\054\142\050\143" +
    "\027\144\051\001\001\000\002\001\001\000\024\026\u012c" +
    "\041\232\055\207\056\u0125\124\u0116\125\165\126\171\127" +
    "\224\130\212\001\001\000\042\057\042\100\u012b\102\016" +
    "\103\060\110\032\111\015\112\047\113\034\114\030\115" +
    "\033\121\012\140\044\141\054\142\050\143\027\144\051" +
    "\001\001\000\002\001\001\000\002\001\001\000\042\057" +
    "\042\100\u0132\102\016\103\060\110\032\111\015\112\047" +
    "\113\034\114\030\115\033\121\012\140\044\141\054\142" +
    "\050\143\027\144\051\001\001\000\042\057\042\100\u0131" +
    "\102\016\103\060\110\032\111\015\112\047\113\034\114" +
    "\030\115\033\121\012\140\044\141\054\142\050\143\027" +
    "\144\051\001\001\000\042\057\042\100\u0130\102\016\103" +
    "\060\110\032\111\015\112\047\113\034\114\030\115\033" +
    "\121\012\140\044\141\054\142\050\143\027\144\051\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\044\057\042\100\121\102\016\103\060\110\032" +
    "\111\015\112\047\113\034\114\030\115\033\116\u013e\121" +
    "\012\140\044\141\054\142\050\143\027\144\051\001\001" +
    "\000\002\001\001\000\002\001\001\000\044\057\042\100" +
    "\041\102\016\103\060\107\u0141\110\032\111\015\112\047" +
    "\113\034\114\030\115\033\121\012\140\044\141\054\142" +
    "\050\143\027\144\051\001\001\000\004\077\354\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\024\041\232\055\207\056\203\070\u0147" +
    "\124\u0116\125\165\126\171\127\224\130\212\001\001\000" +
    "\002\001\001\000\002\001\001\000\042\057\042\100\u014a" +
    "\102\016\103\060\110\032\111\015\112\047\113\034\114" +
    "\030\115\033\121\012\140\044\141\054\142\050\143\027" +
    "\144\051\001\001\000\002\001\001\000\002\001\001\000" +
    "\042\057\042\100\u014d\102\016\103\060\110\032\111\015" +
    "\112\047\113\034\114\030\115\033\121\012\140\044\141" +
    "\054\142\050\143\027\144\051\001\001\000\002\001\001" +
    "\000\004\145\u0154\001\001\000\004\145\u0151\001\001\000" +
    "\004\076\362\001\001\000\050\057\042\100\u0153\102\016" +
    "\103\060\110\032\111\015\112\047\113\034\114\030\115" +
    "\033\116\113\121\012\122\u0152\123\115\140\044\141\054" +
    "\142\050\143\027\144\051\001\001\000\002\001\001\000" +
    "\002\001\001\000\050\057\042\100\u0156\102\016\103\060" +
    "\110\032\111\015\112\047\113\034\114\030\115\033\116" +
    "\113\121\012\122\u0155\123\115\140\044\141\054\142\050" +
    "\143\027\144\051\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\077\354\001\001\000\042\057\042\100\u0159" +
    "\102\016\103\060\110\032\111\015\112\047\113\034\114" +
    "\030\115\033\121\012\140\044\141\054\142\050\143\027" +
    "\144\051\001\001\000\002\001\001\000\042\057\042\100" +
    "\u015b\102\016\103\060\110\032\111\015\112\047\113\034" +
    "\114\030\115\033\121\012\140\044\141\054\142\050\143" +
    "\027\144\051\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\136\306\145\320\001\001\000" +
    "\044\041\305\057\042\100\317\102\016\103\060\110\032" +
    "\111\015\112\047\113\034\114\030\115\033\121\012\140" +
    "\044\141\054\142\050\143\027\144\051\001\001\000\004" +
    "\077\u016c\001\001\000\006\136\312\145\341\001\001\000" +
    "\002\001\001\000\002\001\001\000\110\041\232\047\u0166" +
    "\054\226\055\207\056\203\057\042\064\201\065\170\066" +
    "\213\067\204\070\214\071\175\072\230\100\121\102\016" +
    "\103\060\110\032\111\015\112\047\113\034\114\030\115" +
    "\033\116\222\121\012\124\231\125\165\126\171\127\224" +
    "\130\212\140\044\141\054\142\050\143\027\144\051\153" +
    "\211\001\001\000\044\041\316\057\042\100\064\102\016" +
    "\103\060\110\032\111\015\112\047\113\034\114\030\115" +
    "\033\121\012\140\044\141\054\142\050\143\027\144\051" +
    "\001\001\000\002\001\001\000\002\001\001\000\044\057" +
    "\042\100\121\102\016\103\060\110\032\111\015\112\047" +
    "\113\034\114\030\115\033\116\u0169\121\012\140\044\141" +
    "\054\142\050\143\027\144\051\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\042\057\042\100" +
    "\u016d\102\016\103\060\110\032\111\015\112\047\113\034" +
    "\114\030\115\033\121\012\140\044\141\054\142\050\143" +
    "\027\144\051\001\001\000\002\001\001\000\002\001\001" +
    "\000\042\057\042\100\u0170\102\016\103\060\110\032\111" +
    "\015\112\047\113\034\114\030\115\033\121\012\140\044" +
    "\141\054\142\050\143\027\144\051\001\001\000\002\001" +
    "\001\000\004\076\362\001\001\000\002\001\001\000\010" +
    "\242\u017e\243\u0182\246\u0183\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\241\u017c\001\001\000" +
    "\002\001\001\000\002\001\001\000\046\057\042\100\121" +
    "\102\016\103\060\110\032\111\015\112\047\113\034\114" +
    "\030\115\033\116\113\121\012\123\u0197\140\044\141\054" +
    "\142\050\143\027\144\051\001\001\000\002\001\001\000" +
    "\002\001\001\000\044\057\042\100\121\102\016\103\060" +
    "\110\032\111\015\112\047\113\034\114\030\115\033\116" +
    "\u0189\121\012\140\044\141\054\142\050\143\027\144\051" +
    "\001\001\000\044\057\042\100\121\102\016\103\060\110" +
    "\032\111\015\112\047\113\034\114\030\115\033\116\u0185" +
    "\121\012\140\044\141\054\142\050\143\027\144\051\001" +
    "\001\000\004\246\u0184\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\044" +
    "\057\042\100\041\102\016\103\060\107\u0192\110\032\111" +
    "\015\112\047\113\034\114\030\115\033\121\012\140\044" +
    "\141\054\142\050\143\027\144\051\001\001\000\004\077" +
    "\354\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\243" +
    "\u0199\246\u0183\001\001\000\004\246\u0184\001\001\000\042" +
    "\057\042\100\u019b\102\016\103\060\110\032\111\015\112" +
    "\047\113\034\114\030\115\033\121\012\140\044\141\054" +
    "\142\050\143\027\144\051\001\001\000\002\001\001\000" +
    "\004\074\u01bc\001\001\000\002\001\001\000\002\001\001" +
    "\000\110\041\232\046\u01b8\054\226\055\207\056\203\057" +
    "\042\064\201\065\u01b7\066\213\067\204\070\214\071\175" +
    "\072\230\100\121\102\016\103\060\110\032\111\015\112" +
    "\047\113\034\114\030\115\033\116\222\121\012\124\231" +
    "\125\165\126\171\127\224\130\212\140\044\141\054\142" +
    "\050\143\027\144\051\153\211\001\001\000\004\055\u01b3" +
    "\001\001\000\002\001\001\000\004\055\u01a5\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\157\u01a6\001\001" +
    "\000\004\074\u01a9\001\001\000\002\001\001\000\004\053" +
    "\u01ad\001\001\000\110\041\232\047\u01aa\054\226\055\207" +
    "\056\203\057\042\064\201\065\170\066\213\067\204\070" +
    "\214\071\175\072\230\100\121\102\016\103\060\110\032" +
    "\111\015\112\047\113\034\114\030\115\033\116\222\121" +
    "\012\124\231\125\165\126\171\127\224\130\212\140\044" +
    "\141\054\142\050\143\027\144\051\153\211\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\157\u01b0\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\157\u01b4\001\001\000\110\041\232\047\u01b5\054\226\055" +
    "\207\056\203\057\042\064\201\065\170\066\213\067\204" +
    "\070\214\071\175\072\230\100\121\102\016\103\060\110" +
    "\032\111\015\112\047\113\034\114\030\115\033\116\222" +
    "\121\012\124\231\125\165\126\171\127\224\130\212\140" +
    "\044\141\054\142\050\143\027\144\051\153\211\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\044\057\042\100\041" +
    "\102\016\103\060\107\u01bb\110\032\111\015\112\047\113" +
    "\034\114\030\115\033\121\012\140\044\141\054\142\050" +
    "\143\027\144\051\001\001\000\004\077\354\001\001\000" +
    "\110\041\232\046\u01bd\054\226\055\207\056\203\057\042" +
    "\064\201\065\u01b7\066\213\067\204\070\214\071\175\072" +
    "\230\100\121\102\016\103\060\110\032\111\015\112\047" +
    "\113\034\114\030\115\033\116\222\121\012\124\231\125" +
    "\165\126\171\127\224\130\212\140\044\141\054\142\050" +
    "\143\027\144\051\153\211\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\014\u040c\001\001\000\002\001\001\000" +
    "\004\014\u01d2\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\005\u01c9\010\u01c4\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\013\u01cb\001\001\000\002\001\001" +
    "\000\004\012\u01cd\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\022\015\u01d7\017\u01d8\021\u01d5\022\u01a3\023\u01a4\025" +
    "\u019d\031\u01d4\174\u01d6\001\001\000\020\055\u0330\161\u0306" +
    "\162\u0315\163\u0311\167\u0319\171\u030c\173\u040a\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\074\016\u030a\020\u031e\024" +
    "\u030d\027\u0309\030\u01e7\032\u031c\041\232\055\u0310\056\u01f3" +
    "\073\u030e\074\u01dd\075\u031d\124\u0116\125\165\126\171\127" +
    "\224\130\212\131\u01e8\132\u01f0\133\u01f2\134\u01e4\135\u01e6" +
    "\161\u0306\162\u0315\163\u0311\167\u0319\171\u030c\173\u0318\235" +
    "\u031b\001\001\000\066\024\u01df\027\u01dc\030\u01e7\041\232" +
    "\055\u01e5\056\u01f3\073\u01e0\074\u01dd\075\u01f5\124\u0116\125" +
    "\165\126\171\127\224\130\212\131\u01e8\132\u01f0\133\u01f2" +
    "\134\u01e4\135\u01e6\164\u01ea\165\u01ed\166\u01ee\170\u01ef\172" +
    "\u01e2\175\u01e9\235\u01f4\001\001\000\004\055\u0301\001\001" +
    "\000\002\001\001\000\002\001\001\000\046\055\u02fa\057" +
    "\042\100\121\102\016\103\060\110\032\111\015\112\047" +
    "\113\034\114\030\115\033\116\u02fb\121\012\140\044\141" +
    "\054\142\050\143\027\144\051\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\136\306\137\u02f5\001\001\000" +
    "\002\001\001\000\006\041\305\055\u02f4\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\020\060\u0206\232\u0205\233\u0204\234\u0213\236\u020e\241" +
    "\u0216\247\u0208\001\001\000\004\055\u0200\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\053\u01fe\001\001\000\002\001\001\000\004" +
    "\074\u01fa\001\001\000\002\001\001\000\002\001\001\000" +
    "\044\057\042\100\041\102\016\103\060\107\u01f7\110\032" +
    "\111\015\112\047\113\034\114\030\115\033\121\012\140" +
    "\044\141\054\142\050\143\027\144\051\001\001\000\004" +
    "\077\354\001\001\000\002\001\001\000\044\057\042\100" +
    "\121\102\016\103\060\110\032\111\015\112\047\113\034" +
    "\114\030\115\033\116\u01fd\121\012\140\044\141\054\142" +
    "\050\143\027\144\051\001\001\000\002\001\001\000\044" +
    "\057\042\100\121\102\016\103\060\110\032\111\015\112" +
    "\047\113\034\114\030\115\033\116\u01fc\121\012\140\044" +
    "\141\054\142\050\143\027\144\051\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\157\u01b0" +
    "\001\001\000\002\001\001\000\046\057\042\100\121\102" +
    "\016\103\060\110\032\111\015\112\047\113\034\114\030" +
    "\115\033\116\u0203\121\012\140\044\141\054\142\050\143" +
    "\027\144\051\252\u0202\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\215\u0227\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\055\u02b9\001\001\000\052\057\042\100\041\102\016\103" +
    "\060\107\u0219\110\032\111\015\112\047\113\034\114\030" +
    "\115\033\121\012\140\044\141\054\142\050\143\027\144" +
    "\051\237\u02b0\250\u02b7\251\u02b1\001\001\000\052\057\042" +
    "\100\041\102\016\103\060\107\u0219\110\032\111\015\112" +
    "\047\113\034\114\030\115\033\121\012\140\044\141\054" +
    "\142\050\143\027\144\051\237\u02b0\250\u02af\251\u02b1\001" +
    "\001\000\044\057\042\100\041\102\016\103\060\107\u02ad" +
    "\110\032\111\015\112\047\113\034\114\030\115\033\121" +
    "\012\140\044\141\054\142\050\143\027\144\051\001\001" +
    "\000\056\041\232\054\226\060\u0206\067\u0275\124\u0260\125" +
    "\165\126\171\127\224\130\212\153\211\220\u026a\222\u0268" +
    "\224\u026d\225\u026c\226\u0272\231\u0267\232\u0266\233\u0204\234" +
    "\u0213\236\u020e\241\u0216\247\u0208\001\001\000\002\001\001" +
    "\000\026\041\232\054\226\067\u025f\124\u0260\125\165\126" +
    "\171\127\224\130\212\153\211\221\u025e\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\177\u025a\001\001\000\044\057\042\100\041" +
    "\102\016\103\060\107\u0258\110\032\111\015\112\047\113" +
    "\034\114\030\115\033\121\012\140\044\141\054\142\050" +
    "\143\027\144\051\001\001\000\002\001\001\000\044\057" +
    "\042\100\121\102\016\103\060\110\032\111\015\112\047" +
    "\113\034\114\030\115\033\116\u0254\121\012\140\044\141" +
    "\054\142\050\143\027\144\051\001\001\000\046\057\042" +
    "\100\041\102\016\103\060\107\u0219\110\032\111\015\112" +
    "\047\113\034\114\030\115\033\121\012\140\044\141\054" +
    "\142\050\143\027\144\051\237\u021a\001\001\000\004\077" +
    "\354\001\001\000\002\001\001\000\002\001\001\000\020" +
    "\060\u0206\232\u021d\233\u0204\234\u0213\236\u020e\241\u0216\247" +
    "\u0208\001\001\000\004\215\u0227\001\001\000\074\041\232" +
    "\055\207\056\u0114\057\042\061\u0242\062\u0100\063\u0102\100" +
    "\121\102\016\103\060\110\032\111\015\112\047\113\034" +
    "\114\030\115\033\116\u0203\121\012\124\u0116\125\165\126" +
    "\171\127\224\130\212\140\044\141\054\142\050\143\027" +
    "\144\051\252\u0240\001\001\000\020\060\u0206\232\u023f\233" +
    "\u0204\234\u0213\236\u020e\241\u0216\247\u0208\001\001\000\046" +
    "\057\042\100\121\102\016\103\060\110\032\111\015\112" +
    "\047\113\034\114\030\115\033\116\u0233\121\012\140\044" +
    "\141\054\142\050\143\027\144\051\205\u023e\001\001\000" +
    "\020\060\u0206\232\u023d\233\u0204\234\u0213\236\u020e\241\u0216" +
    "\247\u0208\001\001\000\046\057\042\100\121\102\016\103" +
    "\060\110\032\111\015\112\047\113\034\114\030\115\033" +
    "\116\u0203\121\012\140\044\141\054\142\050\143\027\144" +
    "\051\252\u0230\001\001\000\046\057\042\100\121\102\016" +
    "\103\060\110\032\111\015\112\047\113\034\114\030\115" +
    "\033\116\u0203\121\012\140\044\141\054\142\050\143\027" +
    "\144\051\252\u022b\001\001\000\020\060\u0206\232\u022a\233" +
    "\u0204\234\u0213\236\u020e\241\u0216\247\u0208\001\001\000\020" +
    "\060\u0206\232\u0229\233\u0204\234\u0213\236\u020e\241\u0216\247" +
    "\u0208\001\001\000\020\060\u0206\232\u0228\233\u0204\234\u0213" +
    "\236\u020e\241\u0216\247\u0208\001\001\000\002\001\001\000" +
    "\004\215\u0227\001\001\000\004\215\u0227\001\001\000\004" +
    "\215\u0227\001\001\000\002\001\001\000\046\057\042\100" +
    "\121\102\016\103\060\110\032\111\015\112\047\113\034" +
    "\114\030\115\033\116\u0203\121\012\140\044\141\054\142" +
    "\050\143\027\144\051\252\u022d\001\001\000\002\001\001" +
    "\000\020\060\u0206\232\u022f\233\u0204\234\u0213\236\u020e\241" +
    "\u0216\247\u0208\001\001\000\004\215\u0227\001\001\000\002" +
    "\001\001\000\046\057\042\100\121\102\016\103\060\110" +
    "\032\111\015\112\047\113\034\114\030\115\033\116\u0233" +
    "\121\012\140\044\141\054\142\050\143\027\144\051\205" +
    "\u0232\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\020\060\u0206\232\u0236\233\u0204\234\u0213\236" +
    "\u020e\241\u0216\247\u0208\001\001\000\004\215\u0227\001\001" +
    "\000\046\057\042\100\121\102\016\103\060\110\032\111" +
    "\015\112\047\113\034\114\030\115\033\116\u0233\121\012" +
    "\140\044\141\054\142\050\143\027\144\051\205\u0238\001" +
    "\001\000\002\001\001\000\046\057\042\100\121\102\016" +
    "\103\060\110\032\111\015\112\047\113\034\114\030\115" +
    "\033\116\u0203\121\012\140\044\141\054\142\050\143\027" +
    "\144\051\252\u023a\001\001\000\002\001\001\000\020\060" +
    "\u0206\232\u023c\233\u0204\234\u0213\236\u020e\241\u0216\247\u0208" +
    "\001\001\000\004\215\u0227\001\001\000\004\215\u0227\001" +
    "\001\000\002\001\001\000\004\215\u0227\001\001\000\002" +
    "\001\001\000\046\057\042\100\121\102\016\103\060\110" +
    "\032\111\015\112\047\113\034\114\030\115\033\116\u0233" +
    "\121\012\140\044\141\054\142\050\143\027\144\051\205" +
    "\u0244\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\046\057\042\100\121\102" +
    "\016\103\060\110\032\111\015\112\047\113\034\114\030" +
    "\115\033\116\u0233\121\012\140\044\141\054\142\050\143" +
    "\027\144\051\205\u0247\001\001\000\002\001\001\000\002" +
    "\001\001\000\020\060\u0206\232\u024a\233\u0204\234\u0213\236" +
    "\u020e\241\u0216\247\u0208\001\001\000\004\215\u0227\001\001" +
    "\000\046\057\042\100\121\102\016\103\060\110\032\111" +
    "\015\112\047\113\034\114\030\115\033\116\u0233\121\012" +
    "\140\044\141\054\142\050\143\027\144\051\205\u024c\001" +
    "\001\000\002\001\001\000\002\001\001\000\046\057\042" +
    "\100\121\102\016\103\060\110\032\111\015\112\047\113" +
    "\034\114\030\115\033\116\u0233\121\012\140\044\141\054" +
    "\142\050\143\027\144\051\205\u024f\001\001\000\002\001" +
    "\001\000\046\057\042\100\121\102\016\103\060\110\032" +
    "\111\015\112\047\113\034\114\030\115\033\116\u0203\121" +
    "\012\140\044\141\054\142\050\143\027\144\051\252\u0251" +
    "\001\001\000\002\001\001\000\020\060\u0206\232\u0253\233" +
    "\u0204\234\u0213\236\u020e\241\u0216\247\u0208\001\001\000\004" +
    "\215\u0227\001\001\000\002\001\001\000\002\001\001\000" +
    "\020\060\u0206\232\u0257\233\u0204\234\u0213\236\u020e\241\u0216" +
    "\247\u0208\001\001\000\004\215\u0227\001\001\000\004\077" +
    "\354\001\001\000\002\001\001\000\002\001\001\000\046" +
    "\057\042\100\121\102\016\103\060\110\032\111\015\112" +
    "\047\113\034\114\030\115\033\116\113\121\012\123\u025c" +
    "\140\044\141\054\142\050\143\027\144\051\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\077\u0261\001\001" +
    "\000\002\001\001\000\002\001\001\000\024\041\232\054" +
    "\226\067\u0264\124\u0260\125\165\126\171\127\224\130\212" +
    "\153\211\001\001\000\020\060\u0206\232\u0263\233\u0204\234" +
    "\u0213\236\u020e\241\u0216\247\u0208\001\001\000\004\215\u0227" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\215" +
    "\u0227\001\001\000\002\001\001\000\002\001\001\000\030" +
    "\041\232\054\226\067\u025f\124\u0260\125\165\126\171\127" +
    "\224\130\212\153\211\217\u029a\221\u0278\001\001\000\002" +
    "\001\001\000\004\055\u028f\001\001\000\002\001\001\000" +
    "\002\001\001\000\030\041\232\054\226\067\u025f\124\u0260" +
    "\125\165\126\171\127\224\130\212\153\211\217\u028c\221" +
    "\u0278\001\001\000\030\041\232\054\226\067\u025f\124\u0260" +
    "\125\165\126\171\127\224\130\212\153\211\217\u0289\221" +
    "\u0278\001\001\000\030\041\232\054\226\067\u025f\124\u0260" +
    "\125\165\126\171\127\224\130\212\153\211\217\u0286\221" +
    "\u0278\001\001\000\002\001\001\000\004\223\u0281\001\001" +
    "\000\046\057\042\100\121\102\016\103\060\110\032\111" +
    "\015\112\047\113\034\114\030\115\033\116\u0233\121\012" +
    "\140\044\141\054\142\050\143\027\144\051\205\u0276\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\030\041\232\054\226\067\u025f\124\u0260\125\165\126" +
    "\171\127\224\130\212\153\211\217\u0279\221\u0278\001\001" +
    "\000\004\077\u0261\001\001\000\002\001\001\000\020\060" +
    "\u0206\232\u027b\233\u0204\234\u0213\236\u020e\241\u0216\247\u0208" +
    "\001\001\000\004\215\u0227\001\001\000\046\057\042\100" +
    "\121\102\016\103\060\110\032\111\015\112\047\113\034" +
    "\114\030\115\033\116\u0203\121\012\140\044\141\054\142" +
    "\050\143\027\144\051\252\u027d\001\001\000\002\001\001" +
    "\000\020\060\u0206\232\u027f\233\u0204\234\u0213\236\u020e\241" +
    "\u0216\247\u0208\001\001\000\004\215\u0227\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\044\057" +
    "\042\100\121\102\016\103\060\110\032\111\015\112\047" +
    "\113\034\114\030\115\033\116\u0284\121\012\140\044\141" +
    "\054\142\050\143\027\144\051\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\020\060\u0206\232" +
    "\u0288\233\u0204\234\u0213\236\u020e\241\u0216\247\u0208\001\001" +
    "\000\004\215\u0227\001\001\000\002\001\001\000\020\060" +
    "\u0206\232\u028b\233\u0204\234\u0213\236\u020e\241\u0216\247\u0208" +
    "\001\001\000\004\215\u0227\001\001\000\002\001\001\000" +
    "\020\060\u0206\232\u028e\233\u0204\234\u0213\236\u020e\241\u0216" +
    "\247\u0208\001\001\000\004\215\u0227\001\001\000\002\001" +
    "\001\000\056\041\232\054\226\060\u0206\067\u0275\124\u0260" +
    "\125\165\126\171\127\224\130\212\153\211\220\u026a\222" +
    "\u0268\224\u026d\225\u026c\226\u0272\231\u0292\232\u0291\233\u0204" +
    "\234\u0213\236\u020e\241\u0216\247\u0208\001\001\000\004\215" +
    "\u0227\001\001\000\002\001\001\000\004\177\u0294\001\001" +
    "\000\002\001\001\000\054\041\232\054\226\060\u0206\067" +
    "\u0275\124\u0260\125\165\126\171\127\224\130\212\153\211" +
    "\220\u0297\222\u0268\224\u026d\225\u026c\226\u0272\232\u0296\233" +
    "\u0204\234\u0213\236\u020e\241\u0216\247\u0208\001\001\000\004" +
    "\215\u0227\001\001\000\002\001\001\000\020\060\u0206\232" +
    "\u0299\233\u0204\234\u0213\236\u020e\241\u0216\247\u0208\001\001" +
    "\000\004\215\u0227\001\001\000\002\001\001\000\046\057" +
    "\042\100\121\102\016\103\060\110\032\111\015\112\047" +
    "\113\034\114\030\115\033\116\u0203\121\012\140\044\141" +
    "\054\142\050\143\027\144\051\252\u029e\001\001\000\020" +
    "\060\u0206\232\u029d\233\u0204\234\u0213\236\u020e\241\u0216\247" +
    "\u0208\001\001\000\004\215\u0227\001\001\000\002\001\001" +
    "\000\002\001\001\000\020\060\u0206\232\u02a1\233\u0204\234" +
    "\u0213\236\u020e\241\u0216\247\u0208\001\001\000\004\215\u0227" +
    "\001\001\000\032\041\232\054\226\067\u0275\124\u0260\125" +
    "\165\126\171\127\224\130\212\153\211\224\u02a3\225\u026c" +
    "\226\u0272\001\001\000\002\001\001\000\004\177\u02a5\001" +
    "\001\000\002\001\001\000\004\216\u02a7\001\001\000\002" +
    "\001\001\000\004\060\u02a9\001\001\000\002\001\001\000" +
    "\046\057\042\100\121\102\016\103\060\110\032\111\015" +
    "\112\047\113\034\114\030\115\033\116\113\121\012\123" +
    "\u02ab\140\044\141\054\142\050\143\027\144\051\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\077\354\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\020\060\u0206\232\u02b3\233\u0204\234" +
    "\u0213\236\u020e\241\u0216\247\u0208\001\001\000\004\215\u0227" +
    "\001\001\000\002\001\001\000\050\057\042\100\041\102" +
    "\016\103\060\107\u0219\110\032\111\015\112\047\113\034" +
    "\114\030\115\033\121\012\140\044\141\054\142\050\143" +
    "\027\144\051\237\u02b0\251\u02b6\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\020\060\u0206\232\u0291\233\u0204\234\u0213\236\u020e\241\u0216" +
    "\247\u0208\001\001\000\044\057\042\100\041\102\016\103" +
    "\060\107\u02bc\110\032\111\015\112\047\113\034\114\030" +
    "\115\033\121\012\140\044\141\054\142\050\143\027\144" +
    "\051\001\001\000\004\077\354\001\001\000\044\057\042" +
    "\100\041\102\016\103\060\107\u02be\110\032\111\015\112" +
    "\047\113\034\114\030\115\033\121\012\140\044\141\054" +
    "\142\050\143\027\144\051\001\001\000\004\077\354\001" +
    "\001\000\002\001\001\000\002\001\001\000\046\057\042" +
    "\100\121\102\016\103\060\110\032\111\015\112\047\113" +
    "\034\114\030\115\033\116\113\121\012\123\u02c2\140\044" +
    "\141\054\142\050\143\027\144\051\001\001\000\002\001" +
    "\001\000\044\057\042\100\041\102\016\103\060\107\u02c4" +
    "\110\032\111\015\112\047\113\034\114\030\115\033\121" +
    "\012\140\044\141\054\142\050\143\027\144\051\001\001" +
    "\000\004\077\354\001\001\000\044\057\042\100\041\102" +
    "\016\103\060\107\u02c6\110\032\111\015\112\047\113\034" +
    "\114\030\115\033\121\012\140\044\141\054\142\050\143" +
    "\027\144\051\001\001\000\004\077\354\001\001\000\002" +
    "\001\001\000\062\024\u01df\027\u01dc\030\u01e7\041\232\055" +
    "\u01e5\056\u01f3\073\u01e0\074\u01dd\075\u01f5\124\u0116\125\165" +
    "\126\171\127\224\130\212\131\u01e8\132\u01f0\133\u01f2\134" +
    "\u01e4\135\u01e6\164\u01ea\165\u01ed\166\u01ee\170\u02ca\172\u01e2" +
    "\001\001\000\002\001\001\000\002\001\001\000\044\057" +
    "\042\100\121\102\016\103\060\110\032\111\015\112\047" +
    "\113\034\114\030\115\033\116\u02cc\121\012\140\044\141" +
    "\054\142\050\143\027\144\051\001\001\000\002\001\001" +
    "\000\004\055\u02f3\001\001\000\060\041\232\054\226\060" +
    "\u0206\067\u0275\124\u0260\125\165\126\171\127\224\130\212" +
    "\153\211\220\u026a\222\u0268\224\u026d\225\u026c\226\u0272\230" +
    "\u02f0\231\u02ef\232\u02ee\233\u0204\234\u0213\236\u020e\241\u0216" +
    "\247\u0208\001\001\000\020\060\u0206\232\u02e7\233\u0204\234" +
    "\u0213\236\u020e\241\u0216\247\u0208\001\001\000\004\137\u02db" +
    "\001\001\000\002\001\001\000\026\041\232\051\u02d3\052" +
    "\u02d5\055\207\056\u02d4\124\u0116\125\165\126\171\127\224" +
    "\130\212\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\044\057\042\100\121\102\016\103\060" +
    "\110\032\111\015\112\047\113\034\114\030\115\033\116" +
    "\u02d7\121\012\140\044\141\054\142\050\143\027\144\051" +
    "\001\001\000\002\001\001\000\002\001\001\000\024\041" +
    "\232\052\u02da\055\207\056\u02d4\124\u0116\125\165\126\171" +
    "\127\224\130\212\001\001\000\002\001\001\000\004\055" +
    "\u02dc\001\001\000\010\154\u02dd\155\u02e1\156\u02de\001\001" +
    "\000\004\055\u02e6\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\215\u0227\227\u02e8\001\001\000\020" +
    "\060\u0206\232\u02ed\233\u0204\234\u0213\236\u020e\241\u0216\247" +
    "\u0208\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\215\u0227\001\001\000" +
    "\004\215\u0227\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\177\u025a\216\u02f2\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\055\u02f6\001\001" +
    "\000\010\154\u02f7\155\u02f8\156\u02de\001\001\000\004\055" +
    "\u02f9\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\044\057\042\100\121\102" +
    "\016\103\060\110\032\111\015\112\047\113\034\114\030" +
    "\115\033\116\u02fd\121\012\140\044\141\054\142\050\143" +
    "\027\144\051\001\001\000\002\001\001\000\006\030\u02ff" +
    "\055\u0300\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\157\u0302\001\001\000\006\074\u01dd\075\u0303\001\001" +
    "\000\002\001\001\000\044\057\042\100\041\102\016\103" +
    "\060\107\u0305\110\032\111\015\112\047\113\034\114\030" +
    "\115\033\121\012\140\044\141\054\142\050\143\027\144" +
    "\051\001\001\000\004\077\354\001\001\000\002\001\001" +
    "\000\012\034\u03b2\035\u03b1\037\u03b5\044\u0409\001\001\000" +
    "\004\055\u0403\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\074\u01dd\075\u03f5\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\074\u01dd\075\u03f1" +
    "\001\001\000\002\001\001\000\002\001\001\000\014\033" +
    "\u03eb\034\u03ea\035\u03e9\036\u03e8\037\u03ec\001\001\000\002" +
    "\001\001\000\014\053\u03d3\074\u03d1\202\u03d5\203\u03d4\223" +
    "\u03d2\001\001\000\002\001\001\000\002\001\001\000\012" +
    "\034\u03b2\035\u03b1\037\u03b5\044\u03b3\001\001\000\002\001" +
    "\001\000\002\001\001\000\012\074\u01dd\075\u0324\201\u0325" +
    "\204\u0322\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\044\057\042\100\041" +
    "\102\016\103\060\107\u0320\110\032\111\015\112\047\113" +
    "\034\114\030\115\033\121\012\140\044\141\054\142\050" +
    "\143\027\144\051\001\001\000\004\077\354\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\074\u01dd\075\u0324\204" +
    "\u0327\001\001\000\002\001\001\000\004\176\u032a\001\001" +
    "\000\046\057\042\100\121\102\016\103\060\110\032\111" +
    "\015\112\047\113\034\114\030\115\033\116\113\121\012" +
    "\123\u032b\140\044\141\054\142\050\143\027\144\051\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\016\055\u0330\161\u0306\162\u0315\163" +
    "\u0311\167\u0331\171\u030c\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\014\074\u0336\211\u0335\212" +
    "\u0338\213\u0334\214\u0333\001\001\000\002\001\001\000\004" +
    "\227\u03af\001\001\000\002\001\001\000\002\001\001\000" +
    "\010\176\u03a5\177\u035d\200\u035e\001\001\000\002\001\001" +
    "\000\066\024\u01df\027\u01dc\030\u01e7\041\232\055\u01e5\056" +
    "\u01f3\073\u01e0\074\u01dd\075\u01f5\124\u0116\125\165\126\171" +
    "\127\224\130\212\131\u01e8\132\u01f0\133\u01f2\134\u01e4\135" +
    "\u01e6\164\u01ea\165\u01ed\166\u01ee\170\u01ef\172\u01e2\175\u03a0" +
    "\235\u03a1\001\001\000\046\041\232\054\226\067\u025f\074" +
    "\u0336\124\u0260\125\165\126\171\127\224\130\212\153\211" +
    "\207\u033b\210\u033e\211\u0335\212\u0338\213\u0343\214\u0333\217" +
    "\u0340\221\u0278\001\001\000\002\001\001\000\030\041\232" +
    "\054\226\067\u025f\124\u0260\125\165\126\171\127\224\130" +
    "\212\153\211\217\u0394\221\u0278\001\001\000\030\041\232" +
    "\054\226\067\u025f\124\u0260\125\165\126\171\127\224\130" +
    "\212\153\211\217\u0388\221\u0278\001\001\000\002\001\001" +
    "\000\030\041\232\054\226\067\u025f\124\u0260\125\165\126" +
    "\171\127\224\130\212\153\211\217\u037c\221\u0278\001\001" +
    "\000\002\001\001\000\030\041\232\054\226\067\u025f\124" +
    "\u0260\125\165\126\171\127\224\130\212\153\211\217\u036b" +
    "\221\u0278\001\001\000\030\041\232\054\226\067\u025f\124" +
    "\u0260\125\165\126\171\127\224\130\212\153\211\217\u0354" +
    "\221\u0278\001\001\000\002\001\001\000\014\074\u0336\211" +
    "\u0335\212\u0338\213\u0353\214\u0333\001\001\000\014\074\u0336" +
    "\211\u0335\212\u0338\213\u0352\214\u0333\001\001\000\004\216" +
    "\u0351\001\001\000\014\074\u0336\211\u0335\212\u0338\213\u0350" +
    "\214\u0333\001\001\000\014\074\u0336\211\u0335\212\u0338\213" +
    "\u034f\214\u0333\001\001\000\046\057\042\100\121\102\016" +
    "\103\060\110\032\111\015\112\047\113\034\114\030\115" +
    "\033\116\u0233\121\012\140\044\141\054\142\050\143\027" +
    "\144\051\205\u034c\001\001\000\046\057\042\100\121\102" +
    "\016\103\060\110\032\111\015\112\047\113\034\114\030" +
    "\115\033\116\u0233\121\012\140\044\141\054\142\050\143" +
    "\027\144\051\205\u034b\001\001\000\002\001\001\000\002" +
    "\001\001\000\014\074\u0336\211\u0335\212\u0338\213\u034e\214" +
    "\u0333\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\050\041\232\054\226\067\u025f" +
    "\074\u0336\124\u0260\125\165\126\171\127\224\130\212\153" +
    "\211\206\u0368\207\u0357\210\u0358\211\u0335\212\u0338\213\u035b" +
    "\214\u0333\217\u0340\221\u0278\001\001\000\050\041\232\054" +
    "\226\067\u025f\074\u0336\124\u0260\125\165\126\171\127\224" +
    "\130\212\153\211\206\u0359\207\u0357\210\u0358\211\u0335\212" +
    "\u0338\213\u035b\214\u0333\217\u0340\221\u0278\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\012\176\u0360\177\u035d\200\u035e" +
    "\216\u035f\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\010\177\u0364\200\u0365\216\u0366\001\001" +
    "\000\046\057\042\100\121\102\016\103\060\110\032\111" +
    "\015\112\047\113\034\114\030\115\033\116\113\121\012" +
    "\123\u0362\140\044\141\054\142\050\143\027\144\051\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\050\041\232\054\226\067\u025f\074\u0336\124" +
    "\u0260\125\165\126\171\127\224\130\212\153\211\206\u0371" +
    "\207\u0357\210\u0358\211\u0335\212\u0338\213\u035b\214\u0333\217" +
    "\u0340\221\u0278\001\001\000\050\041\232\054\226\067\u025f" +
    "\074\u0336\124\u0260\125\165\126\171\127\224\130\212\153" +
    "\211\206\u036e\207\u0357\210\u0358\211\u0335\212\u0338\213\u035b" +
    "\214\u0333\217\u0340\221\u0278\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\050\041\232\054\226\067" +
    "\u025f\074\u0336\124\u0260\125\165\126\171\127\224\130\212" +
    "\153\211\206\u0379\207\u0357\210\u0358\211\u0335\212\u0338\213" +
    "\u035b\214\u0333\217\u0340\221\u0278\001\001\000\050\041\232" +
    "\054\226\067\u025f\074\u0336\124\u0260\125\165\126\171\127" +
    "\224\130\212\153\211\206\u0376\207\u0357\210\u0358\211\u0335" +
    "\212\u0338\213\u035b\214\u0333\217\u0340\221\u0278\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\050\041\232\054\226\067\u025f\074\u0336\124\u0260" +
    "\125\165\126\171\127\224\130\212\153\211\206\u0382\207" +
    "\u0357\210\u0358\211\u0335\212\u0338\213\u035b\214\u0333\217\u0340" +
    "\221\u0278\001\001\000\050\041\232\054\226\067\u025f\074" +
    "\u0336\124\u0260\125\165\126\171\127\224\130\212\153\211" +
    "\206\u037f\207\u0357\210\u0358\211\u0335\212\u0338\213\u035b\214" +
    "\u0333\217\u0340\221\u0278\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\200\u0386\216\u0387\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\046\057\042\100\121\102\016\103\060\110\032\111\015" +
    "\112\047\113\034\114\030\115\033\116\u0233\121\012\140" +
    "\044\141\054\142\050\143\027\144\051\205\u038a\001\001" +
    "\000\002\001\001\000\002\001\001\000\050\041\232\054" +
    "\226\067\u025f\074\u0336\124\u0260\125\165\126\171\127\224" +
    "\130\212\153\211\206\u0391\207\u0357\210\u0358\211\u0335\212" +
    "\u0338\213\u035b\214\u0333\217\u0340\221\u0278\001\001\000\050" +
    "\041\232\054\226\067\u025f\074\u0336\124\u0260\125\165\126" +
    "\171\127\224\130\212\153\211\206\u038e\207\u0357\210\u0358" +
    "\211\u0335\212\u0338\213\u035b\214\u0333\217\u0340\221\u0278\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\050\041\232\054\226\067\u025f\074\u0336" +
    "\124\u0260\125\165\126\171\127\224\130\212\153\211\206" +
    "\u039a\207\u0357\210\u0358\211\u0335\212\u0338\213\u035b\214\u0333" +
    "\217\u0340\221\u0278\001\001\000\050\041\232\054\226\067" +
    "\u025f\074\u0336\124\u0260\125\165\126\171\127\224\130\212" +
    "\153\211\206\u0397\207\u0357\210\u0358\211\u0335\212\u0338\213" +
    "\u035b\214\u0333\217\u0340\221\u0278\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\177\u039e\216\u039f" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\235" +
    "\u03a3\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\177\u0364\200\u0365\001" +
    "\001\000\034\041\232\054\226\067\u025f\124\u0260\125\165" +
    "\126\171\127\224\130\212\153\211\207\u03a7\210\u03a8\217" +
    "\u0340\221\u0278\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\176\u03aa\001\001\000\004\200\u03ab\001\001\000" +
    "\002\001\001\000\004\176\u03ad\001\001\000\004\177\u03ae" +
    "\001\001\000\002\001\001\000\014\074\u0336\211\u0335\212" +
    "\u0338\213\u03b0\214\u0333\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\043" +
    "\u03c8\001\001\000\002\001\001\000\004\041\u03b9\001\001" +
    "\000\004\041\u03c5\001\001\000\004\040\u03c1\001\001\000" +
    "\002\001\001\000\004\040\u03bb\001\001\000\006\041\u03bf" +
    "\042\u03be\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\041\u03c3\042\u03be\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\036\u03ca\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\041\u03cc\001\001\000\002" +
    "\001\001\000\004\040\u03ce\001\001\000\006\041\u03cf\042" +
    "\u03be\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\223\u03e0\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\012\053\u03d3\074\u03d1\203\u03d9\223\u03d2\001" +
    "\001\000\002\001\001\000\002\001\001\000\044\057\042" +
    "\100\121\102\016\103\060\110\032\111\015\112\047\113" +
    "\034\114\030\115\033\116\u03dc\121\012\140\044\141\054" +
    "\142\050\143\027\144\051\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\044\057\042\100\121\102" +
    "\016\103\060\110\032\111\015\112\047\113\034\114\030" +
    "\115\033\116\u03e3\121\012\140\044\141\054\142\050\143" +
    "\027\144\051\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\041\u03ee\001\001\000" +
    "\002\001\001\000\004\040\u03f0\001\001\000\006\041\u03cf" +
    "\042\u03be\001\001\000\004\055\u03f2\001\001\000\002\001" +
    "\001\000\050\041\232\054\226\067\u025f\074\u0336\124\u0260" +
    "\125\165\126\171\127\224\130\212\153\211\206\u03f4\207" +
    "\u0357\210\u0358\211\u0335\212\u0338\213\u035b\214\u0333\217\u0340" +
    "\221\u0278\001\001\000\002\001\001\000\004\055\u03f6\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\046\057\042\100\121\102\016\103" +
    "\060\110\032\111\015\112\047\113\034\114\030\115\033" +
    "\116\u0233\121\012\140\044\141\054\142\050\143\027\144" +
    "\051\205\u03fb\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\054\020\u0401\024" +
    "\u030d\027\u0309\030\u01e7\032\u031c\041\232\055\u0402\056\u01f3" +
    "\073\u030e\074\u01dd\075\u031d\124\u0116\125\165\126\171\127" +
    "\224\130\212\131\u01e8\132\u01f0\133\u01f2\134\u01e4\135\u01e6" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\157\u0404\001\001\000\006\074\u01dd\075\u0405" +
    "\001\001\000\004\160\u0406\001\001\000\044\057\042\100" +
    "\041\102\016\103\060\107\u0408\110\032\111\015\112\047" +
    "\113\034\114\030\115\033\121\012\140\044\141\054\142" +
    "\050\143\027\144\051\001\001\000\002\001\001\000\004" +
    "\077\354\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\022\015\u01d7\017\u01d8\021\u01d5\022\u01a3" +
    "\023\u01a4\025\u019d\031\u01d4\174\u01d6\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  @Override
  public short[][] reduce_table() {return _reduce_table;}


  /** Load external table from file. */
  private static short[][] loadTableFromFile(String tableName)
  {
    String tableFileName = tableName + ".dat";
    java.io.InputStream is = Parser.class.getResourceAsStream(tableFileName);
    if (is == null) {
      throw new RuntimeException("Cannot find external parser table " + tableFileName);
    }

    try {
      try {

        java.io.ObjectInputStream in = new java.io.ObjectInputStream(is);
        try {
          return (short[][]) in.readObject();
        } finally {
          in.close();
        }

      } finally {
        is.close();
      }
    } catch (Exception e) {
      throw new RuntimeException("Cannot load external parser table " + tableFileName, e);
    }
  }
  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  @Override
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  @Override
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack<java_cup.runtime.Symbol> stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  @Override
  public int start_state() {return 0;}
  /** Indicates start production. */
  @Override
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  @Override
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  @Override
  public int error_sym() {return 1;}


  /** User initialization code. */
  @Override
  public void user_init() throws java.lang.Exception
    {

    //share the operator table between the action code and the parser code
    action_obj.source_ = source_;
    action_obj.sectInfo_ = sectInfo_;
    action_obj.dialect_ = dialect_;
    action_obj.defaultSP_ = defaultSP_;
    action_obj.opScanner_ = opScanner_;
    action_obj.nlScanner_ = nlScanner_;
    action_obj.parserState_ = createParserState(source_);
    action_obj.factory_ = createParserFactory();


    }

  /** Scan to get the next Symbol. */
  @Override
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {
 return local_next_token(); 
    }


    private static final Map<Object, String> symbolMap_ = DebugUtils.getFieldMap(Sym.class);

    
    //static {
    //  System.err.println("Symbol table mapping" + " for " + getDialect().toString() + " in Parser:");
    //  java.util.Iterator it = symbolMap_.entrySet().iterator();
    //  while (it.hasNext())
    //  {
    //     Map.Entry entry = (Map.Entry)it.next();
    //     System.err.println("\t#" + entry.getKey() + " = " + entry.getValue());
    //  }
    //}
    

    @Override
    public Symbol parse() throws java.lang.Exception
    {
      // perform the parsing, but wrap into a try-catch, to react when problems
      // occur - we need to update the transactions in the section manager
      Symbol symbol;
      try {
      
        symbol = super.parse();
        
      } catch (Exception e) {
        /*
         * If fatal exception occurred during the parsing (usually problems are reported
         * but the parsing continues), we need to cancel the current transaction. This is 
         * required, because ZSect transactions are started manually, instead of via 
         * SectionInfo.get(). So upon exception, find out the current ZSect, and cancel
         * its transaction, then re-throw the exception.
         */
        cleanupZSectTransaction();
        
        throw e;
      }
      
      if (hasErrors())
      {
        // need to cleanup, e.g. if scanning error happens. It would be reported, but
        // parsing stops and section transaction is not closed.
        cleanupZSectTransaction();
        raiseErrors();
      }
      return symbol;
    }
    
    /**
     * Finds the current section, and cancels its transaction, if one is still active.
     * This is necessary because section transactions are started manually, and we need
     * to cleanup if unexpected error (e.g. underlying scanning error) happens. 
     */
    private void cleanupZSectTransaction() {
      String currentSect = action_obj.parserState_.getCurrentSectName();
      if (currentSect != null) {
        Key<ZSect> sectKey = new Key<ZSect>(currentSect, ZSect.class);
        // Check whether the current section transaction is still active.
        // This is needed, because sometimes the transaction has finished
        // and we are just reporting errors (and cleaning up)
        if (sectKey.equals(sectInfo_.getCurrentTransaction())) {
          sectInfo_.cancelTransaction(sectKey);
        }
      }
    }

    /** The file being parsed. */
    protected Source source_;

    /** Section information (parser code). */
    protected SectionInfo sectInfo_;

  // dialect is a final attribute determined at construction time
  // depending on the extension being used (i.e. decided at XML transformation time).
  // this is useful for fine-tuned error information. If no extension is chosen we 
  // get a compilation error (i.e. final field not assigned).
  protected final Dialect dialect_ = 
  						Dialect.CIRCUS
    				  // otherwise it will be unassigned, hence a compilation error
    				  ;

	protected DefaultSectionParents defaultSP_;

    /**
     * The list of parse errors.
     */
    protected List<CztError> errorList_;

    protected ParseException parseException_;

    /**
     * Contains the last token where a syntax error has occured.
     */
    private Symbol errorToken_;

    /**
     * True if and only if an error has occured during parsing.
     */
    //protected boolean error_ = false;

    private OperatorScanner opScanner_;
    private NewlineScanner nlScanner_;


		public Dialect getDialect()
		{
			return dialect_;
		}

    protected boolean hasErrors()
    {
      for(CztError e : errorList_)
      {
        if (e.getErrorType() == ErrorType.ERROR)
          return true;

      }
      return false;
    }

    protected void raiseErrors() throws ParseException
    {
      assert hasErrors() : "no errors to be raised";
      if (parseException_ == null)
      {
        assert source_ == null;
        parseException_ = new ParseException(getDialect(), errorList_);
      }
      assert parseException_.getErrors().equals(errorList_) : "inconsistent error list";
      Iterator<CztError> it = errorList_.iterator();
      while (it.hasNext())
      {
        CztError e = it.next();
        if (e.getErrorType().equals(ErrorType.WARNING))
        {
          it.remove();
          // TODO: Parser should have a warning manager (!) 
          //       For now, keep warnings as just "show" at the parser level?
          CztLogger.getLogger(Parser.class).warning(e.toString());
        }
      }
      it = null;
      // in case there are no more warnings...
      if (hasErrors())
      {
        throw parseException_;
      }
    }

    // there are more constructors created by java cup, don't put it final!
    private Set<Key<?>> explicitDeps_ = Collections.emptySet();

    Set<Key<?>> getExplicitDeps()
    {
      return Collections.unmodifiableSet(explicitDeps_);
    }

    /**
     * Creates a new parser with the given scanner, source information,
     * and section information.
     * The source information is only used for printing error messages.
     * The section information should be able to provide information of
     * type <code>net.sourceforge.czt.parser.util.OpTable.class</code>.
     */
    public Parser(CztScanner scanner,
                    Source source,
                    SectionInfo sectInfo,
                    Properties properties,
                    Collection<? extends Key<?>> explicitDeps)
    {
      super(scanner);
      source_ = source;
      sectInfo_ = sectInfo;
      assert scanner != null && sectInfo_ != null;
      errorList_ = new ArrayList<CztError>(PerformanceSettings.INITIAL_ARRAY_CAPACITY);
      explicitDeps_ = new HashSet<Key<?>>(explicitDeps);
      parseException_ = null;
      defaultSP_ = null;
      if (source != null) {
        try {
          parseException_ =
            sectInfo_.get(new Key<ParseException>(source.getName(),
                                  ParseException.class));
          errorList_ = parseException_.getErrors();
          
          defaultSP_ =
          	sectInfo_.get(new Key<DefaultSectionParents>(source.getName(),
          							DefaultSectionParents.class));
        }
        catch (CommandException e) {
          e.printStackTrace();
          //TODO: check this. why not report the error?
          //report_error(e.toString(), e);
        }
      }
      else {
      	try {
          defaultSP_ =
          	sectInfo_.get(new Key<DefaultSectionParents>(Section.ANONYMOUS.getName(),
          							DefaultSectionParents.class));
        }
        catch (CommandException e) {
          e.printStackTrace();
          //TODO: check this. why not report the error?
          //report_error(e.toString(), e);
        } 
      }
      assert defaultSP_ != null;
      opScanner_ = new OperatorScanner(getCztScanner(), properties);

      nlScanner_ = new NewlineScanner(opScanner_, properties);
      CztLogger.getLogger(Parser.class).finer("New " + Parser.class.getName() + 
      		" parser created for " + source_ 
      		+ " for " + getDialect().toString() + ".");
    }
    
    public CztScanner getCztScanner()
    {
    	return (CztScanner)getScanner();
    }

    /**
     * Returns the next token.
     */
    protected Symbol local_next_token() throws Exception
    {
      Symbol result = nlScanner_.next_token();
      assert result != action_obj.previous_;

      action_obj.previous_ = result;
      String logMessage =
        "Next token is (" + symbolMap_.get(result.sym) + ", " +
            (result.sym != Sym.TEXT ? String.valueOf(result.value) + ", " +
                (result.value != null ? result.value.getClass().getName() : "null") : "...shhh...")  
                + " for " + getDialect().toString() + " in Parser).";
      CztLogger.getLogger(Parser.class).finest(logMessage);
      return result;
    }

    /**
     * @throws ClassCastException if the object is not a CztError
     */
    public void report_error(String message, Object object)
    {
      CztError error = (CztError) object;
      errorList_.add(error);
      //error_ = true;
    }

    public void report_error(ZParseMessage msg,
                             Object[] params,
                             LocInfo locInfo)
    {
      report_error(null, new ZParseError(sectInfo_, msg, params, locInfo));
    }

 
    public void report_error(CircusParseMessage msg,
                             Object[] params,
                             LocInfo locInfo)
    {
      report_error(null, new CircusParseError(sectInfo_, msg, params, locInfo));
    }


    public void syntax_error(Symbol token)
    {
      errorToken_ = token;
    }

    public void unrecovered_syntax_error(Symbol token) //throws Exception
    {
      report_error("Syntax error", createSyntaxError(token));
      done_parsing();
      CztLogger.getLogger(Parser.class).severe("Parser error for " + getDialect().toString() + " dialect ==> token " +
      	symbolMap_.get(token.sym));
      // TODO: throw new ParseException?
      //	    throw new PrintException(dialect_, "Parser printer error: " +
	    //  String.valueOf(message) + " => " + (info instanceof Symbol ? symbolMap_.get(((Symbol)info).sym) : String.valueOf(info)));
    }

    public void report_syntax_error()
    {
      report_error("Syntax error", createSyntaxError(errorToken_));
    }

    protected CztError createSyntaxError(Symbol token)
    {
      return new ZParseError(sectInfo_, ZParseMessage.MSG_SYNTAX_ERROR,
                             new Object[] { toObject(token) },
                             getLocation(token));
    }

    public void report_syntax_error(ZParseMessage msg)
    {
      report_error(msg,
                   new Object[] { toObject(errorToken_) },
                   getLocation(errorToken_));
    }
    

    protected CztError createCircusSyntaxError(CircusParseMessage syntax_msg, Symbol token)
    {
      return new CircusParseError(sectInfo_, syntax_msg,
                             new Object[] { toObject(token) },
                             getLocation(token));
    }

    public void report_syntax_error(CircusParseMessage msg)
    {
      report_error(msg,
                   new Object[] { toObject(errorToken_) },
                   getLocation(errorToken_));
    }

    public void report_syntax_error(CircusParseMessage msg,
                             Object[] params,
                             LocInfo locInfo)
    {
      report_error(null, new CircusParseError(sectInfo_, msg, params, locInfo));
    }

    /**
     * <p>
     * Changes the toString() method of ZFactory (within the given Factory),
     * so that is uses the toString() strategy for Circus. This essentially
     * means that the ZFactory will use Circus' version of PrintVisitor, which
     * includes Spec, ZSect, and other interesting productions of interest.
     * </p>
     * <p>
     * They are importat in order to debug/inspect easily the rather complex
     * scoping mechanisms for basic (locally declared) processes.
     * It also shows how one could use the elegant CZT design for extension
     * surgical fine tunning!
     * </p>
     */
    protected void setZFactoryToStringVisitor(Factory f) {
        ZUtils.assertZFactoryImpl(f.getZFactory()).setToStringVisitor(
            CircusUtils.assertCircusFactoryImpl(f.getCircusFactory()).getToStringVisitor());
    }


    protected Object toObject(Symbol symbol)
    {
      if (symbol.value != null &&
          !(symbol.value instanceof LocInfo)) {
        return symbol.value;
      }
      return symbolMap_.get(symbol.sym);
    }

    protected String getLoc()
    {
      return source_.toString();
    }

    protected LocInfo getLocation(Symbol symbol)
    {
      if (symbol.value instanceof LocInfo) {
        return (LocInfo) symbol.value;
      }
      if (symbol.value instanceof LocString) {
        LocString s = (LocString) symbol.value;
        return s.getLocation();
      }
      if (symbol.value instanceof LocInt) {
        LocInt i = (LocInt) symbol.value;
        return i.getLocation();
      }
      return new LocInfoImpl(getDialect(), getLoc(), symbol.left, symbol.right);
    }

    protected LocInfo getLocation(Term term)
    {
      if (term != null) {
        return getLocation((LocAnn) term.getAnn(LocAnn.class));
      }
      return null;
    }

    protected LocInfo getLocation(LocAnn locAnn)
    {
      return new LocInfoImpl(getDialect(), locAnn);
    }

    protected ParserState createParserState(Source src)
    {
      return new ParserState(src);
    }

    protected Factory createParserFactory()
    {
      Factory result = new Factory();
      setZFactoryToStringVisitor(result);
      return result;
    }

}

/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings("unused")
class CUP$Parser$actions {




    /** The symbols used to replace arguments for names in ApplExpr etc. */
    protected final static String ARG_TOK = ZString.ARG_TOK;
    protected final static String LISTARG_TOK = ZString.LISTARG_TOK;

    /** The factory for creating AST objects. */
    protected Factory factory_;

    /** The table of operators. */
    protected OpTable opTable_;
    
    /** The table of named conjectures */
    protected ThmTable thmTable_;



    /** The source currently being parsed. */
    protected Source source_ = null;

    /**
     * The symbol returned by the last call to local_next_token().
     */
    protected Symbol previous_;

    protected ParserState parserState_;

   /** Section information (action code). */
    protected SectionInfo sectInfo_;

	protected DefaultSectionParents defaultSP_;

		/** Action code dialect */
	  protected Dialect dialect_;
	  
    /** The operator scanner. */
    protected OperatorScanner opScanner_;
    protected NewlineScanner nlScanner_;


		public Dialect getDialect()
		{
			return dialect_;
		}

    /**
     * Create an function application with the SchExpr formed from
     * 'st' and any additional renaming/strokes etc in 'al'.
     * 
     * @param e 
     * @param st 
     * @param al 
     * @return
     */
    private ApplExpr createSchApplExpr(Expr e, SchText st,
                                       List < Object > al)
    {
      Expr se = factory_.createSchExpr(st);
      for (Object a : al) {
        if (a instanceof Stroke) {
          se = factory_.createDecorExpr(se, (Stroke) a);
        }
        else if (a instanceof RenameExpr) {
          RenameExpr re = (RenameExpr) a;
          se = factory_.createRenameExpr(se, re.getRenameList());
        }
        else if (a instanceof BindSelExpr) {
          BindSelExpr bse = (BindSelExpr) a;
          se  = factory_.createBindSelExpr(se, bse.getName());
        }
        else if (a instanceof TupleSelExpr) {
          TupleSelExpr tse = (TupleSelExpr) a;
          se  = factory_.createTupleSelExpr(se, tse.getNumeral());
        }
      }
      ApplExpr result = factory_.createApplExpr(e, se, Boolean.FALSE);
      return result;
    }

    private void checkName(Decorword decorword)
    {
      ZChar unmatched = decorword.check();
      if (unmatched != null) {
        final Object[] params = { unmatched };
        parser.report_error(ZParseMessage.MSG_UNMATCHED_WORDGLUE,
                            params, decorword.getLocation());
      }
    }

    private Spec createSpec(List<? extends Sect> sectList)
    {
      Spec result = factory_.createSpec();
      result.setVersion(Version.ZML_VERSION);
      result.getSect().addAll(sectList);
      return result;
    }

    private ZName createZName(Decorword decorword)
    {
      checkName(decorword);
      ZName result = factory_.createZName(decorword.getWord(),
                                          decorword.getStrokes());
      addLocAnn(result, decorword.getLocation());
      return result;
    }


    /**
     * This solution is simpler(?) than the DEFNAME used by Object-Z to
     * disambiguate DECORWORD where a name is needed. For Circus, we
     * just use DECORWORD, which does not cause ambiguity, but check
     * that strokes are empty if not accepted.
     */
    private ZName createCircusName(Decorword decorword)
    {
      // !acceptStrokes => decorword.getStrokes().isEmpty()
      //boolean validStrokes = (acceptStrokes || decorword.getStrokes().isEmpty());
      if (!decorword.getStrokes().isEmpty())
      {
        final Object[] params = { decorword.getWord() };
        parser.report_error(CircusParseMessage.MSG_CIRCNAME_DOESNOT_ALLOW_STROKES,
                            params, decorword.getLocation());
      }
      return createZName(decorword);
    }


    private Operator createOperator(Decorword decorword)
    {
      return createOperator(decorword.getName(), decorword.getLocation());
    }

    private Operator createOperator(String name, LocInfo locInfo)
    {
      final ZName dn = factory_.createZName(name);
      final StrokeList sl = dn.getStrokeList();
      if (sl instanceof List && ((List<?>) sl).size() != 0) {
        final Object[] params = { name };
        parser.report_error(ZParseMessage.MSG_STROKE_IN_OPNAME,
                            params, locInfo);
      }
      Operator result = factory_.createOperator(dn.getWord());
      addLocAnn(result, locInfo);
      return result;
    }

    private void misusedOpName(LocString name)
    {
      final Object [] params = {name.getString()};
      parser.report_error(ZParseMessage.MSG_OPNAME_AS_DECLWORD,
                          params, name.getLocation());
    }

    private LocInfo getLocation(int line, int column)
    {
      return new LocInfoImpl(getDialect(), getLoc(), line, column);
    }

    private LocInfo getLocation(Term term)
    {
      return parser.getLocation(term);
    }

    private OperatorName createOperatorName(List<String> list)
      throws OperatorName.OperatorNameException
    {
      final String errorMessage = list + " is not an operator name (for dialect " + getDialect().toString() + " in Parser).";
      if (list.size() <= 1) {
        throw new OperatorName.OperatorNameException(errorMessage);
      }
      StrokeList strokes = null;
      Boolean expectArgument = null;
      StringBuilder stringBuilder = new StringBuilder();
      for (String opPart : list) {
        if (opPart.equals(ZString.ARG) ||
            opPart.equals(ARG_TOK)) {
          if (Boolean.FALSE.equals(expectArgument)) {
            throw new OperatorName.OperatorNameException(errorMessage);
          }
          stringBuilder.append(ARG_TOK);
          expectArgument = Boolean.FALSE;
        }
        else if (opPart.equals(ZString.LISTARG) ||
                 opPart.equals(LISTARG_TOK)) {
          if (Boolean.FALSE.equals(expectArgument)) {
            throw new OperatorName.OperatorNameException(errorMessage);
          }
          stringBuilder.append(LISTARG_TOK);
          expectArgument = Boolean.FALSE;
        }
        else {
          if (Boolean.TRUE.equals(expectArgument)) {
            throw new OperatorName.OperatorNameException(errorMessage);
          }
          ZName declName = factory_.createZName(opPart);
          stringBuilder.append(declName.getWord());
          if (strokes == null) {
            strokes = declName.getStrokeList();
          }
          else if (! strokes.equals(declName.getStrokeList())) {
            final String message =
              "The component names of an operator must have the " +
              "same decorations (for dialect " + dialect_.toString() + " in Parser).";
            throw new OperatorName.OperatorNameException(message);
          }
          expectArgument = Boolean.TRUE;
        }
      }
      return new OperatorName(stringBuilder.toString(), strokes);
    }

    /**
     * Converts a list of String objects to a Name object.
     * 
     * @param list 
     * @param location 
     * @return
     */
    protected ZName strListToZName(List<String> list,
                                   LocInfo location)
    {
      try {
        OperatorName opName = createOperatorName(list);
        ZName result =
          factory_.createZName(opName.getWord(), opName.getStrokes());
        addLocAnn(result, location);
        return result;
      }
      catch (OperatorName.OperatorNameException e) {
        parser.report_error(ZParseMessage.MSG_OPNAME_ERROR,
                            new Object[] { e.getMessage() },
                            location);
        return null;
      }
    }
    
    /**
     * Converts a name list into a list of strings. This methods is called by complex operator template
     * patterns that eventually call strListToZName(List<String>, LocInfo). Earlier versions of 
     * parser mixed up list of names within the list of strings... This method flattens these names to strings.
     */
    protected List<String> extractNamesFromNameList(List<Name> list)
    {
    	List<String> result = factory_.list();
    	for(Name n : list)
    	{
    		if (n instanceof ZName)
    			result.add(ZUtils.assertZName(n).getWord());
    		
    		else
    			result.add(n.toString());
    	}
    	return result;
    }
    

    protected List<String> toStringList(List<LocString> list)
    {
      List<String> result = new ArrayList<String>(list.size());
      for (LocString ls : list) {
        result.add(ls.getString());
      }
      return result;
    }

    /**
     * Converts a Term to a Pred.
     * 
     * @param t 
     * @return
     */
    protected Pred pred(Term t)
    {
      Pred result = null;

      if (t instanceof Pred) {
        result = (Pred) t;
      }

      else if (t instanceof Expr) {
        result = factory_.createExprPred((Expr) t);
        LocAnn locAnn = (LocAnn) t.getAnn(LocAnn.class);
        if (locAnn != null) result.getAnns().add(locAnn);
      }
      else {
        //I don't think that this is possible...?
        parser.report_error(ZParseMessage.MSG_PRED_EXPECTED,
                            new Object[0], getLocation(t));
      }
      return result;
    }

    /**
     * Converts an Term to an Expr.
     * 
     * @param t 
     * @return
     */
    protected Expr expr(Term t)
    {
      Expr result = null;

      if (t instanceof Expr) {
        result = (Expr) t;
      }
      else if (t instanceof ExprPred) {
        result = ((ExprPred) t).getExpr();
      }

      else if (t instanceof Pred) {

        parser.report_error(ZParseMessage.MSG_EXPR_EXPECTED_FOUND_PRED,
                            new Object [0], getLocation(t));

      }
      else {
        parser.report_error(ZParseMessage.MSG_EXPR_EXPECTED,
                            new Object [0], getLocation(t));
      }
      return result;
    }



    /**
     * Converts a Term to a Name.
     * 
     * @param t 
     * @return 
     */
    protected Name name(Term t)
    {
      if (t instanceof Name) return (Name) t;
      if (t instanceof RefExpr) {
        RefExpr re = (RefExpr) t;
        if (re.getZExprList().size() > 0) {
          parser.report_error(ZParseMessage.MSG_REFNAME_NO_PARAMS_EXPECTED,
                              new Object [0], getLocation(re));
        }
        return re.getName();
      }
      parser.report_error(ZParseMessage.MSG_REFNAME_EXPECTED,
                          new Object [0], getLocation(t));
      return null;
    }

    /**
     * Creates a member predicate from a string list and an expression list.
     * 
     * @param name 
     * @param exprs 
     * @param loc 
     * @return
     */
    protected MemPred createMemPred(List<String> name,
                                    ZExprList exprs,
                                    LocInfo loc)
    {
      Expr e = createTupleExpr(exprs);
      Name rn = strListToZName(name, loc);
      MemPred result = factory_.createRelOpAppl(e, rn);
      addLocAnn(result.getRightExpr(), loc);
      return result;
    }

    /**
     * Creates an application expression or reference expression
     * (depending on the type of operator: function or generic)
     * from a string list and an expression list.
     * The line,column pair are the position of the start of
     * the whole mixfix expression.
     * 
     * @param name 
     * @param exprs 
     * @param loc 
     * @return
     */
    protected Expr createMixfixExpr(List<String> name,
                                    ZExprList exprs,
                                    LocInfo loc)
    {
      final Name rn = strListToZName(name, loc);
      Expr result = null;

      // TODO: then do what with it? firstOperator is never used.
      //
      //get the first operator in the name list, i.e. the first
      //item that is not an ARG_TOK or LISTARG_TOK.
      //String firstOperator = null;
      //for (String next : name) {
      //  if (! next.equals(ARG_TOK) && ! next.equals(LISTARG_TOK)) {
      //    firstOperator = next;
      //    break;
      //  }
      //}

      if (opTable_.lookup(name) != null &&
          Cat.Function.equals(opTable_.lookup(name).getCat())) {
        Expr e = createTupleExpr(exprs);
        result = factory_.createFunOpAppl(rn, e);
        addLocAnn(((ApplExpr) result).getLeftExpr(), loc);
      }
      else {
        result = factory_.createRefExpr(rn, exprs, Boolean.TRUE, Boolean.TRUE);
      }

      return result;
    }

    /**
     * If the list contains just one expression, the expression is
     * returned.  If there is more than one expression in the list, a
     * tuple expression is created and returned.
     * 
     * @param exprs 
     * @return
     */
    private Expr createTupleExpr(ZExprList exprs)
    {
      return exprs.size() == 1 ?
        exprs.get(0) : factory_.createTupleExpr(exprs);
    }

    /**
     * Returns the right hand side of the previous infix relation.
     * 
     * @param pred 
     * @return
     */
    protected Expr getPreviousRhsExpr(Pred pred)
    {
      Expr result = null;

      MemPred memPred = null;
      if (pred instanceof MemPred) {
        memPred = (MemPred) pred;
      }
      else {   //AndPred
        memPred = (MemPred) ((AndPred) pred).getRightPred();
      }

      //if the previous infix is a mem pred
      if (memPred.getMixfix().equals(Boolean.FALSE)) {
        result = memPred.getRightExpr();
      }
      //if the previous infix is an equals
      else if (memPred.getMixfix().equals(Boolean.TRUE) &&
               memPred.getRightExpr() instanceof SetExpr) {
        SetExpr se = (SetExpr) memPred.getRightExpr();
        result = se.getZExprList().get(0);
      }
      //if the previous infix is an IP
      else {
        TupleExpr te = (TupleExpr) memPred.getLeftExpr();
        result = te.getZExprList().get(1);
      }

      return result;
    }

    /**
     * Convert a chain relation into a series of and predicates
     * (transformation rule 12.2.10.3).
     * 
     * @param chain 
     * @param sym 
     * @param rhs 
     * @param loc 
     * @return
     */
    protected Pred transformChainRel(Pred chain, int sym, Expr rhs,
                                     LocInfo loc)
    {
      Pred result = null;

      Expr lExpr = getPreviousRhsExpr(chain);
      Expr rExpr = rhs;

      Boolean mixfix = Boolean.FALSE;
      if (sym == Sym.EQUALS) {
        ZExprList expList = factory_.createZExprList();
        expList.add(rhs);
        rExpr = factory_.createSetExpr(expList);
        addLocAnn(rExpr, loc);
        mixfix = Boolean.TRUE;
      }

      MemPred mp = factory_.createMemPred(lExpr, rExpr, mixfix);
      addLocAnn(mp, loc);
      result = factory_.createAndPred(chain, mp, And.Chain);
      return result;
    }

    protected Pred transformChainRelInfix(Pred chain, Expr rhs, String ip,
                                          LocInfo loc)
    {
      Pred result = null;

      List<String> opName = factory_.list(ARG_TOK);
      opName.add(ip);
      opName.add(ARG_TOK);

      Expr lExpr = getPreviousRhsExpr(chain);
      Expr rExpr = rhs;
      ZExprList exprs = factory_.createZExprList();
      exprs.add(lExpr);
      exprs.add(rExpr);
      MemPred mp = createMemPred(opName, exprs, loc);
      addLocAnn(mp, loc);
      result = factory_.createAndPred(chain, mp, And.Chain);
      return result;
    }

    /**
     * Creates a list of strings for a list returned by expSep.
     * This list will represent the name of the operator to which
     * the expressions were applied.
     * 
     * @param opName 
     * @param es
     */
    protected void addExpSepName(List<String> opName, List<?> es)
    {
      for (int i = 0; i < es.size(); i += 2) {

        List<?> list = (List<?>) es.get(i);
        if (list.size() == 1) {
          opName.add(ARG_TOK);
        }
        else {
          opName.add(LISTARG_TOK);
        }
        opName.add((String) es.get(i + 1));
      }
    }

    /**
     * Returns the list of expressions returned by expSep.
     * 
     * @param expList 
     * @param es 
     */
    @SuppressWarnings({ "unchecked", "rawtypes" })
    protected void addExpSepExp(List<? extends Object> expList, List<Object> es)
    {
      for (int i = 0; i < es.size(); i += 2) {
      	// exprList is always called as ZExprList; but es can have expr or strings. argh... TODO: fix types?
        expList.addAll((List) es.get(i));
      }
    }
    
    private void resetInfoTables(String section, List<Parent> parents,
                                 int line, int column)
      throws Exception
    {
      
      // use the cyclic manager to get valid parents avoiding cyclic recursion
      CyclicParseManager cyclicMan = CyclicParseManager.getManager(sectInfo_);
      List<Parent> validParents = cyclicMan.getValidParents(section, parents); 
      try
      {
        // to enable proper transaction scopes within the section manager,
        // we MUST adhere to the most natural dependency ordering between
        // any info table involved. 
        // the one we choose was: 
        //  [ProofTable] dependsOn ThmTble dependsOn [JokerTble] dependsOn OpTable
        //
        //
        // ahhh, but there is the possibility of unrecovered errors or syntax errors
        // or indeed scanning errors. In that case, we would need a catch for closing/cancelling
        // the transactions. Instead then, we decided to end the transaction with a empty
        // info table that gets filled along the way during parsing. If such errors occur,
        // then upon removing the ZSect involved, we know that the dependant tables get
        // removed as well becuase they explicitly depend on the ZSect.
        // So order here of resetXXXTable doesn't matter.

        resetOpTable(section, validParents, line, column);
        resetThmTable(section, validParents, line, column);

        
      } finally {
        // mark section inactive and report cycles
        List<List<String>> cycles = cyclicMan.visitedParents(section);
        for (List<String> cycle : cycles) {
          // report found cycles, if any, as warnings
          reportParentCycle(cycle, parents);
        }
      }
      
    }
    
    private void reportParentCycle(List<String> cycle, List<Parent> parents)
    {
      Pair<String, String> render = CyclicParseManager.renderParseParentCycle(cycle);
      String cycleParent = render.getFirst();
      String cycleStr = render.getSecond();
      
      boolean found = false;
      for (Parent parent : parents) {
        if (cycleParent.equals(parent.getWord())) {
          // found the parent - report cycle with its location as a warning
          CyclicParentError.reportCyclicParent(sectInfo_, source_, cycleStr, getLocation(parent));
          found = true;
          // do not break, because several parents with the same name could be
          // listed - we need to report the same cycle for all of them
        }
      }
      
      if (!found) {
        // no applicable parent found? 
        // still report - using dummy location
        CyclicParentError.reportCyclicParent(sectInfo_, source_, cycleStr, 
            new LocInfoImpl(getDialect(), source_.getName(), 0, 0));
      }
    }
    
    /**
     * Starts a transaction for the info table. Also calculates parent info tables and returns
     * them. This means that parent info tables become implicit dependencies for this info table.
     * 
     * @param section
     * @param parents
     * @param line
     * @param column
     * @param tableKey
     * @param tableLabel
     * @return
     */
    private <T> List<T> startInfoTableTransaction(String section, List<Parent> parents, 
        int line, int column, Key<T> tableKey, String tableLabel)
    {
      /*
       * Start the transaction for the info table. Parent calculations later will start their own
       * transactions (via {@code SectionInfo.get()}), thus nesting transactions and dependencies.
       * We assume here, that the parent cycles have been resolved.
       */
      sectInfo_.startTransaction(tableKey);
  
      List<T> parentInfoTables = factory_.list();
      if (Section.PRELUDE.getName().equals(section)) {
        assert parents.isEmpty();
      }
      else {
        for (Parent parent : parents) {
          
          // For each parent, resolve their info table and use it to create the current one.
          // Note that if problems occur in parents, the error is reported, but parsing continues.
          try 
          {
            // will have a transaction on the inner/parent table
            T parentInfoTable = sectInfo_.get(new Key<T>(parent.getWord(), tableKey.getType()));
            parentInfoTables.add(parentInfoTable);
          }
          catch (CommandException e) {
            Object [] args = { tableLabel, section, e.getMessage() };
            parser.report_error(ZParseMessage.MSG_OF_PARENT_NOT_FOUND,
                                args, new LocInfoImpl(getDialect(), getLoc(), line, column));
          }
        }
      }
      
      return parentInfoTables;
    }
    
    /**
     * End the transaction for the info table calculation in the Section Manager. The transaction is
     * ended immediately after calculation of the info table. It is then populated with contents
     * during the actual parsing. This means that the info table can be empty when first put in the
     * section manager, and filled with content later. Such approach is necessary to ensure correct
     * transactions in the section manager. Otherwise, parsing of different info tables can overlap,
     * and transactions would fail.
     * <p>
     * To accommodate for the short-circuiting of the info table transactions, we add an explicit
     * dependency on the ZSect for the info table. This is to signal that the ZSect may contain
     * contents for the info table, e.g. operator definitions.
     * </p>
     * <p>
     * The same approach (end transaction after initial resolution of an object) is used for
     * LatexMarkupFunction computation. This is necessary because of a complicated parsing protocol,
     * and is a compromise to achieve transactional structure to some level. Otherwise the
     * transactions would overlap. To achieve better confidence in the dependencies, some
     * dependencies are added explicitly (e.g. that info table depends on its ZSect).
     * </p>
     * 
     * @param section
     * @param tableKey
     * @param infoTable
     */
    private <T> void endInfoTableTransaction(String section, Key<T> tableKey, T infoTable)
    {
      sectInfo_.endTransaction(tableKey, infoTable,
          Collections.singleton(new Key<ZSect>(section, ZSect.class)));
    }
    
    /**
     * Marks the given key of the info table computation as a dependency for the parsed section. 
     * This is used to implicitly include the dependency on an info table, e.g. if it is used to
     * interpret/generate the subsequent contents of the Z section. For example, OpTable is used
     * in the operator scanner, so we mark this dependency. This should be done for all info
     * tables that have bi-directional dependency with the ZSect, e.g. OpTable, JokerTable. The
     * ThmTable, though, is not used by the parser, so it should not be a dependency for the ZSect.
     * 
     * @param section 
     * @param tableKey
     * @return 
     */
    private <T> T markInfoTableDependency(String section, Key<T> tableKey) {
      try
      {
        // mark the implicit dependency via SectionInfo.get(), 
        // because we are inside a ZSect transaction
        return sectInfo_.get(tableKey);
      }
      catch (CommandException e)
      {
        // should never happen - we have just put the table into the manager
        final String message = "Could not retrieve " + tableKey.getType().getSimpleName() 
            + " for " + section + " that has just been calculated?! (for dialect " 
            + getDialect().toString() + " in Parser).";
        throw new CztException(message, e);
      }
    }
    
    private void resetOpTable(String section, List<Parent> parents,
                              int line, int column)
    {
      Key<OpTable> optKey = new Key<OpTable>(section, OpTable.class);
      
      // start the transaction and collect parent tables
      List<OpTable> parentOpTables = startInfoTableTransaction(
          section, parents, line, column, optKey, "Operator table");
      
      OpTable opTable = new OpTable(getDialect(), section);
      try {
        opTable.addParents(parentOpTables);
      }
      catch (InfoTable.InfoTableException e) {
        parser.report_error(ZParseMessage.MSG_CANNOT_MERGE_OPTABLES, 
            new Object[]{e.getMessage()},
            getLocation(line, column));
      }
  
      // end the transaction with the non-null value
      endInfoTableTransaction(section, optKey, opTable);
      
      opTable_ = opTable;
      
      // mark the OpTable dependency for the ZSect, because it is used in the operator scanner 
      markInfoTableDependency(section, optKey);
      opScanner_.setOperatorTable(opTable_);
    }
    
    private void resetThmTable(String section, List<Parent> parents,
                              int line, int column)
    {
      Key<ThmTable> thmKey = new Key<ThmTable>(section, ThmTable.class);
      
      // start the transaction and collect parent tables
      List<ThmTable> parentThmTables = startInfoTableTransaction(
          section, parents, line, column, thmKey, "Named conjectures table");
      
      ThmTable thmTable = new ThmTable(getDialect(), section);
      try {
        thmTable.addParents(parentThmTables);
      }
      catch (InfoTable.InfoTableException e) {
        parser.report_error(ZParseMessage.MSG_CANNOT_MERGE_THMTABLES, 
            new Object[]{e.getMessage()},
            getLocation(line, column));
      }
  
      // end the transaction with the non-null value
      endInfoTableTransaction(section, thmKey, thmTable);
      
      thmTable_ = thmTable;
    }



    /**
     * Starts the Z section computation transaction in the Section Manager. The transaction allows to
     * capture the dependencies of the ZSect - e.g. that it depends on its OpTable, and transitively
     * on parent OpTables and ZSects.
     * <p>
     * The ZSect transaction must be started manually, because the parsing is done for the whole
     * specification. So the section manager can start a transaction on the Spec, however inside the
     * specification, there can be multiple Z sections. Thus transactions for each ZSect are started
     * and ended manually, during the parse process.
     * </p>
     * <p>
     * The start of transaction handles issues with redeclared sections as well. See
     * {@link #endZSectTransaction(ZSect, OpTable)} for more details about the ZSect transaction and
     * explicit dependencies.
     * </p>
     * <p>
     * When the manual transaction starts, we need to ensure that any exceptions until the end of
     * transaction are caught and handled. If an exception is encountered, the ZSect transaction must
     * be cancelled. This is done in {@link Parser#parse()} method, which is the single entry point to
     * parsing.
     * </p>
     * 
     * @param sectName
     * @see #endZSectTransaction(ZSect, OpTable)
     */
    private void startZSectTransaction(String sectName)
    {
      Key<ZSect> zsKey = new Key<ZSect>(sectName, ZSect.class);
       
      /*
       * There may be cases when the Z section is calculated already at the start of transaction.
       * Sometimes it can be because of the pollution of section manager (SM) from previous runs -
       * this should have been removed before running the parsing again. Polluted section managers
       * should generally be caught by other transactions, so it is not that important to be strict
       * about existing objects in SM cache here.
       *
       * However, there are cases when we can encounter this case in a single specification
       * (RedeclaredSection). The parser is required to parse such specification without errors, and
       * leave the check for the typechecker. Thus there is parsing of two identical section names
       * (and therefore keys). For this case - when we encounter the second (redeclared) section, we
       * remove the ZSect from SM if it is already cached, and start a new transaction for its
       * calculation. We will have a case when the second ZSect "overwrites" the first ZSect via
       * remove-endTransaction.
       * 
       * If we do not do such "overwriting", we would have needed to make the RedeclaredSection a
       * parsing error and stop parsing altogether (e.g. via Exception). Current solution allows us to
       * finish parsing and postpone the check to typechecker.
       */
      if (sectInfo_.isCached(zsKey))
      {
        sectInfo_.removeKey(zsKey);
      }
       
      /*
       * Force start the transaction - we cannot have it started already. The parsing could not have
       * started with a ZSect transaction, because parsing encompasses the whole Spec (even if it has
       * a single ZSect). So the outer transaction must be that of a Spec, and we should not have an
       * existing transaction on ZSect. Therefore do a strict startTransaction(), instead of
       * ensureTransaction().
       * 
       * Note if parsing is started using SectionInfo#get(ZSect), the original ZSect transaction is
       * postponed in favor of the Spec transaction (see ParseUtils for details).
       */
       
      sectInfo_.startTransaction(zsKey);
    }

    private ZSect createZSect(String name, List<Parent> parents)
    {
      parserState_.setCurrentSectName(name);
      ZParaList paraList = factory_.createZParaList();
      ZSect result = factory_.createZSect(name, parents, paraList);
      return result;
    }
    
    /**
     * Ends the transaction for Z section calculation in the Section Manager. The computed ZSect
     * receives final adjustments - its operators are reordered according to their precedence, and the
     * LatexMarkupFunction is added as a LatexMarkupPara to the section. The Z section transaction is
     * ended, and the section is added to the section manager.
     * 
     * @param zSect
     *          The Z section to end transaction
     * @param opTable 
     *          The operator table to determine operator precedences
     * @return The updated Z section (may be the same object)
     * @see #startZSectTransaction(String)
     */
    private ZSect endZSectTransaction(ZSect zSect, OpTable opTable)
    {
      final boolean parseError = parser.hasErrors();
      final String sectName = zSect.getName();
  
      // reorder the Z section in correct operator precedence
      final PrecedenceHandlingVisitor visitor = new PrecedenceHandlingVisitor(opTable);
      final ZSect sect = (ZSect) zSect.accept(visitor);

      // Add the LatexMarkupFunction as a LatexMarkupPara to the ZSect.
      // Note, that this will add implicit dependency on LMF, if it is available
      addLatexMarkupPara(sect, sectName);

      
      // Add implicit process paragraphs to the ZSect term.
      ZUtils.assertZParaList(sect.getParaList()).addAll(parserState_.getImplicitlyDeclProcPara());
//      System.out.println("Printing " + sect.getPara().size() + " paragraphs from " + 
//         sect.getName() + " for " + getDialect().toString() + " in Parser.");
//      for(Para para : sect.getPara()) {
//        System.out.println("\t" + para.toString());
//      }
//      System.out.println();

      
      Key<ZSect> zsKey = new Key<ZSect>(sectName, ZSect.class);
  
      if (!parseError) {

        /*
         * End the ZSect transaction. The parser may carry explicit dependencies to add for the ZSect.
         * This allows indicating some dependencies that could have been missed since ZSect
         * transaction is started later in the parsing, e.g. that ZSect depends on its Source, or has
         * a bi-directional dependency with its Spec.
         * 
         * ZSect also depends on its LatexMarkupFunction, OpTable and JokerTable. Actually, dependencies 
         * with these objects are bi-directional (they also depend on the ZSect). These dependencies are
         * implicitly captured (see #resetOpTable(), addLatexMarkupPara(), etc.), so there is no need to
         * add them explicitly.
         */
        sectInfo_.endTransaction(zsKey, sect, parser.getExplicitDeps());
      }
      else {
        // in case of parsing errors, cancel the transaction
        sectInfo_.cancelTransaction(zsKey);
      }
      return sect;
    }

    /**
     * Adds the computed LatexMarkupFunction for the Z section, if available, as a LatexMarkupPara to
     * the section.
     * 
     * @param sect
     * @param sectName
     */
    private void addLatexMarkupPara(ZSect sect, String sectName)
    {
      Key<LatexMarkupFunction> key = new Key<LatexMarkupFunction>(sectName, LatexMarkupFunction.class);
      if (sectInfo_.isCached(key)) {
        try {
  
          /*
           * Note that this SectionInfo#get(LMF) call will add dependency on the LMF to the ZSect.
           * This is good, because it indicates the dependency implicitly, which may have been missed
           * since LatexMarkupParser executes before Parsing (and ZSect transaction) even starts.
           */
          LatexMarkupFunction latexMarkupFunction = sectInfo_.get(key);
  
          /*
           * During lexing, the LatexMarkupFunction for this ZSect may have been calculated, which
           * contains LaTeX markup directives within the section. These directives are added to the
           * front of the Z section as a LatexMarkupPara. If no directives exist, a LatexMarkupPara
           * with empty directives list is added.
           */
          LatexMarkupPara markupPara = latexMarkupFunction.toAst(factory_);
          ZUtils.assertZParaList(sect.getParaList()).add(0, markupPara);
  
        }
        catch (CommandException exception) {
          String message = "Error retrieving LatexMarkupFunction for section " + sectName + " and dialect " + exception.getDialect().toString() + 
          	" in Parser for " + getDialect().toString();
          CztLogger.getLogger(Parser.class).warning(message);
        }
      }
    }


    protected String getLoc()
    {
      return parserState_.getLoc();
    }

    private void addLocAnn(Term term, LocInfo locInfo)
    {
      parserState_.addLocAnn(term, locInfo);
    }

    //private void addZStateRefInfo(Term term, Ann ozsi, Name n)
    //{
    //   if (ozsi != null)
    //   {
    //      if (ozsi instanceof ZRefinesAnn)
    //        ((ZRefinesAnn)ozsi).setConcreteName(n);
    //      term.getAnns().add(ozsi);
    //   }
    //}

    private int computeLength(LocInfo start, LocInfo end)
    {
      final int startStart = start.getStart();
      final int endStart = end.getStart();
      final int endLength = end.getLength();
      if (startStart >= 0 &&
          endStart >= 0 &&
          endLength >= 0) {
        return endStart - startStart + endLength;
      }
      return -1;
    }

    private LocInfo getLocation(LocInfo start, LocInfo end)
    {
      if (start != null && end != null) {
        return new LocInfoImpl(getDialect(),
        											 start.getSource(),
                               start.getLine(),
                               start.getColumn(),
                               start.getStart(),
                               computeLength(start, end));
      }
      return null;
    }

    private LocInfo getLocation(Term start, LocInfo end)
    {
      return getLocation(getLocation(start), end);
    }

    private LocInfo getLocation(LocInfo start, Term end)
    {
      return getLocation(start, getLocation(end));
    }

    private LocInfo getLocation(Term start, Term end)
    {
      return getLocation(getLocation(start), getLocation(end));
    }

    private LocInfo getLocation(int line, int column,
                                LocInfo start, LocInfo end)
    {
      if (start != null && end != null) {
        return new LocInfoImpl(getDialect(),
        											 start.getSource(),
                               line,
                               column,
                               start.getStart(),
                               computeLength(start, end));
      }
      return null;
    }

    private LocInfo getLocation(int line, int column,
                                Term start, LocInfo end)
    {
      return getLocation(line, column, getLocation(start), end);
    }

    

    private LocInfo getLocation(int line, int column,
                                Term start, Term end)
    {
      return getLocation(line, column, getLocation(start), getLocation(end));
    }

    private LocInfo getLocation(List<LocString> list)
    {
      if (list != null && list.size() > 0) {
        if (list.size() == 1) return list.get(0).getLocation();
        return getLocation(list.get(0).getLocation(),
                           list.get(list.size() - 1).getLocation());
      }
      return null;
    }


    /**
     * Creates an empty (basic) channel set expression
     */
    protected Expr createEmptyChannelSetExpr(LocInfo loc)
    {
      Expr result = factory_.createBasicChannelSetExpr(factory_.createCircusCommunicationList());
      addLocAnn(result, loc);
      return result;
    }

    /**
     * Creates an empty channel set (i.e. ChannelSet with an empty basic channel set expression).
     */
    protected ChannelSet createEmptyChannelSet(LocInfo loc)
    {
      ChannelSet result = factory_.createCircusChannelSet(factory_.createSetExpr(factory_.createZExprList()));
      addLocAnn(result, loc);
      return result;
    }

    /**
     * Creates an empty name set (i.e. NameSet with an empty set expression).
     */
    protected NameSet createEmptyNameSet(LocInfo loc) {
      NameSet result = factory_.createCircusNameSet(factory_.createSetExpr(factory_.createZExprList()));
      addLocAnn(result, loc);
      return result;
    }

    /**
     * <p>
     * This method characterises parameterised commands and actions according to the
     * expected (specific and disjoint) structure both have, yet they share the same
     * AST class due to their similar nature and to minimize AST numbers. This choice
     * is similar to AxPara in Z, which represents various Z boxes.
     * </p>
     * <p>
     * The protocol is as follows: parameterised commands MUST have a CircusCommand
     * as its inner term, and VarDecl and QualifiedDecl are allowed; whereas parameterised
     * actions have a CircusAction as its inner term, and only VarDecl is allowed.
     * </p>
     */
    protected ParamAction createParamAction(CircusAction pa, DeclList cp)
    {
      // if this is not a qualified command, then check for non VarDecl elements
      if (cp instanceof ZDeclList)
      {
        int vDecls = 0;
        int qDecls = 0;
        int otherDecls = 0;
        for(Decl d : ZUtils.assertZDeclList(cp))
        {
          if (d instanceof VarDecl)
            vDecls++;
          else if (d instanceof QualifiedDecl)
            qDecls++;
          else
            otherDecls++;
        }
        // otherDecls = 0 AND (vDecls = 0 IMPlIES qDecls = 0 AND otherDecls = 0) AND
        // (qDecls = 0 IMPlIES vDecls = 0 AND otherDecls = 0) AND (vDecls+qDecls+otherDecls = cp.size())
        boolean declOk = ((otherDecls == 0 && (vDecls == 0 || qDecls == 0)) &&
          ZUtils.assertZDeclList(cp).size() == (vDecls+qDecls+otherDecls));
        if (!declOk)
        {
          parser.report_error(CircusParseMessage.MSG_ERRORDECL_IN_PARAMACTION, new Object[0], getLocation(cp));
        }
      }
      ParamAction result = factory_.createParamAction(pa, cp);
      return result;
    }

    /**
     * Returns whether the given expression is an empty set as a reference to
     * <code>ZString.EMPTYSET</code>.
     */
    protected boolean isEmptySetRefExpr(Expr a) {
      return ZUtils.isEmptySetRefExpr(a);
    }

    /**
     * <p>
     * Creates a <code>BasicChannelSetExpr</code> based on the given list of expressions.
     * </p>
     * <p>
     * The code ensures that all expressions within the expression list
     * must be <code>RefExpr</code>, as <code>BasicChannelSetExpr</code>
     * is just a set extension with special brackets.
     * </p>
     * <p>
     * If something different from <code>RefExpr</code> is found within <code>zrl</code>,
     * the a parsing error is thrown and the result is just an empty <code>BasicChannelSetExpr</code>.
     * </p>
     */
    protected Expr createBasicChannelSetExpr(LocInfo loc, List<Communication> cl) {
//      //assert zrl != null && !zrl.isEmpty();
//      int errorIdx = 0;
//      Iterator<Expr> it = zrl.iterator();
//      while(it.hasNext()) {
//        // If any item at a particular index is not a RefExpr,
//        // return the error index and stop the loop.
//        if (!(it.next() instanceof RefExpr)) {
//          break;
//        }
//        else
//          errorIdx++;
//      }
//
//      BasicChannelSetExpr result = factory_.createBasicChannelSetExpr(factory_.createZExprList());
//      if (loc != null) { addLocAnn(result, loc); }
//
//      int size = zrl.size();
//
//      if (errorIdx >= size) {
//        result.getZExprList().addAll(zrl);
//      } else {
//        boolean isEmpty = zrl.isEmpty();
//        assert errorIdx >= 0 && (errorIdx < size || isEmpty);
//        CztLogger.getLogger(Parser.class).warning(java.text.MessageFormat.format(
//            CircusParseMessage.MSG_REFEXPR_EXPECPTED_IN_BASICCHANNELSETEXPR_WARNING.getMessage(),
//            new Object[] { errorIdx, size-1, isEmpty ? "empty" : zrl.get(errorIdx),
//              isEmpty ? "null" : zrl.get(errorIdx).getClass().getSimpleName(), loc }) 
//							+ " for dialect " + getDialect().toString() + " in Parser.");
//      }
      BasicChannelSetExpr result = factory_.createBasicChannelSetExpr(factory_.createCircusCommunicationList(cl));
      if (loc != null) { addLocAnn(result, loc); }
      return result;
    }

    /**
     * <p>
     * Validates the given Z expression as a valid channel set expression.
     * </p>
     * <p>
     * The code returns the given expression but it ensures that <code>e</code>
     * is neither a set extension, nor a set comprehension expression.
     * If <code>e</code> is one of those two, then a parsing error is thrown.
     * </p>
     * <p>
     * Moreover, it automatically transforms a reference to the empty set expression
     * (i.e. <code>\emptyset</code>) to become an empty <code>BasicChannelSetExpr</code>.
     * Thus, something like <code>validateChannelSetExpr(RefExpr("\emptyset"))</code>,
     * returns <code>BasicChannelSetExpr(ZExprList())</code>.
     * </p>
     */
    protected Expr validateChannelSetExpr(Expr e) {
      Expr result = e;
      
      // For reference empty sets transform them into basic set extension.
      if (isEmptySetRefExpr(result)) {
        result = createBasicChannelSetExpr(getLocation(e), factory_.<Communication>list());
      }
      // For set extensions (possibly empty) or comprehension, report an error.
      else if (result instanceof SetExpr || result instanceof SetCompExpr){
        parser.report_error(CircusParseMessage.MSG_SETDISPLAY_NOTALLOWED_FORCHANNELSET,
                            new Object[0], getLocation(result));
      }
      return result;
    }

    /**
     * Checks whether the given lists have the same size. It returns a parser error if the
     * lists are of a different size. This method is called either through channel renaming or
     * an assignment command.
     */
    protected boolean checkListSizesAreEqual(LocInfo loc,
        List<?> l, List<?> r) {
        boolean result = l.size() == r.size();
        if (!result) {
          parser.report_error(CircusParseMessage.MSG_UNBALANCED_LISTS,
              new Object[] { l.size(), l.getClass().getTypeParameters()[0].getName(),
                  r.size(), r.getClass().getTypeParameters()[0].getName() }, loc);
        }
        return result;
    }

    /**
     * Creates an <code>AssignmentPairs</code> class containing the LHS and RHS
     * elements for each list, which must have the same size. If the lists are not of the same
     * size, the returned list is empty and a parsing error is generated.
     */
    protected AssignmentPairs createAssignmentPairs(LocInfo loc,
        ZNameList rnl, ZExprList el) {
        AssignmentPairs result = factory_.createAssignmentPairs();
        if (checkListSizesAreEqual(loc, rnl, el)) {
          result.setLHS(rnl);
          result.setRHS(el);
        }
        if (rnl.isEmpty()) {
          parser.report_error(CircusParseMessage.MSG_EMPTY_ASSIGNMENT,
              new Object[0], loc);
        }
        addLocAnn(result, loc);
        return result;
    }

    /**
     * Creates an <code>AssignmentPairs</code> class containing the LHS and RHS
     * elements for each list, which must have the same size and must only contain <code>RefExpr</code>.
     * If the lists are not of the same size, the returned list is empty and a parsing error
     * is generated.
     */
    protected AssignmentPairs createChannelRenamingPairs(LocInfo loc,
        ZNameList rnl, ZExprList el) {
        AssignmentPairs result = createAssignmentPairs(loc, rnl, el);
        int i = 0;
        for(Expr e : el) {
          if (!(e instanceof RefExpr)) {
            parser.report_error(CircusParseMessage.MSG_INVALID_CHANNEL_RENAMING_EXPR,
              new Object[] { rnl.get(i), i+1, e.getClass().getSimpleName() }, loc);
          }
          i++;
        }
        addLocAnn(result, loc);
        return result;
    }

    /**
     * Creates a unique name for implicitly declared actions located
     * at the given term.
     */
    protected Decorword createImplicitlyDeclActUniqueName(Term term)
    {
      LocInfo loc = getLocation(term);
      String name = parserState_.createImplicitlyDeclActUniqueName(loc);
      return new Decorword(name, loc);
    }

    /**
     * Creates a unique name for implicitly declared processes located
     * at the given term.
     */
    protected Decorword createImplicitlyDeclProcUniqueName(Term term)
    {
      LocInfo loc = getLocation(term);
      String name = parserState_.createImplicitlyDeclProcUniqueName(loc);
      return new Decorword(name, loc);
    }

    /**
     * Creates an implicit action paragraph with location annotation for the given name and action.
     */
    protected ActionPara createImplicitActionPara(Decorword an, CircusAction ca) {
        ActionPara ap = factory_.createActionPara(createCircusName(an),  ca);
        addLocAnn(ap, getLocation(an.getLocation(), ca));
        return ap;
    }

    /**
     * Creates an implicit process paragraph with location annotation for the given name and action.
     */
    protected ProcessPara createImplicitProcessPara(Decorword pn, CircusProcess pp) {
        /* On-the-fly process have no generic formals/actuals*/
        ProcessPara pa = factory_.createProcessPara(createCircusName(pn), factory_.createZNameList(), pp);
        addLocAnn(pa, getLocation(pn.getLocation(), pp));
        return pa;
    }

    protected Para createStatePara(Name n, Expr e, LocInfo loc, boolean implicitlyDeclared)
    {
       // check if the state is duplicated and raise the error
       checkForDuplicatedState((implicitlyDeclared ? "implicitly declared" : "horizontally declared"), loc);

       // create the state para.
       Para result = parserState_.createStatePara(n, e, loc, implicitlyDeclared);
       checkCircusStateAnnParaIsSchema(result);

       // set the result to the parser state
       parserState_.setStatePara(result);

       return result;
    }

    protected void setMainAction(CircusAction mainAction, LocInfo loc)
    {
       checkForDuplicatedMainAction(loc);
       parserState_.setMainAction(mainAction);
    }

    /**
     * Checks whether the given predicate is a schema.
     * If the paragraph is not a schema, an error is reported.
     */
    /* NOTE: As we now managed to accept the expression production for state
     *       schemas without trouble then this is no longer a problem.
     *       The extra check is harmless though.
     */
    protected boolean checkCircusStateAnnParaIsSchema(Para p) {
      // call the CircusUtils version of isSchema to include Schema Actions
      boolean result = parserState_.isValidStatePara(p);
      if (!result) {
         parser.report_error(CircusParseMessage.MSG_INVALID_BASICPROCESS_STATE_PARA,
               new Object[0], getLocation(p));
      }
      return result;
    }

    /**
     * Checks <code>BasicProcess</code> paragraphs for repeated state annotations.
     * That is, if the given paragraph corresponds to a <code>BasicProcess</code>,
     * and the user has declared more than one state schemas, an error is reported.
     * ? TODO: CHECK if deprecated now that we have a robust parserState_ for basic process' scope.
     */
    protected void checkStateDeclNotRepeated(ProcessPara pp) {
      if (pp.getCircusProcess() instanceof BasicProcess) {
        BasicProcess bp = (BasicProcess)pp.getCircusProcess();

        // Collect all paragraphs annotated with CircusStateAnn.
        ZParaList stateParaList = getCircusStateAnnPara(bp);

        // If more than one state has been declared, then raise the error.
        // The message will contain the process name and the first violating
        // state, which is the second one (of the possibly many) declared.
        if (stateParaList.size() > 1) {
          parser.report_error(CircusParseMessage.MSG_DUPLICATE_PROC_STATE_DECL,
              new Object[] { pp.getName(), CircusUtils.getSchemaName(stateParaList.get(0)),
                  stateParaList.size(), CircusUtils.getSchemaName(stateParaList.get(1)), getLocation(pp, stateParaList.get(1)) },
                  getLocation(pp, stateParaList.get(1)));
        }
        // Otherwise, it is fine, either we have one or no state declaration.
      }
    }

    protected boolean checkProcessParaScope(LocInfo loc) {
       boolean result = parserState_.getProcessPara() != null;
       if (!result) {
          parser.report_error(CircusParseMessage.MSG_INVALID_MULTIENV_BASIC_PROCESS_CIRCEND,
                new Object[] {loc} , loc);
       }
       return result;
    }

    protected boolean checkForDuplicatedState(String msg, LocInfo loc) {
      boolean result = parserState_.getStatePara() == null;
      CztLogger.getLogger(Parser.class).fine("DUPLICATED STATE PARA (" +
            msg + ")?: " + !result + " @ " + loc.toString() + " for " + getDialect().toString() + " in Parser.");
      if (!result) {
         parser.report_error(CircusParseMessage.MSG_DUPLICATED_BASIC_PROCESS_STATE,
               new Object[] { msg, loc} , loc);
      }
      return result;
    }

    protected boolean checkForDuplicatedMainAction(LocInfo loc) {
      boolean result = parserState_.getMainAction() == null;
      CztLogger.getLogger(Parser.class).fine("DUPLICATED MAIN ACTION? :" + 
      	!result + " @ " + loc.toString() + " for " + getDialect().toString() + " in Parser.");
      if (!result) {
         parser.report_error(CircusParseMessage.MSG_DUPLICATED_BASIC_PROCESS_MAINACTION, new Object[0], loc);
      }
      return result;
    }

    /**
     * Adds a <code>ParenAnn</code> annotation to the given term, where the given locations
     * are for the left and right parenthesis respectively.
     */
    protected void addParenthesisAnn(LocInfo lp, Term t, LocInfo rp) {
       ParenAnn parenAnn = factory_.createParenAnn();
       addLocAnn(parenAnn, getLocation(lp, rp));
       t.getAnns().add(parenAnn);
    }

    /**
     * Flattens all paragraphs from the given list of <code>ZParaList</code>
     * and then keep those that are annotated with <code>CircusStateAnn</code>.
     */
    protected ZParaList getCircusStateAnnPara(ZParaList... lists) {
        // Create a list with all paragraphs from the lists.
        ZParaList result = factory_.createZParaList();
        for(ZParaList zpl : lists) {
          result.addAll(zpl);
        }

        // Search the complete list and remove all non-state para.
        for(Iterator<Para> it = result.iterator(); it.hasNext(); ) {
          Para p = it.next();
          // If we have an annotation, check it is valid.
          //if (p.getAnn(CircusStateAnn.class) != null) {
          //  checkCircusStateAnnParaIsSchema(p);
          //}
          // Otherwise just remove them
          //else
          if (p.getAnn(CircusStateAnn.class) == null) {
            it.remove();
          }
        }
        return result;
    }

    /**
     * Retrieves all paragraphs within the given <code>BasicProcess</code>
     * that are annotated with <code>CircusStateAnn</code>. This includes
     * both local declarations and on-the-fly actions.
     */
    protected ZParaList getCircusStateAnnPara(BasicProcess bp) {
      return getCircusStateAnnPara(factory_.createZParaList(bp.getLocalPara()),
          factory_.createZParaList(bp.getOnTheFlyPara()));
    }

    protected Model validateModel(Decorword dw) {
      Model result = CircusUtils.DEFAULT_REFINEMENT_MODEL;
      if (dw.toString().toUpperCase().equals(Model.Tr.toString().toUpperCase()))
        result = Model.Tr;
      else if (dw.toString().toUpperCase().equals(Model.SFl.toString().toUpperCase()))
        result = Model.SFl;
      else if (dw.toString().toUpperCase().equals(Model.FlDv.toString().toUpperCase()))
        result = Model.FlDv;
      else {
        parser.report_error(CircusParseMessage.MSG_UNKNOWN_REFINEMENT_MODEL,
              new Object[] { dw.getWord() }, dw.getLocation());
      }
      return result;
    }

    private void warnProcessScopeMismatch(String msg, String from, LocInfo l) {
        final String msg2 = java.text.MessageFormat.format(
                CircusParseMessage.MSG_INVALID_BASIC_PROCESS_SCOPE_WARNING.getMessage(),
                new Object[] { msg, from, l.toString() }) + " for " + getDialect().toString() + " in Parser.";
        CztLogger.getLogger(Parser.class).warning(msg2);
        parserState_.addProcessScopeWarning(msg2, l);
    }

    private void warnProcessScopeMissing(String msg, String from, LocInfo l) {
        from = "(" + from + ")" + " outside basic process scope";
        final String msg2 = java.text.MessageFormat.format(
                CircusParseMessage.MSG_OUTSITE_BASIC_PROCESS_SCOPE_WARNING.getMessage() +
                CircusParseMessage.MSG_OUTSITE_BASIC_PROCESS_SCOPE_WARNING.getExplanation(),
                new Object[] { msg, from, l }) + " for " + getDialect().toString() + " in Parser.";
        CztLogger.getLogger(Parser.class).warning(msg2);
        parserState_.addProcessScopeWarning(msg2, l);
    }

    /**
     * <p>
     * Checks whether there is a basic process in current scope, adding a
     * parsing warning with the given extra msg and location information in
     * case there is no process into scope.
     * </p>
     * <p>
     * This warning ought to be taken seriously, since type checking will
     * simply assume the inner process paragraph (declared outside a process)
     * is included into the closest enclosing basic process.
     * </p>
     * The warning are collected within the parser state and are raised
     * when the parsing task terminates at specification production.
     * <p>
     */
    protected boolean addBasicProcessScopePostCheckFor(String msg, LocInfo l) {
        boolean result = parserState_.isWithinMultipleEnvBasicProcessScope();
        CztLogger.getLogger(Parser.class).fine("ADDING PROCESS SCOPE POST CHECK FOR " +
            msg + "?: " + !result + " @ " + l.toString() + " for " + getDialect().toString() + " in Parser.");
        if (!result) {
            final String msg2 = "Cannot declare " + msg;
            parserState_.addProcessScopeWarning(msg2, l);
        }
        return result;
    }

    /** Adds a warning for the case where circend is missing */
    protected void addMultipleEnvBasicProcessCIRCENDWarning(Name procName, LocInfo loc) {
        CztLogger.getLogger(Parser.class).fine(
            "ADDING PROCESS SCOPE POST CHECK FOR MULTIPLE ENV CIRCEND? : true @ "
            + loc.toString() + " for " + getDialect().toString() + " in Parser.");
        parserState_.addProcessEndWarning(procName, loc);
    }

    /** Removes warning for the case where circend is missing if procName match */
    protected void removeMultipleEnvBasicProcessCIRCENDWarning(LocInfo circEndLoc) {
        Pair<Name, LocInfo> pew = parserState_.getProcessEndWarning();

        // we are at multiple environment situation and found a CIRCEND
        if (pew != null) {
            assert checkProcessParaScope(pew.getSecond()) :
                "Cannot remove CIRCEND warning outside a process para scope";
            if (parserState_.getProcessPara().getName().equals(pew.getFirst())) {
                CztLogger.getLogger(Parser.class).fine(
                    "FOUND MATCHING CIRCEND FOR " + pew.getFirst() + " @ CIRCEND-LOC " +
                    circEndLoc.toString() + " for " + getDialect().toString() + " in Parser.");
                parserState_.clearSectBasicProcessEndWarning();
            } else {
                CztLogger.getLogger(Parser.class).warning(java.text.MessageFormat.format(
                    CircusParseMessage.MSG_PROCESS_PARA_NAME_MISMATCH_FOR_CIRCEND_WARNIING.getMessage() +
                    CircusParseMessage.MSG_PROCESS_PARA_NAME_MISMATCH_FOR_CIRCEND_WARNIING.getExplanation(),
                    new Object[] { pew.getFirst(), parserState_.getProcessPara().getName(),
                      pew.getSecond(), circEndLoc }) + " for " + getDialect().toString() + " in Parser.");
            }
        }
    }

    protected void raisePendingBasicProcessWarnings(String from) {
        raisePendingBasicProcessWarnings(from, "outside basic process scope");
    }

    protected void raisePendingBasicProcessWarnings(String from, String msg) {
        CztLogger.getLogger(Parser.class).fine("PENDING PROCESS SCOPE WARNINGS (" + from +
            ") AFTER POST CHECK: " + parserState_.getProcessScopeWarnings().size()
            + " for " + getDialect().toString() + " in Parser.");
        for(Pair<String, LocInfo> p : parserState_.getProcessScopeWarnings()) {
            parser.report_error(CircusParseMessage.MSG_OUTSITE_BASIC_PROCESS_SCOPE_WARNING,
               new Object[] { p.getFirst(), msg, p.getSecond() }, p.getSecond());
        }
        parserState_.clearSectBasicProcessScopeWarnings();

        Pair<Name, LocInfo> pew = parserState_.getProcessEndWarning();
        CztLogger.getLogger(Parser.class).fine("PENDING PROCESS CIRCEND WARNING (" + from +
            ") AFTER POST CHECK?: " + (pew != null) + " for " + getDialect().toString() + " in Parser.");
        if (pew != null) {
            parser.report_error(CircusParseMessage.MSG_MISSING_BASIC_PROCESS_CIRCEND,
                new Object[] { pew.getFirst(), pew.getSecond() }, pew.getSecond());
        }
        parserState_.clearSectBasicProcessEndWarning();
    }

    /** Ensures the list of collected paragraphs is the same the one into parserState_ */
    protected boolean ensureInnerProcParaListKnownInBasicProcessScope(List<Para> ipl, String from, LocInfo loc) {
        boolean result = parserState_.isWithinMultipleEnvBasicProcessScope() &&
            parserState_.isKnownPara(ipl);
        CztLogger.getLogger(Parser.class).fine("ENSURING PARAGRAPH CONTAINMENT (" + from + ")?: " + result
            + " @ " + loc + " for " + getDialect().toString() + " in Parser.");
        if (!result) {
            parser.report_error(CircusParseMessage.MSG_FAIL_CHECK_INNER_PROC_ELEM_BASIC_PROC_SCOPE,
              new Object[] { loc }, loc);
        }
        return result;
    }

    /** Create an empty basic process and sets the parser state valure for it */
    protected BasicProcess createMockBasicProcessFor(String from, LocInfo l) {
       BasicProcess result = factory_.createBasicProcess(factory_.createZParaList());
       addLocAnn(result, l);
       CztLogger.getLogger(Parser.class).finer("CREATING BASICPROCESS => " + from +
           " @ " + l + "\n" + result + " for " + getDialect().toString() + " in Parser.");
       parserState_.setBasicProcess(result);
       if (!parserState_.isWithinMultipleEnvBasicProcessScope()) {
            warnProcessScopeMismatch("open", from, l);
       }
       return result;
    }

    /**
     * Enters a basic process scope within the parser state, giving a parser
     * error in case of nested process scopes. It assumes the BasicProcess
     * already has location information calculated.
     */
    protected boolean enterBasicProcessScope(String from, LocInfo l) {
        boolean result = parserState_.enterBasicProcessScope(l);
        CztLogger.getLogger(Parser.class).finer("ENTERING PROCESS SCOPE: " + result
            + " from " + from + " @ " + l + " for " + getDialect().toString() + " in Parser.");
        if (!result) {
            parser.report_error(CircusParseMessage.MSG_DUPlICATED_BASIC_PROCESS_SCOPE,
              new Object[] { from, l } , l);
        }
        return result;
    }

    /**
     * Enters a basic process scope within the parser state, giving a parser
     * error in case of nested process scopes. It assumes the BasicProcess
     * already has location information calculated.
     */
    protected boolean exitBasicProcessScope(String from, LocInfo l) {
        CztLogger.getLogger(Parser.class).finer("EXITING PROCESS SCOPE: " +
            parserState_.isWithinMultipleEnvBasicProcessScope() +
            " from " + from + " @ " + l + "\n" + parserState_.getBasicProcess()
						+ " for " + getDialect().toString() + " in Parser.");

        // Clears: the implicitly declared actions and their name seed;
        // the current main action, the current basic process, and the
        // list of locally declared paragraphs. It also clears the process scope
        parserState_.clearBasicProcessInformation();

        boolean result = parserState_.exitBasicProcessScope();
        if (!result) {
            warnProcessScopeMismatch("closing", from, l);
        }
        return result;
    }

    protected boolean updateBasicProcessInformation(String from, LocInfo loc) {
        CztLogger.getLogger(Parser.class).finer("BEFORE UPDATE BASIC PROCESS INFORMATION");

        ParserState.BasicProcessUpdate bpUpdate = parserState_.updateBasicProcessInformation();
        boolean result = bpUpdate.equals(ParserState.BasicProcessUpdate.BP_OK);

        CztLogger.getLogger(Parser.class).finer("AFTER UPDATE BASIC PROCESS INFORMATION");
        CztLogger.getLogger(Parser.class).finer("UPDATE BASIC PROCESS INFORMATION: " +
            result + " from " + from + " @ " + loc + "\n" +
            parserState_.getProcessPara() + " for " + getDialect().toString() + " in Parser.");

        if (!result) {
            warnProcessScopeMissing("update local structures " + bpUpdate + " ", from, loc);
            if (bpUpdate.equals(ParserState.BasicProcessUpdate.DUPLICATED_STATE))
            {
              parser.report_error(CircusParseMessage.MSG_DUPLICATED_BASIC_PROCESS_STATE,
                new Object[] { from, loc} , loc);
            }
            else if (bpUpdate.equals(ParserState.BasicProcessUpdate.DUPLICATED_MAIN_ACTION))
            {
              parser.report_error(CircusParseMessage.MSG_DUPLICATED_BASIC_PROCESS_MAINACTION, new Object[0], loc);
            }
        }
        return result;
    }

    /**
     * This method is called whenever the calling production result is related to
     * a list of paragraphs, where the current one is a ProcessPara. On these conditions,
     * it might be possible to have implicitly declared processes (i.e., those declared
     * on the fly by the current process para) to consider. So, we add all pending ones
     * at this point, and clear the implicitly declared process paragraph buffer.
     */
    protected void addImplicitlyDeclaredProcPara(List<Para> result)
    {
      if (!parserState_.getImplicitlyDeclProcPara().isEmpty())
      {
        result.addAll(parserState_.getImplicitlyDeclProcPara());
        parserState_.clearSectProcessOnTheFlyCache();
      }
    }



    // could be useful for other parsers as well
    protected void logProductionResult(Object term, String from, LocInfo loc) {
        CztLogger.getLogger(Parser.class).fine("PRODUCTION RESULT: " +
            " from " + from + " @ " + loc + "=>\n" + term
            + " for " + getDialect().toString() + " in Parser.");
    }

  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 515: // optNL ::= NL 
            {
               CUP$Parser$result = case515(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 514: // optNL ::= 
            {
               CUP$Parser$result = case514(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 513: // expSep ::= expSep expressionList SS 
            {
               CUP$Parser$result = case513(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 512: // expSep ::= expSep term ES 
            {
               CUP$Parser$result = case512(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 511: // expSep ::= 
            {
               CUP$Parser$result = case511(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 510: // nofixApp ::= L expSep optExpressionList SR 
            {
               CUP$Parser$result = case510(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 509: // nofixApp ::= L expSep term ER 
            {
               CUP$Parser$result = case509(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 508: // infixApp ::= term EL expSep optExpressionList SRE term 
            {
               CUP$Parser$result = case508(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 507: // infixApp ::= term EL expSep term ERE term 
            {
               CUP$Parser$result = case507(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 506: // infixApp ::= term I term 
            {
               CUP$Parser$result = case506(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 505: // postfixApp ::= term EL expSep optExpressionList SR 
            {
               CUP$Parser$result = case505(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 504: // postfixApp ::= term EL expSep term ER 
            {
               CUP$Parser$result = case504(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 503: // postfixApp ::= term POST 
            {
               CUP$Parser$result = case503(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 502: // prefixApp ::= L expSep optExpressionList SRE term 
            {
               CUP$Parser$result = case502(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 501: // prefixApp ::= L expSep term ERE term 
            {
               CUP$Parser$result = case501(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 500: // prefixApp ::= PRE term 
            {
               CUP$Parser$result = case500(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 499: // application ::= infixApp 
            {
               CUP$Parser$result = case499(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 498: // application ::= postfixApp 
            {
               CUP$Parser$result = case498(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 497: // application ::= prefixApp 
            {
               CUP$Parser$result = case497(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 496: // nofixRel ::= LP expSep optExpressionList SRP 
            {
               CUP$Parser$result = case496(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 495: // nofixRel ::= LP expSep term ERP 
            {
               CUP$Parser$result = case495(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 494: // infixChainRel ::= infixChainRel IP term 
            {
               CUP$Parser$result = case494(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 493: // infixChainRel ::= infixChainRel EQUALS term 
            {
               CUP$Parser$result = case493(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 492: // infixChainRel ::= infixChainRel MEM term 
            {
               CUP$Parser$result = case492(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 491: // infixChainRel ::= term IP term 
            {
               CUP$Parser$result = case491(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 490: // infixChainRel ::= term EQUALS term 
            {
               CUP$Parser$result = case490(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 489: // infixChainRel ::= term MEM term 
            {
               CUP$Parser$result = case489(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 488: // infixRel ::= term ELP expSep optExpressionList SREP term 
            {
               CUP$Parser$result = case488(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 487: // infixRel ::= term ELP expSep term EREP term 
            {
               CUP$Parser$result = case487(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 486: // infixRel ::= infixChainRel 
            {
               CUP$Parser$result = case486(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 485: // postfixRel ::= term ELP expSep optExpressionList SRP 
            {
               CUP$Parser$result = case485(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 484: // postfixRel ::= term ELP expSep term ERP 
            {
               CUP$Parser$result = case484(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 483: // postfixRel ::= term POSTP 
            {
               CUP$Parser$result = case483(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 482: // prefixRel ::= LP expSep optExpressionList SREP term 
            {
               CUP$Parser$result = case482(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 481: // prefixRel ::= LP expSep term EREP term 
            {
               CUP$Parser$result = case481(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 480: // prefixRel ::= PREP term 
            {
               CUP$Parser$result = case480(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 479: // relation ::= infixRel 
            {
               CUP$Parser$result = case479(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 478: // relation ::= postfixRel 
            {
               CUP$Parser$result = case478(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 477: // relation ::= prefixRel 
            {
               CUP$Parser$result = case477(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 476: // rename ::= declName SLASH refName 
            {
               CUP$Parser$result = case476(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 475: // zRenameList ::= rename 
            {
               CUP$Parser$result = case475(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 474: // zRenameList ::= zRenameList COMMA rename 
            {
               CUP$Parser$result = case474(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 473: // renameList ::= zRenameList 
            {
               CUP$Parser$result = case473(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 472: // stroke ::= NUMSTROKE 
            {
               CUP$Parser$result = case472(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 471: // stroke ::= NEXTSTROKE 
            {
               CUP$Parser$result = case471(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 470: // stroke ::= OUTSTROKE 
            {
               CUP$Parser$result = case470(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 469: // stroke ::= INSTROKE 
            {
               CUP$Parser$result = case469(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 468: // letDefinition ::= declName DEFEQUAL expression 
            {
               CUP$Parser$result = case468(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 467: // letDefinitionList ::= letDefinition 
            {
               CUP$Parser$result = case467(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 466: // letDefinitionList ::= letDefinitionList SEMICOLON letDefinition 
            {
               CUP$Parser$result = case466(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 465: // constDeclList ::= constDecl 
            {
               CUP$Parser$result = case465(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 464: // constDeclList ::= constDeclList COMMA constDecl 
            {
               CUP$Parser$result = case464(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 463: // optConstDeclList ::= constDeclList 
            {
               CUP$Parser$result = case463(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 462: // optConstDeclList ::= 
            {
               CUP$Parser$result = case462(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 461: // expressionList ::= expression 
            {
               CUP$Parser$result = case461(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 460: // expressionList ::= expressionList COMMA expression 
            {
               CUP$Parser$result = case460(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 459: // optExpressionList ::= expressionList 
            {
               CUP$Parser$result = case459(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 458: // optExpressionList ::= 
            {
               CUP$Parser$result = case458(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 457: // prodExpressionList ::= prodExpressionList CROSS term 
            {
               CUP$Parser$result = case457(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 456: // prodExpressionList ::= term CROSS term 
            {
               CUP$Parser$result = case456(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 455: // appendage ::= DOT NUMERAL 
            {
               CUP$Parser$result = case455(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 454: // appendage ::= DOT refName 
            {
               CUP$Parser$result = case454(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 453: // appendage ::= LSQUARE renameList RSQUARE 
            {
               CUP$Parser$result = case453(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 452: // appendage ::= stroke 
            {
               CUP$Parser$result = case452(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 451: // appendageList ::= appendage 
            {
               CUP$Parser$result = case451(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 450: // appendageList ::= appendageList appendage 
            {
               CUP$Parser$result = case450(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 449: // optAppendageList ::= 
            {
               CUP$Parser$result = case449(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 448: // optAppendageList ::= appendageList 
            {
               CUP$Parser$result = case448(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 447: // inner_term ::= FALSE 
            {
               CUP$Parser$result = case447(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 446: // inner_term ::= TRUE 
            {
               CUP$Parser$result = case446(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 445: // inner_term ::= refName 
            {
               CUP$Parser$result = case445(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 444: // inner_term ::= LPAREN septerm RPAREN 
            {
               CUP$Parser$result = case444(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 443: // inner_term ::= NUMERAL 
            {
               CUP$Parser$result = case443(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 442: // inner_term ::= inner_term LSQUARE renameList RSQUARE 
            {
               CUP$Parser$result = case442(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 441: // inner_term ::= inner_term LSQUARE expressionList RSQUARE 
            {
               CUP$Parser$result = case441(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 440: // inner_term ::= inner_term LSQUARE schemaTextNoExpression RSQUARE optAppendageList 
            {
               CUP$Parser$result = case440(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 439: // inner_term ::= THETA inner_term 
            {
               CUP$Parser$result = case439(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 438: // inner_term ::= inner_term stroke 
            {
               CUP$Parser$result = case438(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 437: // inner_term ::= inner_term DOT NUMERAL 
            {
               CUP$Parser$result = case437(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 436: // inner_term ::= inner_term DOT refName 
            {
               CUP$Parser$result = case436(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 435: // inner_term ::= LSQUARE schemaTextNoExpression RSQUARE 
            {
               CUP$Parser$result = case435(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 434: // inner_term ::= LSQUARE RSQUARE 
            {
               CUP$Parser$result = case434(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 433: // inner_term ::= LBIND optConstDeclList RBIND 
            {
               CUP$Parser$result = case433(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 432: // inner_term ::= nofixApp 
            {
               CUP$Parser$result = case432(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 431: // inner_term ::= nofixRel 
            {
               CUP$Parser$result = case431(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 430: // inner_term ::= LPAREN MU schemaText RPAREN 
            {
               CUP$Parser$result = case430(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 429: // inner_term ::= LPAREN expressionList COMMA expression RPAREN 
            {
               CUP$Parser$result = case429(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 428: // inner_term ::= LBRACE schemaTextNoExpression RBRACE 
            {
               CUP$Parser$result = case428(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 427: // inner_term ::= LBRACE schemaText SPOT expression RBRACE 
            {
               CUP$Parser$result = case427(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 426: // inner_term ::= LBRACE optExpressionList RBRACE 
            {
               CUP$Parser$result = case426(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 425: // func_appl ::= inner_term 
            {
               CUP$Parser$result = case425(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 424: // func_appl ::= func_appl inner_term 
            {
               CUP$Parser$result = case424(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 423: // communicationList ::= communication 
            {
               CUP$Parser$result = case423(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 422: // communicationList ::= communicationList COMMA communication 
            {
               CUP$Parser$result = case422(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 421: // term ::= LCIRCCHANSET RCIRCCHANSET 
            {
               CUP$Parser$result = case421(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 420: // term ::= LCIRCCHANSET communicationList RCIRCCHANSET 
            {
               CUP$Parser$result = case420(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 419: // term ::= func_appl 
            {
               CUP$Parser$result = case419(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 418: // term ::= application 
            {
               CUP$Parser$result = case418(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 417: // term ::= relation 
            {
               CUP$Parser$result = case417(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 416: // term ::= prodExpressionList 
            {
               CUP$Parser$result = case416(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 415: // term ::= POWER term 
            {
               CUP$Parser$result = case415(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 414: // term ::= ZPRE term 
            {
               CUP$Parser$result = case414(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 413: // term ::= term ZPROJ term 
            {
               CUP$Parser$result = case413(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 412: // term ::= term ZHIDE LPAREN refNameList RPAREN 
            {
               CUP$Parser$result = case412(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 411: // term ::= term ZPIPE term 
            {
               CUP$Parser$result = case411(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 410: // term ::= term ZCOMP term 
            {
               CUP$Parser$result = case410(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 409: // term ::= NOT term 
            {
               CUP$Parser$result = case409(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 408: // term ::= term AND term 
            {
               CUP$Parser$result = case408(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 407: // term ::= term OR term 
            {
               CUP$Parser$result = case407(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 406: // term ::= term IMP term 
            {
               CUP$Parser$result = case406(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 405: // term ::= term IFF term 
            {
               CUP$Parser$result = case405(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 404: // term ::= LET letDefinitionList SPOT term 
            {
               CUP$Parser$result = case404(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 403: // term ::= MU schemaText SPOT term 
            {
               CUP$Parser$result = case403(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 402: // term ::= LAMBDA schemaText SPOT term 
            {
               CUP$Parser$result = case402(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 401: // term ::= EXIONE schemaText SPOT term 
            {
               CUP$Parser$result = case401(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 400: // term ::= EXI schemaText SPOT term 
            {
               CUP$Parser$result = case400(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 399: // term ::= ALL schemaText SPOT term 
            {
               CUP$Parser$result = case399(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 398: // term ::= IF predicate THEN term ELSE term 
            {
               CUP$Parser$result = case398(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 397: // septerm ::= term 
            {
               CUP$Parser$result = case397(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 396: // septerm ::= septerm sep term 
            {
               CUP$Parser$result = case396(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 395: // expression ::= term 
            {
               CUP$Parser$result = case395(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 394: // predicate ::= term 
            {
               CUP$Parser$result = case394(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 393: // predicate ::= predicate sep term 
            {
               CUP$Parser$result = case393(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 392: // erOrSr ::= SR 
            {
               CUP$Parser$result = case392(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 391: // erOrSr ::= ER 
            {
               CUP$Parser$result = case391(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 390: // ereOrSre ::= SRE 
            {
               CUP$Parser$result = case390(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 389: // ereOrSre ::= ERE 
            {
               CUP$Parser$result = case389(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 388: // esOrSs ::= SS 
            {
               CUP$Parser$result = case388(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 387: // esOrSs ::= ES 
            {
               CUP$Parser$result = case387(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 386: // optNameEsSsList ::= optNameEsSsList name esOrSs 
            {
               CUP$Parser$result = case386(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 385: // optNameEsSsList ::= 
            {
               CUP$Parser$result = case385(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 384: // nofixGenName ::= L optNameEsSsList name erOrSr 
            {
               CUP$Parser$result = case384(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 383: // infixGenName ::= name EL optNameEsSsList name ereOrSre name 
            {
               CUP$Parser$result = case383(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 382: // infixGenName ::= name I name 
            {
               CUP$Parser$result = case382(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 381: // postfixGenName ::= name EL optNameEsSsList name erOrSr 
            {
               CUP$Parser$result = case381(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 380: // postfixGenName ::= name POST 
            {
               CUP$Parser$result = case380(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 379: // prefixGenName ::= L optNameEsSsList name ereOrSre name 
            {
               CUP$Parser$result = case379(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 378: // prefixGenName ::= PRE name 
            {
               CUP$Parser$result = case378(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 377: // genName ::= nofixGenName 
            {
               CUP$Parser$result = case377(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 376: // genName ::= infixGenName 
            {
               CUP$Parser$result = case376(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 375: // genName ::= postfixGenName 
            {
               CUP$Parser$result = case375(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 374: // genName ::= prefixGenName 
            {
               CUP$Parser$result = case374(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 373: // argErpOrSrp ::= LISTARG SRP 
            {
               CUP$Parser$result = case373(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 372: // argErpOrSrp ::= ARG ERP 
            {
               CUP$Parser$result = case372(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 371: // argErOrSr ::= LISTARG SR 
            {
               CUP$Parser$result = case371(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 370: // argErOrSr ::= ARG ER 
            {
               CUP$Parser$result = case370(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 369: // argErepOrSrep ::= LISTARG SREP 
            {
               CUP$Parser$result = case369(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 368: // argErepOrSrep ::= ARG EREP 
            {
               CUP$Parser$result = case368(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 367: // argEreOrSre ::= LISTARG SRE 
            {
               CUP$Parser$result = case367(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 366: // argEreOrSre ::= ARG ERE 
            {
               CUP$Parser$result = case366(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 365: // argEsOrSs ::= LISTARG SS 
            {
               CUP$Parser$result = case365(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 364: // argEsOrSs ::= ARG ES 
            {
               CUP$Parser$result = case364(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 363: // optVargEsSsList ::= optVargEsSsList argEsOrSs 
            {
               CUP$Parser$result = case363(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 362: // optVargEsSsList ::= 
            {
               CUP$Parser$result = case362(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 361: // nofixName ::= LP optVargEsSsList argErpOrSrp 
            {
               CUP$Parser$result = case361(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 360: // nofixName ::= L optVargEsSsList argErOrSr 
            {
               CUP$Parser$result = case360(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 359: // infixName ::= varg ELP optVargEsSsList argErepOrSrep varg 
            {
               CUP$Parser$result = case359(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 358: // infixName ::= varg EL optVargEsSsList argEreOrSre varg 
            {
               CUP$Parser$result = case358(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 357: // infixName ::= varg IP varg 
            {
               CUP$Parser$result = case357(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 356: // infixName ::= varg I varg 
            {
               CUP$Parser$result = case356(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 355: // postfixName ::= varg ELP optVargEsSsList argErpOrSrp 
            {
               CUP$Parser$result = case355(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 354: // postfixName ::= varg EL optVargEsSsList argErOrSr 
            {
               CUP$Parser$result = case354(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 353: // postfixName ::= varg POSTP 
            {
               CUP$Parser$result = case353(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 352: // postfixName ::= varg POST 
            {
               CUP$Parser$result = case352(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 351: // prefixName ::= LP optVargEsSsList argErepOrSrep varg 
            {
               CUP$Parser$result = case351(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 350: // prefixName ::= L optVargEsSsList argEreOrSre varg 
            {
               CUP$Parser$result = case350(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 349: // prefixName ::= PREP varg 
            {
               CUP$Parser$result = case349(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 348: // prefixName ::= PRE varg 
            {
               CUP$Parser$result = case348(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 347: // opName ::= nofixName 
            {
               CUP$Parser$result = case347(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 346: // opName ::= infixName 
            {
               CUP$Parser$result = case346(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 345: // opName ::= postfixName 
            {
               CUP$Parser$result = case345(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 344: // opName ::= prefixName 
            {
               CUP$Parser$result = case344(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 343: // refName ::= LPAREN opName RPAREN 
            {
               CUP$Parser$result = case343(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 342: // refName ::= FIELDNAME 
            {
               CUP$Parser$result = case342(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 341: // refName ::= DECORWORD 
            {
               CUP$Parser$result = case341(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 340: // refNameList ::= DECORWORD 
            {
               CUP$Parser$result = case340(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 339: // refNameList ::= refNameList COMMA DECORWORD 
            {
               CUP$Parser$result = case339(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 338: // declName ::= opName 
            {
               CUP$Parser$result = case338(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 337: // declName ::= name 
            {
               CUP$Parser$result = case337(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 336: // misusedOpName ::= SS 
            {
               CUP$Parser$result = case336(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 335: // misusedOpName ::= ES 
            {
               CUP$Parser$result = case335(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 334: // misusedOpName ::= SRE 
            {
               CUP$Parser$result = case334(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 333: // misusedOpName ::= SREP 
            {
               CUP$Parser$result = case333(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 332: // misusedOpName ::= ERE 
            {
               CUP$Parser$result = case332(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 331: // misusedOpName ::= EREP 
            {
               CUP$Parser$result = case331(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 330: // misusedOpName ::= SR 
            {
               CUP$Parser$result = case330(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 329: // misusedOpName ::= SRP 
            {
               CUP$Parser$result = case329(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 328: // misusedOpName ::= ER 
            {
               CUP$Parser$result = case328(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 327: // misusedOpName ::= ERP 
            {
               CUP$Parser$result = case327(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 326: // misusedOpName ::= EL 
            {
               CUP$Parser$result = case326(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 325: // misusedOpName ::= ELP 
            {
               CUP$Parser$result = case325(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 324: // misusedOpName ::= L 
            {
               CUP$Parser$result = case324(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 323: // misusedOpName ::= LP 
            {
               CUP$Parser$result = case323(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 322: // misusedOpName ::= I 
            {
               CUP$Parser$result = case322(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 321: // misusedOpName ::= IP 
            {
               CUP$Parser$result = case321(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 320: // misusedOpName ::= POST 
            {
               CUP$Parser$result = case320(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 319: // misusedOpName ::= POSTP 
            {
               CUP$Parser$result = case319(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 318: // misusedOpName ::= PRE 
            {
               CUP$Parser$result = case318(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 317: // misusedOpName ::= PREP 
            {
               CUP$Parser$result = case317(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 316: // declWordList ::= misusedOpName 
            {
               CUP$Parser$result = case316(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 315: // declWordList ::= DECLWORD 
            {
               CUP$Parser$result = case315(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 314: // declWordList ::= opName 
            {
               CUP$Parser$result = case314(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 313: // declWordList ::= declWordList COMMA misusedOpName 
            {
               CUP$Parser$result = case313(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 312: // declWordList ::= declWordList COMMA opName 
            {
               CUP$Parser$result = case312(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 311: // declWordList ::= declWordList COMMA DECLWORD 
            {
               CUP$Parser$result = case311(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 310: // name ::= DECORWORD 
            {
               CUP$Parser$result = case310(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 309: // nameList ::= DECORWORD 
            {
               CUP$Parser$result = case309(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 308: // nameList ::= nameList COMMA DECORWORD 
            {
               CUP$Parser$result = case308(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 307: // sep ::= NL 
            {
               CUP$Parser$result = case307(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 306: // sep ::= SEMICOLON 
            {
               CUP$Parser$result = case306(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 305: // constDecl ::= declName DEFEQUAL expression 
            {
               CUP$Parser$result = case305(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 304: // varDecl ::= declWordList COLON error 
            {
               CUP$Parser$result = case304(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 303: // varDecl ::= declWordList COLON expression 
            {
               CUP$Parser$result = case303(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 302: // basicDeclaration ::= constDecl 
            {
               CUP$Parser$result = case302(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 301: // basicDeclaration ::= varDecl 
            {
               CUP$Parser$result = case301(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 300: // schemaTextNoExpression ::= basicDeclaration 
            {
               CUP$Parser$result = case300(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 299: // schemaTextNoExpression ::= zDeclList sep declaration 
            {
               CUP$Parser$result = case299(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 298: // schemaTextNoExpression ::= optDeclPart BAR predicate 
            {
               CUP$Parser$result = case298(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 297: // declaration ::= expression 
            {
               CUP$Parser$result = case297(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 296: // declaration ::= basicDeclaration 
            {
               CUP$Parser$result = case296(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 295: // zDeclList ::= zDeclList sep declaration 
            {
               CUP$Parser$result = case295(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 294: // zDeclList ::= declaration 
            {
               CUP$Parser$result = case294(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 293: // declPart ::= zDeclList 
            {
               CUP$Parser$result = case293(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 292: // optDeclPart ::= declPart 
            {
               CUP$Parser$result = case292(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 291: // optDeclPart ::= 
            {
               CUP$Parser$result = case291(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 290: // axiomaticSchemaText ::= optDeclPart 
            {
               CUP$Parser$result = case290(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 289: // axiomaticSchemaText ::= optDeclPart BAR predicate 
            {
               CUP$Parser$result = case289(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 288: // schemaText ::= optDeclPart 
            {
               CUP$Parser$result = case288(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 287: // schemaText ::= optDeclPart BAR predicate 
            {
               CUP$Parser$result = case287(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 286: // refines ::= CIRCREFINES DECORWORD 
            {
               CUP$Parser$result = case286(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 285: // refines ::= CIRCREFINES 
            {
               CUP$Parser$result = case285(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 284: // refines ::= EQUALS 
            {
               CUP$Parser$result = case284(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 283: // refines ::= CIRCSIMULATES 
            {
               CUP$Parser$result = case283(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 282: // actionRefPara ::= name CIRCASSERTREF circusAction refines circusAction 
            {
               CUP$Parser$result = case282(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 281: // processRefPara ::= name CIRCASSERTREF process refines process 
            {
               CUP$Parser$result = case281(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 280: // nameSubstitution ::= LSQUARE renameList RSQUARE 
            {
               CUP$Parser$result = case280(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 279: // guardedCommand ::= guard CIRCTHEN circusAction 
            {
               CUP$Parser$result = case279(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 278: // guardedCommands ::= guardedCommand 
            {
               CUP$Parser$result = case278(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 277: // guardedCommands ::= guardedCommands CIRCELSE guardedCommand 
            {
               CUP$Parser$result = case277(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 276: // command ::= LSQUARE predicate RSQUARE 
            {
               CUP$Parser$result = case276(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 275: // command ::= LBRACE predicate RBRACE 
            {
               CUP$Parser$result = case275(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 274: // command ::= PREFIXCOLON LSQUARE predicate COMMA predicate RSQUARE 
            {
               CUP$Parser$result = case274(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 273: // command ::= refNameList PREFIXCOLON LSQUARE predicate COMMA predicate RSQUARE 
            {
               CUP$Parser$result = case273(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 272: // command ::= CIRCVAR circusParamZDeclList CIRCSPOT circusAction 
            {
               CUP$Parser$result = case272(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 271: // command ::= CIRCDO guardedCommands CIRCOD 
            {
               CUP$Parser$result = case271(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 270: // command ::= IF guardedCommands CIRCFI 
            {
               CUP$Parser$result = case270(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 269: // command ::= refNameList CIRCASSIGN expressionList 
            {
               CUP$Parser$result = case269(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 268: // commField ::= CHANNELOUT DECORWORD error END 
            {
               CUP$Parser$result = case268(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 267: // commField ::= CHANNELDOT DECORWORD error END 
            {
               CUP$Parser$result = case267(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 266: // commField ::= CHANNELIN DECORWORD error END 
            {
               CUP$Parser$result = case266(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 265: // commField ::= CHANNELIN FIELDNAME PREFIXCOLON error END 
            {
               CUP$Parser$result = case265(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 264: // commField ::= CHANNELDOT expression 
            {
               CUP$Parser$result = case264(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 263: // commField ::= CHANNELOUT expression 
            {
               CUP$Parser$result = case263(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 262: // commField ::= CHANNELIN FIELDNAME PREFIXCOLON LPAREN predicate RPAREN 
            {
               CUP$Parser$result = case262(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 261: // commField ::= CHANNELIN FIELDNAME 
            {
               CUP$Parser$result = case261(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 260: // commFields ::= commField 
            {
               CUP$Parser$result = case260(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 259: // commFields ::= commFields commField 
            {
               CUP$Parser$result = case259(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 258: // optCommFields ::= 
            {
               CUP$Parser$result = case258(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 257: // optCommFields ::= commFields 
            {
               CUP$Parser$result = case257(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 256: // communication ::= CHANNELERROR error PREFIXTHEN 
            {
               CUP$Parser$result = case256(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 255: // communication ::= CHANNELNAME LSQUARE expressionList RSQUARE commFields 
            {
               CUP$Parser$result = case255(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 254: // communication ::= CHANNELNAME optCommFields 
            {
               CUP$Parser$result = case254(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 253: // guard ::= predicate 
            {
               CUP$Parser$result = case253(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 252: // parenthesisedAction ::= LPAREN circusAction RPAREN channelRenaming 
            {
               CUP$Parser$result = case252(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 251: // parenthesisedAction ::= LPAREN CIRCMU name CIRCSPOT paramAction RPAREN actualParameters 
            {
               CUP$Parser$result = case251(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 250: // parenthesisedAction ::= LPAREN paramAction RPAREN actualParameters 
            {
               CUP$Parser$result = case250(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 249: // parenthesisedAction ::= LPAREN paramAction RPAREN 
            {
               CUP$Parser$result = case249(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 248: // parenthesisedAction ::= LPAREN circusAction RPAREN 
            {
               CUP$Parser$result = case248(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 247: // actionCall ::= DECORWORD 
            {
               CUP$Parser$result = case247(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 246: // actionCall ::= DECORWORD actualParameters 
            {
               CUP$Parser$result = case246(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 245: // cspAction ::= circusAction nameSubstitution 
            {
               CUP$Parser$result = case245(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 244: // cspAction ::= actionCall 
            {
               CUP$Parser$result = case244(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 243: // cspAction ::= communication PREFIXTHEN circusAction 
            {
               CUP$Parser$result = case243(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 242: // cspAction ::= LCIRCGUARD guard RCIRCGUARD ANDALSO circusAction 
            {
               CUP$Parser$result = case242(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 241: // cspAction ::= circusAction CIRCSEQ circusAction 
            {
               CUP$Parser$result = case241(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 240: // cspAction ::= circusAction CIRCINTERRUPT circusAction 
            {
               CUP$Parser$result = case240(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 239: // cspAction ::= circusAction EXTCHOICE circusAction 
            {
               CUP$Parser$result = case239(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 238: // cspAction ::= circusAction INTCHOICE circusAction 
            {
               CUP$Parser$result = case238(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 237: // cspAction ::= circusAction LSQUARE BAR channelSet BAR BAR channelSet BAR RSQUARE circusAction 
            {
               CUP$Parser$result = case237(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 236: // cspAction ::= circusAction LSQUARE nameSet BAR channelSet BAR BAR channelSet BAR nameSet RSQUARE circusAction 
            {
               CUP$Parser$result = case236(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 235: // cspAction ::= circusAction LPAR BAR channelSet BAR RPAR circusAction 
            {
               CUP$Parser$result = case235(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 234: // cspAction ::= circusAction LPAR nameSet BAR channelSet BAR nameSet RPAR circusAction 
            {
               CUP$Parser$result = case234(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 233: // cspAction ::= circusAction INTERLEAVE circusAction 
            {
               CUP$Parser$result = case233(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 232: // cspAction ::= circusAction LINTER nameSet BAR nameSet RINTER circusAction 
            {
               CUP$Parser$result = case232(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 231: // cspAction ::= circusAction CIRCHIDING channelSet 
            {
               CUP$Parser$result = case231(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 230: // cspAction ::= CIRCMU name CIRCSPOT circusAction 
            {
               CUP$Parser$result = case230(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 229: // cspAction ::= CIRCCHAOS 
            {
               CUP$Parser$result = case229(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 228: // cspAction ::= CIRCSTOP 
            {
               CUP$Parser$result = case228(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 227: // cspAction ::= CIRCSKIP 
            {
               CUP$Parser$result = case227(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 226: // circusAction ::= parenthesisedAction 
            {
               CUP$Parser$result = case226(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 225: // circusAction ::= LSCHEXPRACT expression RSCHEXPRACT 
            {
               CUP$Parser$result = case225(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 224: // circusAction ::= command 
            {
               CUP$Parser$result = case224(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 223: // circusAction ::= cspAction 
            {
               CUP$Parser$result = case223(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 222: // paramAction ::= circusParamCommandDeclList CIRCSPOT circusParamCommandDeclList CIRCSPOT circusAction 
            {
               CUP$Parser$result = case222(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 221: // paramAction ::= ZCOMP circusParamDeclList CIRCSPOT circusAction 
            {
               CUP$Parser$result = case221(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 220: // paramAction ::= REPEXTCHOICE circusParamDeclList CIRCSPOT circusAction 
            {
               CUP$Parser$result = case220(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 219: // paramAction ::= REPINTCHOICE circusParamDeclList CIRCSPOT circusAction 
            {
               CUP$Parser$result = case219(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 218: // paramAction ::= LPAR channelSet RPAR circusParamDeclList CIRCSPOT circusAction 
            {
               CUP$Parser$result = case218(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 217: // paramAction ::= LPAR channelSet RPAR circusParamDeclList CIRCSPOT LPAR nameSet RPAR circusAction 
            {
               CUP$Parser$result = case217(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 216: // paramAction ::= REPINTERLEAVE circusParamDeclList CIRCSPOT circusAction 
            {
               CUP$Parser$result = case216(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 215: // paramAction ::= REPINTERLEAVE circusParamDeclList LINTER nameSet RINTER CIRCSPOT circusAction 
            {
               CUP$Parser$result = case215(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 214: // paramAction ::= circusParamCommandDeclList CIRCSPOT circusAction 
            {
               CUP$Parser$result = case214(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 213: // actionDesc ::= circusAction 
            {
               CUP$Parser$result = case213(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 212: // actionDesc ::= paramAction 
            {
               CUP$Parser$result = case212(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 211: // actionDesc ::= DECORWORD channelRenaming 
            {
               CUP$Parser$result = case211(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 210: // actionPara ::= name CIRCDEF actionDesc 
            {
               CUP$Parser$result = case210(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 209: // nameSet ::= expression 
            {
               CUP$Parser$result = case209(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 208: // namesetPara ::= CIRCNAMESET name DEFEQUAL nameSet 
            {
               CUP$Parser$result = case208(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 207: // channelRenaming ::= LCIRCRENAME refNameList CIRCASSIGN expressionList RCIRCRENAME 
            {
               CUP$Parser$result = case207(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 206: // actualIndexes ::= CIRCLINST expressionList CIRCRINST 
            {
               CUP$Parser$result = case206(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // actualParameters ::= LPAREN expressionList RPAREN 
            {
               CUP$Parser$result = case205(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // genericActuals ::= LSQUARE expressionList RSQUARE 
            {
               CUP$Parser$result = case204(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // circusProcessState ::= CIRCSTATE expression 
            {
               CUP$Parser$result = case203(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // circusProcessState ::= CIRCSTATE name DEFEQUAL expression 
            {
               CUP$Parser$result = case202(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // circusBasicProcessMainAction ::= CIRCSPOT circusAction 
            {
               CUP$Parser$result = case201(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // circusBasicProcess ::= CIRCBEGIN circusInnerProcParaList circusBasicProcessMainAction CIRCEND 
            {
               CUP$Parser$result = case200(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // circusBasicProcess ::= CIRCBEGIN circusBasicProcessMainAction CIRCEND 
            {
               CUP$Parser$result = case199(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // circusBasicProcess ::= CIRCBEGIN 
            {
               CUP$Parser$result = case198(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // circusQualifier ::= CIRCVRES 
            {
               CUP$Parser$result = case197(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // circusQualifier ::= CIRCRES 
            {
               CUP$Parser$result = case196(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // circusQualifier ::= CIRCVAL 
            {
               CUP$Parser$result = case195(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // qualifiedDecl ::= circusQualifier circusDeclWordList COLON expression 
            {
               CUP$Parser$result = case194(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // circusParamCommandZDeclList ::= circusParamCommandZDeclList SEMICOLON circusCommandDecl 
            {
               CUP$Parser$result = case193(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // circusParamCommandZDeclList ::= circusCommandDecl 
            {
               CUP$Parser$result = case192(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // circusParamCommandDeclList ::= circusParamCommandZDeclList 
            {
               CUP$Parser$result = case191(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // circusCommandDecl ::= qualifiedDecl 
            {
               CUP$Parser$result = case190(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // circusCommandDecl ::= varDecl 
            {
               CUP$Parser$result = case189(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // circusParamZDeclList ::= circusParamZDeclList sep varDecl 
            {
               CUP$Parser$result = case188(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // circusParamZDeclList ::= varDecl 
            {
               CUP$Parser$result = case187(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // circusParamDeclList ::= circusParamZDeclList 
            {
               CUP$Parser$result = case186(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // parenthesisedProcess ::= LPAREN indexedProcess RPAREN channelRenaming 
            {
               CUP$Parser$result = case185(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // parenthesisedProcess ::= LPAREN paramProcess RPAREN channelRenaming 
            {
               CUP$Parser$result = case184(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // parenthesisedProcess ::= LPAREN process RPAREN channelRenaming 
            {
               CUP$Parser$result = case183(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // parenthesisedProcess ::= formalParameters LPAREN indexedProcess RPAREN genericActuals actualIndexes 
            {
               CUP$Parser$result = case182(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // parenthesisedProcess ::= LPAREN indexedProcess RPAREN actualIndexes 
            {
               CUP$Parser$result = case181(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // parenthesisedProcess ::= LPAREN indexedProcess RPAREN 
            {
               CUP$Parser$result = case180(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // parenthesisedProcess ::= formalParameters LPAREN paramProcess RPAREN genericActuals actualParameters 
            {
               CUP$Parser$result = case179(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // parenthesisedProcess ::= LPAREN paramProcess RPAREN actualParameters 
            {
               CUP$Parser$result = case178(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // parenthesisedProcess ::= LPAREN paramProcess RPAREN 
            {
               CUP$Parser$result = case177(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // parenthesisedProcess ::= LPAREN process RPAREN 
            {
               CUP$Parser$result = case176(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // processCall ::= DECORWORD 
            {
               CUP$Parser$result = case175(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // processCall ::= DECORWORD genericActuals 
            {
               CUP$Parser$result = case174(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // processCall ::= DECORWORD genericActuals actualIndexes 
            {
               CUP$Parser$result = case173(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // processCall ::= DECORWORD actualIndexes 
            {
               CUP$Parser$result = case172(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // processCall ::= DECORWORD genericActuals actualParameters 
            {
               CUP$Parser$result = case171(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // processCall ::= DECORWORD actualParameters 
            {
               CUP$Parser$result = case170(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // process ::= parenthesisedProcess 
            {
               CUP$Parser$result = case169(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // process ::= processCall 
            {
               CUP$Parser$result = case168(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // process ::= process CIRCSEQ process 
            {
               CUP$Parser$result = case167(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // process ::= process EXTCHOICE process 
            {
               CUP$Parser$result = case166(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // process ::= process INTCHOICE process 
            {
               CUP$Parser$result = case165(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // process ::= process LPAR channelSet RPAR process 
            {
               CUP$Parser$result = case164(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // process ::= process INTERLEAVE process 
            {
               CUP$Parser$result = case163(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // process ::= process CIRCHIDING channelSet 
            {
               CUP$Parser$result = case162(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // process ::= circusBasicProcess 
            {
               CUP$Parser$result = case161(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // indexedProcess ::= ZCOMP circusParamDeclList CIRCINDEX error END 
            {
               CUP$Parser$result = case160(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // indexedProcess ::= REPEXTCHOICE circusParamDeclList CIRCINDEX error END 
            {
               CUP$Parser$result = case159(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // indexedProcess ::= REPINTCHOICE circusParamDeclList CIRCINDEX error END 
            {
               CUP$Parser$result = case158(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // indexedProcess ::= REPPARALLEL circusParamDeclList LPAR channelSet RPAR CIRCINDEX error END 
            {
               CUP$Parser$result = case157(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // indexedProcess ::= REPINTERLEAVE circusParamDeclList CIRCINDEX error END 
            {
               CUP$Parser$result = case156(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // indexedProcess ::= circusParamDeclList CIRCINDEX error END 
            {
               CUP$Parser$result = case155(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // indexedProcess ::= ZCOMP circusParamDeclList CIRCINDEX processDesc 
            {
               CUP$Parser$result = case154(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // indexedProcess ::= REPEXTCHOICE circusParamDeclList CIRCINDEX processDesc 
            {
               CUP$Parser$result = case153(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // indexedProcess ::= REPINTCHOICE circusParamDeclList CIRCINDEX processDesc 
            {
               CUP$Parser$result = case152(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // indexedProcess ::= REPPARALLEL circusParamDeclList LPAR channelSet RPAR CIRCINDEX processDesc 
            {
               CUP$Parser$result = case151(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // indexedProcess ::= REPINTERLEAVE circusParamDeclList CIRCINDEX processDesc 
            {
               CUP$Parser$result = case150(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // indexedProcess ::= circusParamDeclList CIRCINDEX processDesc 
            {
               CUP$Parser$result = case149(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // paramProcess ::= ZCOMP circusParamDeclList CIRCSPOT error END 
            {
               CUP$Parser$result = case148(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // paramProcess ::= REPEXTCHOICE circusParamDeclList CIRCSPOT error END 
            {
               CUP$Parser$result = case147(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // paramProcess ::= REPINTCHOICE circusParamDeclList CIRCSPOT error END 
            {
               CUP$Parser$result = case146(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // paramProcess ::= REPPARALLEL circusParamDeclList LPAR channelSet RPAR CIRCSPOT error END 
            {
               CUP$Parser$result = case145(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // paramProcess ::= REPINTERLEAVE circusParamDeclList CIRCSPOT error END 
            {
               CUP$Parser$result = case144(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // paramProcess ::= circusParamDeclList CIRCSPOT error END 
            {
               CUP$Parser$result = case143(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // paramProcess ::= ZCOMP circusParamDeclList CIRCSPOT processDesc 
            {
               CUP$Parser$result = case142(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // paramProcess ::= REPEXTCHOICE circusParamDeclList CIRCSPOT processDesc 
            {
               CUP$Parser$result = case141(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // paramProcess ::= REPINTCHOICE circusParamDeclList CIRCSPOT processDesc 
            {
               CUP$Parser$result = case140(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // paramProcess ::= REPPARALLEL circusParamDeclList LPAR channelSet RPAR CIRCSPOT processDesc 
            {
               CUP$Parser$result = case139(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // paramProcess ::= REPINTERLEAVE circusParamDeclList CIRCSPOT processDesc 
            {
               CUP$Parser$result = case138(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // paramProcess ::= circusParamDeclList CIRCSPOT processDesc 
            {
               CUP$Parser$result = case137(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // processDesc ::= process 
            {
               CUP$Parser$result = case136(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // processDesc ::= indexedProcess 
            {
               CUP$Parser$result = case135(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // processDesc ::= paramProcess 
            {
               CUP$Parser$result = case134(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // processDesc ::= DECORWORD genericActuals channelRenaming 
            {
               CUP$Parser$result = case133(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // processDesc ::= DECORWORD channelRenaming 
            {
               CUP$Parser$result = case132(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // processPara ::= CIRCEND 
            {
               CUP$Parser$result = case131(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // processPara ::= CIRCPROC optFormalParameters name CIRCDEF processDesc 
            {
               CUP$Parser$result = case130(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // channelSet ::= expression 
            {
               CUP$Parser$result = case129(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // channelSetPara ::= CIRCCHANSET optFormalParameters error END 
            {
               CUP$Parser$result = case128(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // channelSetPara ::= CIRCCHANSET optFormalParameters name error END 
            {
               CUP$Parser$result = case127(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // channelSetPara ::= CIRCCHANSET optFormalParameters name DEFEQUAL error END 
            {
               CUP$Parser$result = case126(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // channelSetPara ::= CIRCCHANSET optFormalParameters name DEFEQUAL channelSet 
            {
               CUP$Parser$result = case125(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // channelFromDecl ::= optFormalParameters DECORWORD 
            {
               CUP$Parser$result = case124(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // channelFromDecl ::= optFormalParameters DECORWORD genericActuals 
            {
               CUP$Parser$result = case123(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // channelDecl ::= circusDeclWordList error END 
            {
               CUP$Parser$result = case122(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // channelDecl ::= circusDeclWordList COLON error END 
            {
               CUP$Parser$result = case121(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // channelDecl ::= formalParameters circusDeclWordList error END 
            {
               CUP$Parser$result = case120(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // channelDecl ::= formalParameters circusDeclWordList COLON error END 
            {
               CUP$Parser$result = case119(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // channelDecl ::= nameList 
            {
               CUP$Parser$result = case118(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // channelDecl ::= circusDeclWordList COLON expression 
            {
               CUP$Parser$result = case117(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // channelDecl ::= formalParameters circusDeclWordList COLON expression 
            {
               CUP$Parser$result = case116(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // channelFromDeclList ::= channelFromDecl 
            {
               CUP$Parser$result = case115(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // channelFromDeclList ::= channelFromDeclList SEMICOLON channelFromDecl 
            {
               CUP$Parser$result = case114(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // channelDeclList ::= channelDecl 
            {
               CUP$Parser$result = case113(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // channelDeclList ::= channelDeclList SEMICOLON channelDecl 
            {
               CUP$Parser$result = case112(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // channelPara ::= CIRCCHANFROM error END 
            {
               CUP$Parser$result = case111(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // channelPara ::= CIRCCHAN error END 
            {
               CUP$Parser$result = case110(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // channelPara ::= CIRCCHANFROM channelFromDeclList 
            {
               CUP$Parser$result = case109(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // channelPara ::= CIRCCHAN channelDeclList 
            {
               CUP$Parser$result = case108(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // circusDeclWordList ::= DECLWORD 
            {
               CUP$Parser$result = case107(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // circusDeclWordList ::= circusDeclWordList COMMA DECLWORD 
            {
               CUP$Parser$result = case106(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // circusInnerProcPara ::= actionRefPara 
            {
               CUP$Parser$result = case105(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // circusInnerProcPara ::= actionPara 
            {
               CUP$Parser$result = case104(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // circusInnerProcPara ::= namesetPara 
            {
               CUP$Parser$result = case103(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // circusInnerProcPara ::= circusProcessState 
            {
               CUP$Parser$result = case102(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // circusInnerProcPara ::= optFormalParameters CONJECTURE predicate 
            {
               CUP$Parser$result = case101(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // circusInnerProcPara ::= THEOREM name optNL optFormalParameters CONJECTURE predicate 
            {
               CUP$Parser$result = case100(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // circusInnerProcPara ::= abbreviationDefinition 
            {
               CUP$Parser$result = case99(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // circusInnerProcPara ::= freeTypeList 
            {
               CUP$Parser$result = case98(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // circusInnerProcPara ::= basicTypeDefinition 
            {
               CUP$Parser$result = case97(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // circusInnerProcParaList ::= circusInnerProcPara 
            {
               CUP$Parser$result = case96(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // circusInnerProcParaList ::= circusInnerProcParaList NL circusInnerProcPara 
            {
               CUP$Parser$result = case95(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // singleCircusParagraphItem ::= processRefPara 
            {
               CUP$Parser$result = case94(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // singleCircusParagraphItem ::= processPara 
            {
               CUP$Parser$result = case93(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // singleCircusParagraphItem ::= channelSetPara 
            {
               CUP$Parser$result = case92(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // singleCircusParagraphItem ::= channelPara 
            {
               CUP$Parser$result = case91(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // singleCircusParagraphItemList ::= singleCircusParagraphItem 
            {
               CUP$Parser$result = case90(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // singleCircusParagraphItemList ::= singleCircusParagraphItemList NL singleCircusParagraphItem 
            {
               CUP$Parser$result = case89(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // circusMultiEnvParagraphList ::= CIRCUSACTION circusBasicProcessMainAction END 
            {
               CUP$Parser$result = case88(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // circusMultiEnvParagraphList ::= CIRCUSACTION circusInnerProcParaList END 
            {
               CUP$Parser$result = case87(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // circusMultiEnvParagraphList ::= CIRCUS singleCircusParagraphItemList END 
            {
               CUP$Parser$result = case86(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // varg ::= ARG 
            {
               CUP$Parser$result = case85(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // templateTag ::= LISTARG 
            {
               CUP$Parser$result = case84(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // templateTag ::= varg 
            {
               CUP$Parser$result = case83(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // optWordOperandList ::= optWordOperandList templateTag DECORWORD 
            {
               CUP$Parser$result = case82(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // optWordOperandList ::= 
            {
               CUP$Parser$result = case81(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // nofixTemplate ::= LPAREN DECORWORD optWordOperandList RPAREN 
            {
               CUP$Parser$result = case80(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // infixTemplate ::= LPAREN varg DECORWORD optWordOperandList varg RPAREN 
            {
               CUP$Parser$result = case79(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // postfixTemplate ::= LPAREN varg DECORWORD optWordOperandList RPAREN 
            {
               CUP$Parser$result = case78(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // prefixTemplate ::= LPAREN POWER varg RPAREN 
            {
               CUP$Parser$result = case77(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // prefixTemplate ::= LPAREN DECORWORD optWordOperandList varg RPAREN 
            {
               CUP$Parser$result = case76(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // assoc ::= RIGHTASSOC 
            {
               CUP$Parser$result = case75(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // assoc ::= LEFTASSOC 
            {
               CUP$Parser$result = case74(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // catTemplate ::= nofixTemplate 
            {
               CUP$Parser$result = case73(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // catTemplate ::= NUMERAL assoc infixTemplate 
            {
               CUP$Parser$result = case72(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // catTemplate ::= postfixTemplate 
            {
               CUP$Parser$result = case71(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // catTemplate ::= prefixTemplate 
            {
               CUP$Parser$result = case70(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // template ::= nofixTemplate 
            {
               CUP$Parser$result = case69(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // template ::= infixTemplate 
            {
               CUP$Parser$result = case68(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // template ::= postfixTemplate 
            {
               CUP$Parser$result = case67(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // template ::= prefixTemplate 
            {
               CUP$Parser$result = case66(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // operatorTemplate ::= GENERIC catTemplate 
            {
               CUP$Parser$result = case65(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // operatorTemplate ::= FUNCTION catTemplate 
            {
               CUP$Parser$result = case64(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // operatorTemplate ::= RELATION template 
            {
               CUP$Parser$result = case63(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // narrWordList ::= TEXT 
            {
               CUP$Parser$result = case62(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // narrWordList ::= narrWordList TEXT 
            {
               CUP$Parser$result = case61(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // branch ::= declName LDATA expression RDATA 
            {
               CUP$Parser$result = case60(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // branch ::= declName 
            {
               CUP$Parser$result = case59(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // branchList ::= branch 
            {
               CUP$Parser$result = case58(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // branchList ::= branchList BAR branch 
            {
               CUP$Parser$result = case57(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // freeTypeDefinition ::= name DEFFREE branchList 
            {
               CUP$Parser$result = case56(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // freeTypeList ::= freeTypeDefinition 
            {
               CUP$Parser$result = case55(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // freeTypeList ::= freeTypeList ANDALSO freeTypeDefinition 
            {
               CUP$Parser$result = case54(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // abbreviationDefinition ::= genName DEFEQUAL expression 
            {
               CUP$Parser$result = case53(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // abbreviationDefinition ::= declName formalParameters DEFEQUAL expression 
            {
               CUP$Parser$result = case52(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // abbreviationDefinition ::= declName DEFEQUAL expression 
            {
               CUP$Parser$result = case51(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // axiomaticDefinition ::= AX axiomaticSchemaText END 
            {
               CUP$Parser$result = case50(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // formalParameters ::= LSQUARE nameList RSQUARE optNL 
            {
               CUP$Parser$result = case49(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // optFormalParameters ::= 
            {
               CUP$Parser$result = case48(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // optFormalParameters ::= formalParameters 
            {
               CUP$Parser$result = case47(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // genericAxDefinition ::= GENAX formalParameters axiomaticSchemaText END 
            {
               CUP$Parser$result = case46(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // schema ::= GENSCH name optNL formalParameters schemaText END 
            {
               CUP$Parser$result = case45(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // schema ::= SCH name optNL schemaText END 
            {
               CUP$Parser$result = case44(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // basicTypeDefinition ::= LSQUARE nameList RSQUARE 
            {
               CUP$Parser$result = case43(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // conjecture ::= CONJECTURE 
            {
               CUP$Parser$result = case42(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // unboxedParagraphItem ::= operatorTemplate 
            {
               CUP$Parser$result = case41(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // unboxedParagraphItem ::= optFormalParameters CONJECTURE predicate 
            {
               CUP$Parser$result = case40(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // unboxedParagraphItem ::= THEOREM name optNL optFormalParameters conjecture predicate 
            {
               CUP$Parser$result = case39(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // unboxedParagraphItem ::= freeTypeList 
            {
               CUP$Parser$result = case38(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // unboxedParagraphItem ::= abbreviationDefinition 
            {
               CUP$Parser$result = case37(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // unboxedParagraphItem ::= basicTypeDefinition 
            {
               CUP$Parser$result = case36(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // unboxedParagraphItemList ::= unboxedParagraphItem 
            {
               CUP$Parser$result = case35(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // unboxedParagraphItemList ::= unboxedParagraphItemList NL unboxedParagraphItem 
            {
               CUP$Parser$result = case34(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // unboxedParagraphList ::= ZED error END 
            {
               CUP$Parser$result = case33(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // unboxedParagraphList ::= ZED circusBasicProcessMainAction END 
            {
               CUP$Parser$result = case32(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // unboxedParagraphList ::= ZED singleCircusParagraphItemList END 
            {
               CUP$Parser$result = case31(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // unboxedParagraphList ::= ZED unboxedParagraphItemList END 
            {
               CUP$Parser$result = case30(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // narrParagraph ::= narrWordList 
            {
               CUP$Parser$result = case29(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // boxedParagraph ::= error END 
            {
               CUP$Parser$result = case28(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // boxedParagraph ::= genericAxDefinition 
            {
               CUP$Parser$result = case27(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // boxedParagraph ::= schema 
            {
               CUP$Parser$result = case26(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // boxedParagraph ::= axiomaticDefinition 
            {
               CUP$Parser$result = case25(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // paragraphList ::= 
            {
               CUP$Parser$result = case24(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // paragraphList ::= paragraphList narrParagraph 
            {
               CUP$Parser$result = case23(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // paragraphList ::= paragraphList circusMultiEnvParagraphList 
            {
               CUP$Parser$result = case22(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // paragraphList ::= paragraphList unboxedParagraphList 
            {
               CUP$Parser$result = case21(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // paragraphList ::= paragraphList boxedParagraph 
            {
               CUP$Parser$result = case20(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // parentList ::= DECORWORD 
            {
               CUP$Parser$result = case19(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // parentList ::= parentList COMMA DECORWORD 
            {
               CUP$Parser$result = case18(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // parents ::= PARENTS parentList 
            {
               CUP$Parser$result = case17(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // parents ::= PARENTS 
            {
               CUP$Parser$result = case16(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // parents ::= 
            {
               CUP$Parser$result = case15(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // sectionHeader ::= SECTION DECORWORD parents END 
            {
               CUP$Parser$result = case14(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // section ::= sectionHeader paragraphList 
            {
               CUP$Parser$result = case13(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // sectionList ::= section 
            {
               CUP$Parser$result = case12(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // sectionList ::= sectionList section 
            {
               CUP$Parser$result = case11(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // empty ::= 
            {
               CUP$Parser$result = case10(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // emptySectionHeader ::= empty 
            {
               CUP$Parser$result = case9(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // specification ::= sectionList 
            {
               CUP$Parser$result = case8(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // specification ::= emptySectionHeader paragraphList 
            {
               CUP$Parser$result = case7(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // narrSect ::= narrWordList 
            {
               CUP$Parser$result = case6(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // narrSect ::= 
            {
               CUP$Parser$result = case5(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // input ::= PRED predicate 
            {
               CUP$Parser$result = case4(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // input ::= EXPR expression 
            {
               CUP$Parser$result = case3(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // input ::= PARA boxedParagraph 
            {
               CUP$Parser$result = case2(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= input EOF 
            {
               CUP$Parser$result = case1(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // input ::= narrSect specification 
            {
               CUP$Parser$result = case0(
                 CUP$Parser$act_num,
                 CUP$Parser$parser,
                 CUP$Parser$stack,
                 CUP$Parser$top);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }/*1*/
    //optNL ::= NL 
    java_cup.runtime.Symbol case515(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      And RESULT =null;/*3*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optNL",109, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optNL ::= 
    java_cup.runtime.Symbol case514(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      And RESULT =null;/*3*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optNL",109, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //expSep ::= expSep expressionList SS 
    java_cup.runtime.Symbol case513(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Object> RESULT =null;/*3*/
		int exsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int exsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Object> exs = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int exprListleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int exprListright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZExprList exprList = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int ssleft = CUP$Parser$stack.peek().left;
		int ssright = CUP$Parser$stack.peek().right;
		LocString ss = (LocString) CUP$Parser$stack.peek().value;
		
           exs.add(exprList);
           exs.add(ss.getString());
           RESULT = exs;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expSep",99, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //expSep ::= expSep term ES 
    java_cup.runtime.Symbol case512(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Object> RESULT =null;/*3*/
		int exsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int exsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Object> exs = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int tleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int tright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Term t = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int esleft = CUP$Parser$stack.peek().left;
		int esright = CUP$Parser$stack.peek().right;
		LocString es = (LocString) CUP$Parser$stack.peek().value;
		
           exs.add(factory_.list(expr(t)));
           exs.add(es.getString());
           RESULT = exs;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expSep",99, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //expSep ::= 
    java_cup.runtime.Symbol case511(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Object> RESULT =null;/*3*/
		 RESULT = factory_.list(); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expSep",99, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //nofixApp ::= L expSep optExpressionList SR 
    java_cup.runtime.Symbol case510(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Expr RESULT =null;/*3*/
		int lleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocString l = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int esleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int esright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Object> es = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int oelleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int oelright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZExprList oel = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int srleft = CUP$Parser$stack.peek().left;
		int srright = CUP$Parser$stack.peek().right;
		LocString sr = (LocString) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(l.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sr.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo loc = getLocation(l.getLocation(), sr.getLocation());
           addLocAnn(seq, loc);
           expList.add(seq);
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, loc);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("nofixApp",98, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //nofixApp ::= L expSep term ER 
    java_cup.runtime.Symbol case509(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Expr RESULT =null;/*3*/
		int lleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocString l = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int esleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int esright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Object> es = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int tleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int tright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Term t = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int erleft = CUP$Parser$stack.peek().left;
		int erright = CUP$Parser$stack.peek().right;
		LocString er = (LocString) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(l.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(er.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           expList.add(expr(t));
           LocInfo loc = getLocation(l.getLocation(), er.getLocation());
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, loc);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("nofixApp",98, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixApp ::= term EL expSep optExpressionList SRE term 
    java_cup.runtime.Symbol case508(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Expr RESULT =null;/*3*/
		int t1left = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int t1right = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		Term t1 = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int elleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int elright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocString el = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int esleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int esright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		@SuppressWarnings("unchecked") List<Object> es = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int oelleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int oelright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZExprList oel = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int sreleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int sreright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString sre = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int t2left = CUP$Parser$stack.peek().left;
		int t2right = CUP$Parser$stack.peek().right;
		Term t2 = (Term) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(ARG_TOK);
           opName.add(el.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sre.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo sreLoc = sre.getLocation();
           addLocAnn(seq, getLocation(el.getLocation(), sreLoc));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           expList.add(expr(t2));
           LocInfo loc = getLocation(el.getLocation(), sreLoc);
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(elleft, elright, t1, t2));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixApp",97, CUP$Parser$stack.elementAt(CUP$Parser$top-5), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixApp ::= term EL expSep term ERE term 
    java_cup.runtime.Symbol case507(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Expr RESULT =null;/*3*/
		int t1left = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int t1right = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		Term t1 = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int elleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int elright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocString el = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int esleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int esright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		@SuppressWarnings("unchecked") List<Object> es = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int t2left = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int t2right = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term t2 = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int ereleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int ereright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString ere = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int t3left = CUP$Parser$stack.peek().left;
		int t3right = CUP$Parser$stack.peek().right;
		Term t3 = (Term) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(ARG_TOK);
           opName.add(el.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(ere.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           expList.add(expr(t3));
           LocInfo loc = getLocation(el.getLocation(), ere.getLocation());
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t1, t3));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixApp",97, CUP$Parser$stack.elementAt(CUP$Parser$top-5), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixApp ::= term I term 
    java_cup.runtime.Symbol case506(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Expr RESULT =null;/*3*/
		int lhsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lhsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term lhs = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int ileft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int iright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString i = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		Term rhs = (Term) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(ARG_TOK);
           opName.add(i.getString());
           opName.add(ARG_TOK);
           ZExprList exprs = factory_.createZExprList();
           exprs.add(expr(lhs));
           exprs.add(expr(rhs));
           RESULT = createMixfixExpr(opName, exprs, i.getLocation());
           addLocAnn(RESULT, getLocation(ileft, iright, lhs, rhs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixApp",97, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //postfixApp ::= term EL expSep optExpressionList SR 
    java_cup.runtime.Symbol case505(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Expr RESULT =null;/*3*/
		int tleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int tright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Term t = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int elleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int elright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocString el = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int esleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int esright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Object> es = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int oelleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int oelright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZExprList oel = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int srleft = CUP$Parser$stack.peek().left;
		int srright = CUP$Parser$stack.peek().right;
		LocString sr = (LocString) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(ARG_TOK);
           opName.add(el.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sr.getString());

           LocInfo srLoc = sr.getLocation();
           LocInfo elLoc = el.getLocation();
           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t));
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           addLocAnn(seq, getLocation(el.getLocation(), srLoc));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           LocInfo loc = getLocation(elLoc, srLoc);
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t, srLoc));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("postfixApp",96, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //postfixApp ::= term EL expSep term ER 
    java_cup.runtime.Symbol case504(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Expr RESULT =null;/*3*/
		int t1left = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int t1right = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Term t1 = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int elleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int elright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocString el = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int esleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int esright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Object> es = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int t2left = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int t2right = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Term t2 = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int erleft = CUP$Parser$stack.peek().left;
		int erright = CUP$Parser$stack.peek().right;
		LocString er = (LocString) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(ARG_TOK);
           opName.add(el.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(er.getString());

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           LocInfo erLoc = er.getLocation();
           LocInfo elLoc = el.getLocation();
           LocInfo loc = getLocation(elLoc, erLoc);
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t1, erLoc));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("postfixApp",96, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //postfixApp ::= term POST 
    java_cup.runtime.Symbol case503(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Expr RESULT =null;/*3*/
		int tleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int tright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Term t = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int postleft = CUP$Parser$stack.peek().left;
		int postright = CUP$Parser$stack.peek().right;
		LocString post = (LocString) CUP$Parser$stack.peek().value;
		
           ZExprList exprs = factory_.createZExprList();
           exprs.add(expr(t));
           LocInfo loc = post.getLocation();
           RESULT =
             createMixfixExpr(factory_.list(ARG_TOK, post.getString()), exprs, loc);
           addLocAnn(RESULT, getLocation(t, post.getLocation()));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("postfixApp",96, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //prefixApp ::= L expSep optExpressionList SRE term 
    java_cup.runtime.Symbol case502(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Expr RESULT =null;/*3*/
		int lleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int lright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocString l = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int esleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int esright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		@SuppressWarnings("unchecked") List<Object> es = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int oelleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int oelright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZExprList oel = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int sreleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int sreright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString sre = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		Term t = (Term) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(l.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sre.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo sreLoc = sre.getLocation();
           LocInfo lLoc = l.getLocation();
           addLocAnn(seq, getLocation(lLoc, sreLoc));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           expList.add(expr(t));
           LocInfo loc = getLocation(lLoc, sreLoc);
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(lLoc, t));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("prefixApp",95, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //prefixApp ::= L expSep term ERE term 
    java_cup.runtime.Symbol case501(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Expr RESULT =null;/*3*/
		int lleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int lright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocString l = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int esleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int esright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		@SuppressWarnings("unchecked") List<Object> es = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int t1left = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int t1right = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term t1 = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int ereleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int ereright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString ere = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int t2left = CUP$Parser$stack.peek().left;
		int t2right = CUP$Parser$stack.peek().right;
		Term t2 = (Term) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(l.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(ere.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           expList.add(expr(t1));
           expList.add(expr(t2));
           LocInfo lloc = l.getLocation();
           LocInfo loc = getLocation(lloc, ere.getLocation());
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(lloc, t2));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("prefixApp",95, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //prefixApp ::= PRE term 
    java_cup.runtime.Symbol case500(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Expr RESULT =null;/*3*/
		int preleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int preright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString pre = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		Term t = (Term) CUP$Parser$stack.peek().value;
		
           ZExprList exprs = factory_.createZExprList();
           exprs.add(expr(t));
           LocInfo loc = pre.getLocation();
           RESULT =
             createMixfixExpr(factory_.list(pre.getString(), ARG_TOK), exprs, loc);
           addLocAnn(RESULT, getLocation(pre.getLocation(), t));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("prefixApp",95, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //application ::= infixApp 
    java_cup.runtime.Symbol case499(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Expr RESULT =null;/*3*/
		int ialeft = CUP$Parser$stack.peek().left;
		int iaright = CUP$Parser$stack.peek().right;
		Expr ia = (Expr) CUP$Parser$stack.peek().value;
		 RESULT = ia; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("application",94, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //application ::= postfixApp 
    java_cup.runtime.Symbol case498(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Expr RESULT =null;/*3*/
		int paleft = CUP$Parser$stack.peek().left;
		int paright = CUP$Parser$stack.peek().right;
		Expr pa = (Expr) CUP$Parser$stack.peek().value;
		 RESULT = pa; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("application",94, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //application ::= prefixApp 
    java_cup.runtime.Symbol case497(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Expr RESULT =null;/*3*/
		int paleft = CUP$Parser$stack.peek().left;
		int paright = CUP$Parser$stack.peek().right;
		Expr pa = (Expr) CUP$Parser$stack.peek().value;
		 RESULT = pa; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("application",94, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //nofixRel ::= LP expSep optExpressionList SRP 
    java_cup.runtime.Symbol case496(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      MemPred RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocString lp = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int esleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int esright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Object> es = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int oelleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int oelright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZExprList oel = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int srpleft = CUP$Parser$stack.peek().left;
		int srpright = CUP$Parser$stack.peek().right;
		LocString srp = (LocString) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(ARG_TOK);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srp.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo srpLoc =  srp.getLocation();
           LocInfo lpLoc = lp.getLocation();
           addLocAnn(seq, getLocation(lpLoc, srpLoc));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           LocInfo loc = getLocation(lpLoc, srpLoc);
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, loc);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("nofixRel",75, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //nofixRel ::= LP expSep term ERP 
    java_cup.runtime.Symbol case495(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      MemPred RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocString lp = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int esleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int esright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Object> es = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int tleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int tright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Term t = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int erpleft = CUP$Parser$stack.peek().left;
		int erpright = CUP$Parser$stack.peek().right;
		LocString erp = (LocString) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(ARG_TOK);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erp.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           expList.add(expr(t));
           LocInfo erpLoc = erp.getLocation();
           LocInfo loc = getLocation(lp.getLocation(), erpLoc);
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(lp.getLocation(), erpLoc));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("nofixRel",75, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixChainRel ::= infixChainRel IP term 
    java_cup.runtime.Symbol case494(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pred RESULT =null;/*3*/
		int icrleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int icrright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Pred icr = (Pred) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int ipleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int ipright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString ip = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		Term rhs = (Term) CUP$Parser$stack.peek().value;
		
           RESULT = transformChainRelInfix(icr, expr(rhs), ip.getString(),
                                           getLocation(icrleft, icrright));
           addLocAnn(RESULT, getLocation(icrleft, icrright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixChainRel",72, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixChainRel ::= infixChainRel EQUALS term 
    java_cup.runtime.Symbol case493(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pred RESULT =null;/*3*/
		int icrleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int icrright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Pred icr = (Pred) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		Term rhs = (Term) CUP$Parser$stack.peek().value;
		
           RESULT = transformChainRel(icr, Sym.EQUALS, expr(rhs),
                                      getLocation(icrleft, icrright));
           addLocAnn(RESULT, getLocation(icrleft, icrright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixChainRel",72, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixChainRel ::= infixChainRel MEM term 
    java_cup.runtime.Symbol case492(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pred RESULT =null;/*3*/
		int icrleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int icrright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Pred icr = (Pred) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		Term rhs = (Term) CUP$Parser$stack.peek().value;
		
           RESULT =
             transformChainRel(icr, Sym.MEM, expr(rhs), getLocation(icr));
           addLocAnn(RESULT, getLocation(icr, rhs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixChainRel",72, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixChainRel ::= term IP term 
    java_cup.runtime.Symbol case491(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pred RESULT =null;/*3*/
		int lhsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lhsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term lhs = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int ipleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int ipright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString ip = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		Term rhs = (Term) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(ARG_TOK);
           opName.add(ip.getString());
           opName.add(ARG_TOK);
           ZExprList expList = factory_.createZExprList();
           expList.add(expr(lhs));
           expList.add(expr(rhs));
           RESULT = createMemPred(opName, expList, ip.getLocation());
           addLocAnn(RESULT, getLocation(lhs, rhs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixChainRel",72, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixChainRel ::= term EQUALS term 
    java_cup.runtime.Symbol case490(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pred RESULT =null;/*3*/
		int lhsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lhsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term lhs = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int equalsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int equalsright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo equals = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		Term rhs = (Term) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createEquality(expr(lhs), expr(rhs));
           addLocAnn(RESULT, getLocation(equalsleft, equalsright, lhs, rhs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixChainRel",72, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixChainRel ::= term MEM term 
    java_cup.runtime.Symbol case489(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pred RESULT =null;/*3*/
		int lhsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lhsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term lhs = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int mleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int mright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo m = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		Term rhs = (Term) CUP$Parser$stack.peek().value;
		
           RESULT =
             factory_.createMemPred(expr(lhs), expr(rhs), Boolean.FALSE);
           addLocAnn(RESULT, getLocation(mleft, mright, lhs, rhs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixChainRel",72, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixRel ::= term ELP expSep optExpressionList SREP term 
    java_cup.runtime.Symbol case488(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pred RESULT =null;/*3*/
		int t1left = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int t1right = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		Term t1 = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int elpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int elpright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocString elp = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int esleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int esright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		@SuppressWarnings("unchecked") List<Object> es = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int oelleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int oelright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZExprList oel = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int erepleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int erepright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString erep = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int t2left = CUP$Parser$stack.peek().left;
		int t2right = CUP$Parser$stack.peek().right;
		Term t2 = (Term) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(ARG_TOK);
           opName.add(elp.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(erep.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           addLocAnn(seq, getLocation(oelleft, oelright));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           expList.add(expr(t2));
           LocInfo loc = getLocation(elp.getLocation(), erep.getLocation());
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t1, t2));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixRel",71, CUP$Parser$stack.elementAt(CUP$Parser$top-5), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixRel ::= term ELP expSep term EREP term 
    java_cup.runtime.Symbol case487(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pred RESULT =null;/*3*/
		int t1left = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int t1right = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		Term t1 = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int elpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int elpright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocString elp = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int esleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int esright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		@SuppressWarnings("unchecked") List<Object> es = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int t2left = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int t2right = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term t2 = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int erepleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int erepright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString erep = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int t3left = CUP$Parser$stack.peek().left;
		int t3right = CUP$Parser$stack.peek().right;
		Term t3 = (Term) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(ARG_TOK);
           opName.add(elp.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erep.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           expList.add(expr(t3));
           LocInfo loc = getLocation(elp.getLocation(), erep.getLocation());
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t1, t3));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixRel",71, CUP$Parser$stack.elementAt(CUP$Parser$top-5), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixRel ::= infixChainRel 
    java_cup.runtime.Symbol case486(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pred RESULT =null;/*3*/
		int icrleft = CUP$Parser$stack.peek().left;
		int icrright = CUP$Parser$stack.peek().right;
		Pred icr = (Pred) CUP$Parser$stack.peek().value;
		 RESULT = icr; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixRel",71, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //postfixRel ::= term ELP expSep optExpressionList SRP 
    java_cup.runtime.Symbol case485(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      MemPred RESULT =null;/*3*/
		int tleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int tright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Term t = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int elpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int elpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocString elp = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int esleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int esright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Object> es = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int oelleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int oelright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZExprList oel = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int srpleft = CUP$Parser$stack.peek().left;
		int srpright = CUP$Parser$stack.peek().right;
		LocString srp = (LocString) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(ARG_TOK);
           opName.add(elp.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srp.getString());

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t));
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo srpLoc = srp.getLocation();
           addLocAnn(seq, getLocation(elp.getLocation(), srpLoc));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           LocInfo loc = getLocation(elp.getLocation(), srpLoc);
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t, srpLoc));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("postfixRel",74, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //postfixRel ::= term ELP expSep term ERP 
    java_cup.runtime.Symbol case484(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      MemPred RESULT =null;/*3*/
		int t1left = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int t1right = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Term t1 = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int elpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int elpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocString elp = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int esleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int esright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Object> es = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int t2left = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int t2right = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Term t2 = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int erpleft = CUP$Parser$stack.peek().left;
		int erpright = CUP$Parser$stack.peek().right;
		LocString erp = (LocString) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(ARG_TOK);
           opName.add(elp.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erp.getString());

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           LocInfo erpLoc = erp.getLocation();
           LocInfo loc = getLocation(elp.getLocation(), erpLoc);
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t1, erpLoc));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("postfixRel",74, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //postfixRel ::= term POSTP 
    java_cup.runtime.Symbol case483(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      MemPred RESULT =null;/*3*/
		int tleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int tright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Term t = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		LocString p = (LocString) CUP$Parser$stack.peek().value;
		
           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t));
           LocInfo pLoc = p.getLocation();
           RESULT = createMemPred(factory_.list(p.getString()), expList, pLoc);
           addLocAnn(RESULT, getLocation(t, pLoc));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("postfixRel",74, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //prefixRel ::= LP expSep optExpressionList SREP term 
    java_cup.runtime.Symbol case482(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      MemPred RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocString lp = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int esleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int esright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		@SuppressWarnings("unchecked") List<Object> es = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int oelleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int oelright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZExprList oel = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int srepleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int srepright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString srep = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		Term t = (Term) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(lp.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srep.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo lpLoc = lp.getLocation();
           LocInfo loc = getLocation(lpLoc, srep.getLocation());
           addLocAnn(seq, loc);
           expList.add(seq);
           expList.add(expr(t));
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(lpLoc, t));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("prefixRel",73, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //prefixRel ::= LP expSep term EREP term 
    java_cup.runtime.Symbol case481(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      MemPred RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocString lp = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int esleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int esright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		@SuppressWarnings("unchecked") List<Object> es = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int t1left = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int t1right = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term t1 = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int erepleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int erepright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString erep = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int t2left = CUP$Parser$stack.peek().left;
		int t2right = CUP$Parser$stack.peek().right;
		Term t2 = (Term) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(lp.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erep.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           expList.add(expr(t1));
           expList.add(expr(t2));
           LocInfo lpLoc = lp.getLocation();
           LocInfo loc = getLocation(lpLoc, erep.getLocation());
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(lpLoc, t2));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("prefixRel",73, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //prefixRel ::= PREP term 
    java_cup.runtime.Symbol case480(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      MemPred RESULT =null;/*3*/
		int pleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int pright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString p = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		Term t = (Term) CUP$Parser$stack.peek().value;
		
           List<String> opName = factory_.list(p.getString());
           opName.add(ARG_TOK);
           ZExprList exprs = factory_.createZExprList();
           exprs.add(expr(t));
           RESULT = createMemPred(opName, exprs, p.getLocation());
           addLocAnn(RESULT, getLocation(p.getLocation(), t));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("prefixRel",73, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //relation ::= infixRel 
    java_cup.runtime.Symbol case479(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pred RESULT =null;/*3*/
		int irleft = CUP$Parser$stack.peek().left;
		int irright = CUP$Parser$stack.peek().right;
		Pred ir = (Pred) CUP$Parser$stack.peek().value;
		 RESULT = ir; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relation",70, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //relation ::= postfixRel 
    java_cup.runtime.Symbol case478(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pred RESULT =null;/*3*/
		int prleft = CUP$Parser$stack.peek().left;
		int prright = CUP$Parser$stack.peek().right;
		MemPred pr = (MemPred) CUP$Parser$stack.peek().value;
		 RESULT = pr; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relation",70, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //relation ::= prefixRel 
    java_cup.runtime.Symbol case477(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pred RESULT =null;/*3*/
		int prleft = CUP$Parser$stack.peek().left;
		int prright = CUP$Parser$stack.peek().right;
		MemPred pr = (MemPred) CUP$Parser$stack.peek().value;
		 RESULT = pr; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relation",70, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //rename ::= declName SLASH refName 
    java_cup.runtime.Symbol case476(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      NewOldPair RESULT =null;/*3*/
		int lhsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lhsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Name lhs = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		ZName rhs = (ZName) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createNewOldPair(lhs, rhs);
           addLocAnn(RESULT, getLocation(lhs, rhs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("rename",49, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //zRenameList ::= rename 
    java_cup.runtime.Symbol case475(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZRenameList RESULT =null;/*3*/
		int rnleft = CUP$Parser$stack.peek().left;
		int rnright = CUP$Parser$stack.peek().right;
		NewOldPair rn = (NewOldPair) CUP$Parser$stack.peek().value;
		 RESULT = factory_.createZRenameList(factory_.list(rn)); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("zRenameList",48, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //zRenameList ::= zRenameList COMMA rename 
    java_cup.runtime.Symbol case474(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZRenameList RESULT =null;/*3*/
		int rnlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int rnlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZRenameList rnl = (ZRenameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rnleft = CUP$Parser$stack.peek().left;
		int rnright = CUP$Parser$stack.peek().right;
		NewOldPair rn = (NewOldPair) CUP$Parser$stack.peek().value;
		
           rnl.getNewOldPair().add(rn);
           RESULT = rnl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("zRenameList",48, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //renameList ::= zRenameList 
    java_cup.runtime.Symbol case473(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      RenameList RESULT =null;/*3*/
		int zrnlleft = CUP$Parser$stack.peek().left;
		int zrnlright = CUP$Parser$stack.peek().right;
		ZRenameList zrnl = (ZRenameList) CUP$Parser$stack.peek().value;
		 RESULT = zrnl; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("renameList",47, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //stroke ::= NUMSTROKE 
    java_cup.runtime.Symbol case472(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Stroke RESULT =null;/*3*/
		int nsleft = CUP$Parser$stack.peek().left;
		int nsright = CUP$Parser$stack.peek().right;
		LocInt ns = (LocInt) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createNumStroke(ns.getIntValue());
           addLocAnn(RESULT, ns.getLocation());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("stroke",60, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //stroke ::= NEXTSTROKE 
    java_cup.runtime.Symbol case471(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Stroke RESULT =null;/*3*/
		int nsleft = CUP$Parser$stack.peek().left;
		int nsright = CUP$Parser$stack.peek().right;
		LocInfo ns = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createNextStroke();
           addLocAnn(RESULT, ns);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("stroke",60, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //stroke ::= OUTSTROKE 
    java_cup.runtime.Symbol case470(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Stroke RESULT =null;/*3*/
		int osleft = CUP$Parser$stack.peek().left;
		int osright = CUP$Parser$stack.peek().right;
		LocInfo os = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createOutStroke();
           addLocAnn(RESULT, os);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("stroke",60, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //stroke ::= INSTROKE 
    java_cup.runtime.Symbol case469(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Stroke RESULT =null;/*3*/
		int isleft = CUP$Parser$stack.peek().left;
		int isright = CUP$Parser$stack.peek().right;
		LocInfo is = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createInStroke();
           addLocAnn(RESULT, is);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("stroke",60, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //letDefinition ::= declName DEFEQUAL expression 
    java_cup.runtime.Symbol case468(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ConstDecl RESULT =null;/*3*/
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int defequalleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int defequalright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo defequal = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createConstDecl(n,e);
           addLocAnn(RESULT, getLocation(defequalleft, defequalright, n, e));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("letDefinition",20, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //letDefinitionList ::= letDefinition 
    java_cup.runtime.Symbol case467(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZDeclList RESULT =null;/*3*/
		int ldleft = CUP$Parser$stack.peek().left;
		int ldright = CUP$Parser$stack.peek().right;
		ConstDecl ld = (ConstDecl) CUP$Parser$stack.peek().value;
		 RESULT = factory_.createZDeclList(factory_.list(ld)); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("letDefinitionList",38, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //letDefinitionList ::= letDefinitionList SEMICOLON letDefinition 
    java_cup.runtime.Symbol case466(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZDeclList RESULT =null;/*3*/
		int ldlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ldlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZDeclList ldl = (ZDeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int ldleft = CUP$Parser$stack.peek().left;
		int ldright = CUP$Parser$stack.peek().right;
		ConstDecl ld = (ConstDecl) CUP$Parser$stack.peek().value;
		
           ldl.getDecl().add(ld);
           RESULT = ldl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("letDefinitionList",38, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //constDeclList ::= constDecl 
    java_cup.runtime.Symbol case465(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZDeclList RESULT =null;/*3*/
		int cdleft = CUP$Parser$stack.peek().left;
		int cdright = CUP$Parser$stack.peek().right;
		ConstDecl cd = (ConstDecl) CUP$Parser$stack.peek().value;
		 RESULT = factory_.createZDeclList(factory_.list(cd)); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("constDeclList",77, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //constDeclList ::= constDeclList COMMA constDecl 
    java_cup.runtime.Symbol case464(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZDeclList RESULT =null;/*3*/
		int cdlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cdlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZDeclList cdl = (ZDeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cdleft = CUP$Parser$stack.peek().left;
		int cdright = CUP$Parser$stack.peek().right;
		ConstDecl cd = (ConstDecl) CUP$Parser$stack.peek().value;
		
           cdl.getDecl().add(cd);
           RESULT = cdl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("constDeclList",77, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optConstDeclList ::= constDeclList 
    java_cup.runtime.Symbol case463(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZDeclList RESULT =null;/*3*/
		int cdlleft = CUP$Parser$stack.peek().left;
		int cdlright = CUP$Parser$stack.peek().right;
		ZDeclList cdl = (ZDeclList) CUP$Parser$stack.peek().value;
		 RESULT = cdl; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optConstDeclList",78, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optConstDeclList ::= 
    java_cup.runtime.Symbol case462(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZDeclList RESULT =null;/*3*/
		 RESULT = factory_.createZDeclList(); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optConstDeclList",78, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //expressionList ::= expression 
    java_cup.runtime.Symbol case461(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZExprList RESULT =null;/*3*/
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createZExprList();
           RESULT.add(e);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expressionList",81, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //expressionList ::= expressionList COMMA expression 
    java_cup.runtime.Symbol case460(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZExprList RESULT =null;/*3*/
		int elleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int elright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZExprList el = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
           el.add(e);
           RESULT = el;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expressionList",81, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optExpressionList ::= expressionList 
    java_cup.runtime.Symbol case459(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZExprList RESULT =null;/*3*/
		int elleft = CUP$Parser$stack.peek().left;
		int elright = CUP$Parser$stack.peek().right;
		ZExprList el = (ZExprList) CUP$Parser$stack.peek().value;
		 RESULT = el; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optExpressionList",80, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optExpressionList ::= 
    java_cup.runtime.Symbol case458(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZExprList RESULT =null;/*3*/
		 RESULT = factory_.createZExprList(); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optExpressionList",80, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //prodExpressionList ::= prodExpressionList CROSS term 
    java_cup.runtime.Symbol case457(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZExprList RESULT =null;/*3*/
		int pelleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int pelright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZExprList pel = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		Term t = (Term) CUP$Parser$stack.peek().value;
		
           pel.add(expr(t));
           RESULT = pel;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("prodExpressionList",79, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //prodExpressionList ::= term CROSS term 
    java_cup.runtime.Symbol case456(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZExprList RESULT =null;/*3*/
		int t1left = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int t1right = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term t1 = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int t2left = CUP$Parser$stack.peek().left;
		int t2right = CUP$Parser$stack.peek().right;
		Term t2 = (Term) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createZExprList();
           RESULT.add(expr(t1));
           RESULT.add(expr(t2));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("prodExpressionList",79, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //appendage ::= DOT NUMERAL 
    java_cup.runtime.Symbol case455(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Object RESULT =null;/*3*/
		int nleft = CUP$Parser$stack.peek().left;
		int nright = CUP$Parser$stack.peek().right;
		LocInt n = (LocInt) CUP$Parser$stack.peek().value;
		
           ZNumeral numeral = factory_.createZNumeral(n.getValue());
           addLocAnn(numeral, n.getLocation());
           RESULT = factory_.createTupleSelExpr(null, numeral);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("appendage",68, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //appendage ::= DOT refName 
    java_cup.runtime.Symbol case454(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Object RESULT =null;/*3*/
		int rnleft = CUP$Parser$stack.peek().left;
		int rnright = CUP$Parser$stack.peek().right;
		ZName rn = (ZName) CUP$Parser$stack.peek().value;
		 RESULT = factory_.createBindSelExpr(null, rn); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("appendage",68, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //appendage ::= LSQUARE renameList RSQUARE 
    java_cup.runtime.Symbol case453(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Object RESULT =null;/*3*/
		int lsqleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lsqright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo lsq = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rnlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rnlright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		RenameList rnl = (RenameList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		 RESULT = factory_.createRenameExpr(null, rnl); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("appendage",68, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //appendage ::= stroke 
    java_cup.runtime.Symbol case452(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Object RESULT =null;/*3*/
		int sleft = CUP$Parser$stack.peek().left;
		int sright = CUP$Parser$stack.peek().right;
		Stroke s = (Stroke) CUP$Parser$stack.peek().value;
		 RESULT = s; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("appendage",68, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //appendageList ::= appendage 
    java_cup.runtime.Symbol case451(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Object> RESULT =null;/*3*/
		int aleft = CUP$Parser$stack.peek().left;
		int aright = CUP$Parser$stack.peek().right;
		Object a = (Object) CUP$Parser$stack.peek().value;
		 RESULT = factory_.list(a); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("appendageList",67, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //appendageList ::= appendageList appendage 
    java_cup.runtime.Symbol case450(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Object> RESULT =null;/*3*/
		int alleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int alright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<Object> al = (List<Object>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int aleft = CUP$Parser$stack.peek().left;
		int aright = CUP$Parser$stack.peek().right;
		Object a = (Object) CUP$Parser$stack.peek().value;
		
          al.add(a);
          RESULT = al;
       /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("appendageList",67, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optAppendageList ::= 
    java_cup.runtime.Symbol case449(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Object> RESULT =null;/*3*/
		 RESULT = factory_.list(); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optAppendageList",66, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optAppendageList ::= appendageList 
    java_cup.runtime.Symbol case448(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Object> RESULT =null;/*3*/
		int alleft = CUP$Parser$stack.peek().left;
		int alright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Object> al = (List<Object>) CUP$Parser$stack.peek().value;
		 RESULT = al; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optAppendageList",66, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= FALSE 
    java_cup.runtime.Symbol case447(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int fleft = CUP$Parser$stack.peek().left;
		int fright = CUP$Parser$stack.peek().right;
		LocInfo f = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createFalsePred();
           addLocAnn(RESULT, f);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= TRUE 
    java_cup.runtime.Symbol case446(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		LocInfo t = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createTruePred();
           addLocAnn(RESULT, t);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= refName 
    java_cup.runtime.Symbol case445(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int rnleft = CUP$Parser$stack.peek().left;
		int rnright = CUP$Parser$stack.peek().right;
		ZName rn = (ZName) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createRefExpr(rn);
           addLocAnn(RESULT, getLocation(rn));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= LPAREN septerm RPAREN 
    java_cup.runtime.Symbol case444(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lparenleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lparenright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo lparen = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int tleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int tright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Term t = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rparenleft = CUP$Parser$stack.peek().left;
		int rparenright = CUP$Parser$stack.peek().right;
		LocInfo rparen = (LocInfo) CUP$Parser$stack.peek().value;
		
           ParenAnn parenAnn = factory_.createParenAnn();
           addLocAnn(parenAnn, getLocation(lparen, rparen));
           t.getAnns().add(parenAnn);
           RESULT = t;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= NUMERAL 
    java_cup.runtime.Symbol case443(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int nleft = CUP$Parser$stack.peek().left;
		int nright = CUP$Parser$stack.peek().right;
		LocInt n = (LocInt) CUP$Parser$stack.peek().value;
		
           ZNumeral numeral = factory_.createZNumeral(n.getValue());
           addLocAnn(numeral, n.getLocation());
           RESULT = factory_.createNumExpr(numeral);
           addLocAnn(RESULT, n.getLocation());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= inner_term LSQUARE renameList RSQUARE 
    java_cup.runtime.Symbol case442(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int itleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int itright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		Term it = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int rnlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rnlright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		RenameList rnl = (RenameList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rsquareleft = CUP$Parser$stack.peek().left;
		int rsquareright = CUP$Parser$stack.peek().right;
		LocInfo rsquare = (LocInfo) CUP$Parser$stack.peek().value;
		

             RESULT = factory_.createRenameExpr(expr(it), rnl);

           //System.out.println("REACHED RENAMING = " + rnl.toString());
           addLocAnn(RESULT, getLocation(it, rsquare));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= inner_term LSQUARE expressionList RSQUARE 
    java_cup.runtime.Symbol case441(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int itleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int itright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		Term it = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int elleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int elright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZExprList el = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rsquareleft = CUP$Parser$stack.peek().left;
		int rsquareright = CUP$Parser$stack.peek().right;
		LocInfo rsquare = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createRefExpr(name(it), el, Boolean.FALSE, Boolean.TRUE);
           addLocAnn(RESULT, getLocation(it, rsquare));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= inner_term LSQUARE schemaTextNoExpression RSQUARE optAppendageList 
    java_cup.runtime.Symbol case440(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int itleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int itright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Term it = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int stleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int stright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		SchText st = (SchText) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rsquareleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rsquareright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo rsquare = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int oalleft = CUP$Parser$stack.peek().left;
		int oalright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Object> oal = (List<Object>) CUP$Parser$stack.peek().value;
		
           RESULT = createSchApplExpr(expr(it), st, oal);
           addLocAnn(RESULT, getLocation(it, rsquare));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= THETA inner_term 
    java_cup.runtime.Symbol case439(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int thetaleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int thetaright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo theta = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int itleft = CUP$Parser$stack.peek().left;
		int itright = CUP$Parser$stack.peek().right;
		Term it = (Term) CUP$Parser$stack.peek().value;
		
           //System.out.println("REACHED THETA FOR " + it.toString());
           ZStrokeList sl = factory_.createZStrokeList();
           RESULT = factory_.createThetaExpr(expr(it), sl);
           addLocAnn(RESULT, getLocation(theta, it));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= inner_term stroke 
    java_cup.runtime.Symbol case438(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int itleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int itright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Term it = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int sleft = CUP$Parser$stack.peek().left;
		int sright = CUP$Parser$stack.peek().right;
		Stroke s = (Stroke) CUP$Parser$stack.peek().value;
		
           //if the inner term is a theta expr, add the stroke to the
           //theta expr instead, which has a tighter binding.
           Object pAnn = it.getAnn(ParenAnn.class);
           if (it instanceof ThetaExpr && pAnn == null) {
             ThetaExpr te = (ThetaExpr) it;
	     te.getZStrokeList().add(s);
	     addLocAnn(te, getLocation(te, s));
	     RESULT = te;
           }
           else {
             RESULT = factory_.createDecorExpr(expr(it), s);
           }
           addLocAnn(RESULT, getLocation(it, s));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= inner_term DOT NUMERAL 
    java_cup.runtime.Symbol case437(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int itleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int itright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term it = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int dotleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int dotright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo dot = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int nleft = CUP$Parser$stack.peek().left;
		int nright = CUP$Parser$stack.peek().right;
		LocInt n = (LocInt) CUP$Parser$stack.peek().value;
		
           ZNumeral numeral = factory_.createZNumeral(n.getValue());
           addLocAnn(numeral, n.getLocation());
           RESULT = factory_.createTupleSelExpr(expr(it), numeral);
           LocInfo loc = getLocation(dotleft, dotright, it, n.getLocation());
           addLocAnn(RESULT, loc);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= inner_term DOT refName 
    java_cup.runtime.Symbol case436(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int itleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int itright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term it = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int dotleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int dotright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo dot = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rnleft = CUP$Parser$stack.peek().left;
		int rnright = CUP$Parser$stack.peek().right;
		ZName rn = (ZName) CUP$Parser$stack.peek().value;
		

             RESULT = factory_.createBindSelExpr(expr(it), rn);

           addLocAnn(RESULT, getLocation(dotleft, dotright, it, rn));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= LSQUARE schemaTextNoExpression RSQUARE 
    java_cup.runtime.Symbol case435(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lsqleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lsqright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo lsq = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int stneleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int stneright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		SchText stne = (SchText) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rsqleft = CUP$Parser$stack.peek().left;
		int rsqright = CUP$Parser$stack.peek().right;
		LocInfo rsq = (LocInfo) CUP$Parser$stack.peek().value;
		

           RESULT = factory_.createSchExpr(stne);

           addLocAnn(RESULT, getLocation(lsq, rsq));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= LSQUARE RSQUARE 
    java_cup.runtime.Symbol case434(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lsqleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int lsqright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo lsq = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rsqleft = CUP$Parser$stack.peek().left;
		int rsqright = CUP$Parser$stack.peek().right;
		LocInfo rsq = (LocInfo) CUP$Parser$stack.peek().value;
		
           DeclList dl = factory_.createZDeclList();
           SchText st = factory_.createZSchText(dl, null);

             RESULT = factory_.createSchExpr(st);

           addLocAnn(RESULT, getLocation(lsq, rsq));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= LBIND optConstDeclList RBIND 
    java_cup.runtime.Symbol case433(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lbindleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lbindright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo lbind = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cdlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int cdlright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZDeclList cdl = (ZDeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rbindleft = CUP$Parser$stack.peek().left;
		int rbindright = CUP$Parser$stack.peek().right;
		LocInfo rbind = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createBindExpr(cdl);
           addLocAnn(RESULT, getLocation(lbind, rbind));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= nofixApp 
    java_cup.runtime.Symbol case432(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int nfaleft = CUP$Parser$stack.peek().left;
		int nfaright = CUP$Parser$stack.peek().right;
		Expr nfa = (Expr) CUP$Parser$stack.peek().value;
		 RESULT = nfa; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= nofixRel 
    java_cup.runtime.Symbol case431(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int nfrleft = CUP$Parser$stack.peek().left;
		int nfrright = CUP$Parser$stack.peek().right;
		MemPred nfr = (MemPred) CUP$Parser$stack.peek().value;
		 RESULT = nfr; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= LPAREN MU schemaText RPAREN 
    java_cup.runtime.Symbol case430(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lparenleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lparenright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo lparen = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int muleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int muright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo mu = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int stleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int stright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		SchText st = (SchText) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rparenleft = CUP$Parser$stack.peek().left;
		int rparenright = CUP$Parser$stack.peek().right;
		LocInfo rparen = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createMuExpr(st, null);
           addLocAnn(RESULT, getLocation(muleft, muright, lparen, rparen));
           RESULT.getAnns().add(factory_.createParenAnn());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= LPAREN expressionList COMMA expression RPAREN 
    java_cup.runtime.Symbol case429(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lparenleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int lparenright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo lparen = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int elleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int elright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		ZExprList el = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Expr e = (Expr) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rparenleft = CUP$Parser$stack.peek().left;
		int rparenright = CUP$Parser$stack.peek().right;
		LocInfo rparen = (LocInfo) CUP$Parser$stack.peek().value;
		
           el.add(e);
           RESULT = factory_.createTupleExpr(el);
           addLocAnn(RESULT, getLocation(lparen, rparen));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= LBRACE schemaTextNoExpression RBRACE 
    java_cup.runtime.Symbol case428(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lbraceleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lbraceright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo lbrace = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int stneleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int stneright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		SchText stne = (SchText) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rbraceleft = CUP$Parser$stack.peek().left;
		int rbraceright = CUP$Parser$stack.peek().right;
		LocInfo rbrace = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createSetCompExpr(stne, null);
           addLocAnn(RESULT, getLocation(lbrace, rbrace));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= LBRACE schemaText SPOT expression RBRACE 
    java_cup.runtime.Symbol case427(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lbraceleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int lbraceright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo lbrace = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int stleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int stright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		SchText st = (SchText) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Expr e = (Expr) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rbraceleft = CUP$Parser$stack.peek().left;
		int rbraceright = CUP$Parser$stack.peek().right;
		LocInfo rbrace = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createSetCompExpr(st, e);
           addLocAnn(RESULT, getLocation(lbrace, rbrace));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //inner_term ::= LBRACE optExpressionList RBRACE 
    java_cup.runtime.Symbol case426(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lbraceleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lbraceright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo lbrace = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int oelleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int oelright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZExprList oel = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rbraceleft = CUP$Parser$stack.peek().left;
		int rbraceright = CUP$Parser$stack.peek().right;
		LocInfo rbrace = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createSetExpr(oel);
           addLocAnn(RESULT, getLocation(lbrace, rbrace));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("inner_term",65, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //func_appl ::= inner_term 
    java_cup.runtime.Symbol case425(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int itleft = CUP$Parser$stack.peek().left;
		int itright = CUP$Parser$stack.peek().right;
		Term it = (Term) CUP$Parser$stack.peek().value;
		 RESULT = it; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("func_appl",64, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //func_appl ::= func_appl inner_term 
    java_cup.runtime.Symbol case424(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int faleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int faright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Term fa = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int itleft = CUP$Parser$stack.peek().left;
		int itright = CUP$Parser$stack.peek().right;
		Term it = (Term) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createApplExpr(expr(fa), expr(it), Boolean.FALSE);
           addLocAnn(RESULT, getLocation(fa, it));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("func_appl",64, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //communicationList ::= communication 
    java_cup.runtime.Symbol case423(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Communication> RESULT =null;/*3*/
		int cleft = CUP$Parser$stack.peek().left;
		int cright = CUP$Parser$stack.peek().right;
		Communication c = (Communication) CUP$Parser$stack.peek().value;
		
        	// NOTE: Typechecker takes this pattern into account to know what's implictly given in fields.
           c.setCommPattern(CommPattern.ChannelSet);
           RESULT = factory_.list(c);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("communicationList",163, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //communicationList ::= communicationList COMMA communication 
    java_cup.runtime.Symbol case422(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Communication> RESULT =null;/*3*/
		int clleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int clright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Communication> cl = (List<Communication>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cleft = CUP$Parser$stack.peek().left;
		int cright = CUP$Parser$stack.peek().right;
		Communication c = (Communication) CUP$Parser$stack.peek().value;
		
           // NOTE: Typechecker takes this pattern into account to know what's implictly given in fields.
           //		Because communication:c appears earlier in 7390, the below might/won't match?
           c.setCommPattern(CommPattern.ChannelSet);
           cl.add(c);
           RESULT = cl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("communicationList",163, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= LCIRCCHANSET RCIRCCHANSET 
    java_cup.runtime.Symbol case421(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lcleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int lcright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo lc = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rcleft = CUP$Parser$stack.peek().left;
		int rcright = CUP$Parser$stack.peek().right;
		LocInfo rc = (LocInfo) CUP$Parser$stack.peek().value;
		
           CztLogger.getLogger(Parser.class).fine("BASIC-CHANSET-EXPR: empty for " + getDialect().toString() + " in Parser.");
           RESULT = createBasicChannelSetExpr(getLocation(lc, rc), factory_.<Communication>list());
           addLocAnn(RESULT, getLocation(lc, rc));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= LCIRCCHANSET communicationList RCIRCCHANSET 
    java_cup.runtime.Symbol case420(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lcleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lcright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo lc = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int oclleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int oclright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<Communication> ocl = (List<Communication>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rcleft = CUP$Parser$stack.peek().left;
		int rcright = CUP$Parser$stack.peek().right;
		LocInfo rc = (LocInfo) CUP$Parser$stack.peek().value;
		
           CztLogger.getLogger(Parser.class).fine("BASIC-CHANSET-EXPR: " + ocl + " for " + getDialect().toString() + " in Parser.");
           RESULT = createBasicChannelSetExpr(getLocation(lc, rc), ocl);
           addLocAnn(RESULT, getLocation(lc, rc));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= func_appl 
    java_cup.runtime.Symbol case419(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int faleft = CUP$Parser$stack.peek().left;
		int faright = CUP$Parser$stack.peek().right;
		Term fa = (Term) CUP$Parser$stack.peek().value;
		 RESULT = fa; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= application 
    java_cup.runtime.Symbol case418(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int aleft = CUP$Parser$stack.peek().left;
		int aright = CUP$Parser$stack.peek().right;
		Expr a = (Expr) CUP$Parser$stack.peek().value;
		 RESULT = a; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= relation 
    java_cup.runtime.Symbol case417(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int relleft = CUP$Parser$stack.peek().left;
		int relright = CUP$Parser$stack.peek().right;
		Pred rel = (Pred) CUP$Parser$stack.peek().value;
		 RESULT = rel; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= prodExpressionList 
    java_cup.runtime.Symbol case416(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int pelleft = CUP$Parser$stack.peek().left;
		int pelright = CUP$Parser$stack.peek().right;
		ZExprList pel = (ZExprList) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createProdExpr(pel);
           LocInfo loc =
             getLocation(pelleft, pelright, pel.get(0), pel.get(pel.size()-1));
           addLocAnn(RESULT, loc);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= POWER term 
    java_cup.runtime.Symbol case415(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int powerleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int powerright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo power = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		Term t = (Term) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createPowerExpr(expr(t));
           addLocAnn(RESULT, getLocation(power, t));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= ZPRE term 
    java_cup.runtime.Symbol case414(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int preleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int preright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo pre = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		Term t = (Term) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createPreExpr(expr(t));
           addLocAnn(RESULT, getLocation(pre, t));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= term ZPROJ term 
    java_cup.runtime.Symbol case413(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lhsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lhsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term lhs = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int projleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int projright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo proj = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		Term rhs = (Term) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createProjExpr(expr(lhs), expr(rhs));
           addLocAnn(RESULT, getLocation(projleft, projright, lhs, rhs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= term ZHIDE LPAREN refNameList RPAREN 
    java_cup.runtime.Symbol case412(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int tleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int tright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Term t = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int hideleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int hideright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo hide = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int rnlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rnlright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<ZName> rnl = (List<ZName>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rparenleft = CUP$Parser$stack.peek().left;
		int rparenright = CUP$Parser$stack.peek().right;
		LocInfo rparen = (LocInfo) CUP$Parser$stack.peek().value;
		
           ZNameList zNameList = factory_.createZNameList(rnl);

             RESULT = factory_.createHideExpr(expr(t), zNameList);

           addLocAnn(RESULT, getLocation(hideleft, hideright, t, rparen));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= term ZPIPE term 
    java_cup.runtime.Symbol case411(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lhsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lhsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term lhs = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int pipeleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int piperight = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo pipe = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		Term rhs = (Term) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createPipeExpr(expr(lhs), expr(rhs));
           addLocAnn(RESULT, getLocation(pipeleft, piperight, lhs, rhs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= term ZCOMP term 
    java_cup.runtime.Symbol case410(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lhsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lhsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term lhs = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int compleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int compright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo comp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		Term rhs = (Term) CUP$Parser$stack.peek().value;
		

             RESULT = factory_.createCompExpr(expr(lhs), expr(rhs));

           addLocAnn(RESULT, getLocation(compleft, compright, lhs, rhs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= NOT term 
    java_cup.runtime.Symbol case409(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int notleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int notright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo not = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		Term t = (Term) CUP$Parser$stack.peek().value;
		
          if (t instanceof Expr) {
            RESULT = factory_.createNegExpr(expr(t));
          }
          else {
            RESULT = factory_.createNegPred(pred(t));
          }
          addLocAnn(RESULT, getLocation(not, t));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= term AND term 
    java_cup.runtime.Symbol case408(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lhsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lhsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term lhs = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int andleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int andright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo and = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		Term rhs = (Term) CUP$Parser$stack.peek().value;
		

          if (lhs instanceof Expr && rhs instanceof Expr) {
            RESULT = factory_.createAndExpr(expr(lhs), expr(rhs));
          }
          else {
            RESULT = factory_.createAndPred(pred(lhs), pred(rhs), And.Wedge);
          }
          addLocAnn(RESULT, getLocation(andleft, andright, lhs, rhs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= term OR term 
    java_cup.runtime.Symbol case407(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lhsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lhsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term lhs = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int orleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int orright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo or = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		Term rhs = (Term) CUP$Parser$stack.peek().value;
		
          if (lhs instanceof Expr && rhs instanceof Expr) {
            RESULT = factory_.createOrExpr(expr(lhs), expr(rhs));
          }
          else {
            RESULT = factory_.createOrPred(pred(lhs), pred(rhs));
          }
          addLocAnn(RESULT, getLocation(orleft, orright, lhs, rhs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= term IMP term 
    java_cup.runtime.Symbol case406(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lhsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lhsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term lhs = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int impleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int impright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo imp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		Term rhs = (Term) CUP$Parser$stack.peek().value;
		
          if (lhs instanceof Expr && rhs instanceof Expr) {
            RESULT = factory_.createImpliesExpr(expr(lhs), expr(rhs));
          }
          else {
            RESULT = factory_.createImpliesPred(pred(lhs), pred(rhs));
          }
          addLocAnn(RESULT, getLocation(impleft, impright, lhs, rhs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= term IFF term 
    java_cup.runtime.Symbol case405(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lhsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lhsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term lhs = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int iffleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int iffright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo iff = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		Term rhs = (Term) CUP$Parser$stack.peek().value;
		
          if (lhs instanceof Expr && rhs instanceof Expr) {
            RESULT = factory_.createIffExpr(expr(lhs), expr(rhs));
          }
          else {
            RESULT = factory_.createIffPred(pred(lhs), pred(rhs));
          }
          addLocAnn(RESULT, getLocation(iffleft, iffright, lhs, rhs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= LET letDefinitionList SPOT term 
    java_cup.runtime.Symbol case404(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int letleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int letright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo let = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int ldlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ldlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZDeclList ldl = (ZDeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		Term t = (Term) CUP$Parser$stack.peek().value;
		
           ZSchText st = factory_.createZSchText(ldl, null);
           RESULT = factory_.createLetExpr(st, expr(t));
           addLocAnn(RESULT, getLocation(let, t));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= MU schemaText SPOT term 
    java_cup.runtime.Symbol case403(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int muleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int muright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo mu = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int stleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int stright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		SchText st = (SchText) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		Term t = (Term) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createMuExpr(st, expr(t));
           addLocAnn(RESULT, getLocation(mu, t));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= LAMBDA schemaText SPOT term 
    java_cup.runtime.Symbol case402(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lambdaleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lambdaright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo lambda = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int stleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int stright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		SchText st = (SchText) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		Term t = (Term) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createLambdaExpr(st, expr(t));
           addLocAnn(RESULT, getLocation(lambda, t));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= EXIONE schemaText SPOT term 
    java_cup.runtime.Symbol case401(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int exioneleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int exioneright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo exione = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int stleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int stright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		SchText st = (SchText) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		Term t = (Term) CUP$Parser$stack.peek().value;
		
           if (t instanceof Expr) {
             RESULT = factory_.createExists1Expr(st, expr(t));
           }
           else {
             RESULT = factory_.createExists1Pred(st, pred(t));
           }
           addLocAnn(RESULT, getLocation(exione, t));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= EXI schemaText SPOT term 
    java_cup.runtime.Symbol case400(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int exileft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int exiright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo exi = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int stleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int stright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		SchText st = (SchText) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		Term t = (Term) CUP$Parser$stack.peek().value;
		
           if (t instanceof Expr) {
             RESULT = factory_.createExistsExpr(st, expr(t));
           }
           else {
             RESULT = factory_.createExistsPred(st, pred(t));
           }
           addLocAnn(RESULT, getLocation(exi, t));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= ALL schemaText SPOT term 
    java_cup.runtime.Symbol case399(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int allleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int allright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo all = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int stleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int stright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		SchText st = (SchText) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		Term t = (Term) CUP$Parser$stack.peek().value;
		
           if (t instanceof Expr) {
             RESULT = factory_.createForallExpr(st, expr(t));
           }
           else {
             RESULT = factory_.createForallPred(st, pred(t));
           }
           addLocAnn(RESULT, getLocation(all, t));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //term ::= IF predicate THEN term ELSE term 
    java_cup.runtime.Symbol case398(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int ileft = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int iright = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		LocInfo i = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int pleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int pright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Pred p = (Pred) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int teleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int teright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term te = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int feleft = CUP$Parser$stack.peek().left;
		int feright = CUP$Parser$stack.peek().right;
		Term fe = (Term) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createCondExpr(p, expr(te), expr(fe));
           addLocAnn(RESULT, getLocation(i, fe));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",62, CUP$Parser$stack.elementAt(CUP$Parser$top-5), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //septerm ::= term 
    java_cup.runtime.Symbol case397(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		Term t = (Term) CUP$Parser$stack.peek().value;
		 RESULT = t; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("septerm",63, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //septerm ::= septerm sep term 
    java_cup.runtime.Symbol case396(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int lhsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lhsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Term lhs = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int sleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int sright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		And s = (And) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		Term rhs = (Term) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createAndPred(pred(lhs), pred(rhs), s);
           addLocAnn(RESULT, getLocation(sleft, sright, lhs, rhs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("septerm",63, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //expression ::= term 
    java_cup.runtime.Symbol case395(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Expr RESULT =null;/*3*/
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		Term t = (Term) CUP$Parser$stack.peek().value;
		 RESULT = expr(t); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression",76, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //predicate ::= term 
    java_cup.runtime.Symbol case394(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pred RESULT =null;/*3*/
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		Term p = (Term) CUP$Parser$stack.peek().value;
		
            RESULT = pred(p);
            
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("predicate",69, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //predicate ::= predicate sep term 
    java_cup.runtime.Symbol case393(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pred RESULT =null;/*3*/
		int lhsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lhsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Pred lhs = (Pred) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int sleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int sright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		And s = (And) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rhsleft = CUP$Parser$stack.peek().left;
		int rhsright = CUP$Parser$stack.peek().right;
		Term rhs = (Term) CUP$Parser$stack.peek().value;
		
           Pred rhsp = pred(rhs);
           
           RESULT = factory_.createAndPred(lhs, rhsp, s);
           addLocAnn(RESULT, getLocation(sleft, sright, lhs, rhs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("predicate",69, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //erOrSr ::= SR 
    java_cup.runtime.Symbol case392(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int srleft = CUP$Parser$stack.peek().left;
		int srright = CUP$Parser$stack.peek().right;
		LocString sr = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = sr; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("erOrSr",107, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //erOrSr ::= ER 
    java_cup.runtime.Symbol case391(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int erleft = CUP$Parser$stack.peek().left;
		int erright = CUP$Parser$stack.peek().right;
		LocString er = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = er; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("erOrSr",107, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //ereOrSre ::= SRE 
    java_cup.runtime.Symbol case390(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int sreleft = CUP$Parser$stack.peek().left;
		int sreright = CUP$Parser$stack.peek().right;
		LocString sre = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = sre; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ereOrSre",106, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //ereOrSre ::= ERE 
    java_cup.runtime.Symbol case389(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int ereleft = CUP$Parser$stack.peek().left;
		int ereright = CUP$Parser$stack.peek().right;
		LocString ere = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = ere; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ereOrSre",106, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //esOrSs ::= SS 
    java_cup.runtime.Symbol case388(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int ssleft = CUP$Parser$stack.peek().left;
		int ssright = CUP$Parser$stack.peek().right;
		LocString ss = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = ss; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("esOrSs",108, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //esOrSs ::= ES 
    java_cup.runtime.Symbol case387(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int esleft = CUP$Parser$stack.peek().left;
		int esright = CUP$Parser$stack.peek().right;
		LocString es = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = es; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("esOrSs",108, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optNameEsSsList ::= optNameEsSsList name esOrSs 
    java_cup.runtime.Symbol case386(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pair<ZNameList,ZNameList> RESULT =null;/*3*/
		int oueslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int oueslright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") Pair<ZNameList,ZNameList> ouesl = (Pair<ZNameList,ZNameList>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int fpnleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int fpnright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Name fpn = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int eosleft = CUP$Parser$stack.peek().left;
		int eosright = CUP$Parser$stack.peek().right;
		LocString eos = (LocString) CUP$Parser$stack.peek().value;
		
           ZNameList gens = ouesl.getFirst();
           gens.add(fpn);
           List<ZNameList> name = factory_.list(ouesl.getSecond());
           // BUG?/TODO: This can't be right. The result is a list of ZNameLists and
           //			 the code just adds two strings to the list?
           //
           // NOTE: This template is for rather complex (i.e. ternary etc) generic operator template.
           //		Surprisingly, there are non in the standard toolkit, and the standard itself is
           //		rather vague about examples of such complex operators. We tried but couldn't create
           //		an example to "test" this production, but at least now the types are right.
           //name.add(ARG_TOK);
           //name.add(eos.getString());
           name.add(factory_.createZNameList(
 		  		factory_.list(factory_.createZName(ARG_TOK), 
   					  factory_.createZName(eos.getString()))));
           RESULT = ouesl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optNameEsSsList",93, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optNameEsSsList ::= 
    java_cup.runtime.Symbol case385(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pair<ZNameList,ZNameList> RESULT =null;/*3*/
		 RESULT = new Pair<ZNameList, ZNameList>(factory_.createZNameList(),
                             factory_.createZNameList()); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optNameEsSsList",93, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //nofixGenName ::= L optNameEsSsList name erOrSr 
    java_cup.runtime.Symbol case384(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pair<Name,ZNameList> RESULT =null;/*3*/
		int lleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocString l = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int oneslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int oneslright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") Pair<ZNameList,ZNameList> onesl = (Pair<ZNameList,ZNameList>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int fpnleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int fpnright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Name fpn = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int eosleft = CUP$Parser$stack.peek().left;
		int eosright = CUP$Parser$stack.peek().right;
		LocString eos = (LocString) CUP$Parser$stack.peek().value;
		
           //construct the name
           List<String> name = factory_.list(l.getString());
           
           // BUGFIX:
           // NOTE: This template is for rather complex (i.e. ternary etc) generic operator template.
           //		Surprisingly, there are non in the standard toolkit, and the standard itself is
           //		rather vague about examples of such complex operators. We tried but couldn't create
           //		an example to "test" this production, but at least now the types are right.
           //name.addAll((List) onesl.getSecond());
           name.addAll(extractNamesFromNameList(onesl.getSecond()));
           
           name.add(ARG_TOK);
           name.add(eos.getString());

           //construct the parameter list
           ZNameList fps = onesl.getFirst();
           fps.add(fpn);
           LocInfo loc = getLocation(eosleft, eosright);
           Name declName = strListToZName(name, loc);
           RESULT = new Pair<Name, ZNameList>(declName, fps);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("nofixGenName",91, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixGenName ::= name EL optNameEsSsList name ereOrSre name 
    java_cup.runtime.Symbol case383(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pair<Name,ZNameList> RESULT =null;/*3*/
		int fpn1left = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int fpn1right = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		Name fpn1 = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int elleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int elright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocString el = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int oneslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int oneslright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		@SuppressWarnings("unchecked") Pair<ZNameList,ZNameList> onesl = (Pair<ZNameList,ZNameList>) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int fpn2left = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int fpn2right = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Name fpn2 = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eosleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eosright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString eos = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int fpn3left = CUP$Parser$stack.peek().left;
		int fpn3right = CUP$Parser$stack.peek().right;
		Name fpn3 = (Name) CUP$Parser$stack.peek().value;
		
           //construct the name
           List<String> name = factory_.list(ARG_TOK);
           name.add(el.getString());

           // BUGFIX:
           // NOTE: This template is for rather complex (i.e. ternary etc) generic operator template.
           //		Surprisingly, there are non in the standard toolkit, and the standard itself is
           //		rather vague about examples of such complex operators. We tried but couldn't create
           //		an example to "test" this production, but at least now the types are right.
           //name.addAll((List) onesl.getSecond());
           name.addAll(extractNamesFromNameList(onesl.getSecond()));

           name.add(ARG_TOK);
           name.add(eos.getString());
           name.add(ARG_TOK);
           //construct the parameter list
           ZNameList fps = factory_.createZNameList();
           fps.add(fpn1);
           fps.addAll(onesl.getFirst());
           fps.add(fpn2);
           fps.add(fpn3);
           LocInfo loc = getLocation(fpn3left, fpn3right);
           Name declName = strListToZName(name, loc);
           RESULT = new Pair<Name, ZNameList>(declName, fps);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixGenName",90, CUP$Parser$stack.elementAt(CUP$Parser$top-5), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixGenName ::= name I name 
    java_cup.runtime.Symbol case382(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pair<Name,ZNameList> RESULT =null;/*3*/
		int fpn1left = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int fpn1right = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Name fpn1 = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int ileft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int iright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString i = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int fpn2left = CUP$Parser$stack.peek().left;
		int fpn2right = CUP$Parser$stack.peek().right;
		Name fpn2 = (Name) CUP$Parser$stack.peek().value;
		
           //construct the name
           List<String> name = factory_.list(ARG_TOK);
           name.add(i.getString());
           name.add(ARG_TOK);

           //construct the parameter list
           ZNameList fps = factory_.createZNameList();
           fps.add(fpn1);
           fps.add(fpn2);
           LocInfo loc = getLocation(fpn2left, fpn2right);
           Name declName = strListToZName(name, loc);
           RESULT = new Pair<Name, ZNameList>(declName, fps);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixGenName",90, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //postfixGenName ::= name EL optNameEsSsList name erOrSr 
    java_cup.runtime.Symbol case381(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pair<Name,ZNameList> RESULT =null;/*3*/
		int fpn1left = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int fpn1right = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Name fpn1 = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int elleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int elright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocString el = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int oneslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int oneslright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") Pair<ZNameList,ZNameList> onesl = (Pair<ZNameList,ZNameList>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int fpn2left = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int fpn2right = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Name fpn2 = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int eosleft = CUP$Parser$stack.peek().left;
		int eosright = CUP$Parser$stack.peek().right;
		LocString eos = (LocString) CUP$Parser$stack.peek().value;
		
           //construct the name
           List<String> name = factory_.list(ARG_TOK);
           name.add(el.getString());

           // BUGFIX:
           // NOTE: This template is for rather complex (i.e. ternary etc) generic operator template.
           //		Surprisingly, there are non in the standard toolkit, and the standard itself is
           //		rather vague about examples of such complex operators. We tried but couldn't create
           //		an example to "test" this production, but at least now the types are right.
           //name.addAll((List) onesl.getSecond());
           name.addAll(extractNamesFromNameList(onesl.getSecond()));

           name.add(ARG_TOK);
           name.add(eos.getString());

           //construct the parameter list
           ZNameList fps = factory_.createZNameList();
           fps.add(fpn1);
           fps.addAll(onesl.getFirst());
           fps.add(fpn2);
           LocInfo loc = getLocation(eosleft, eosright);
           Name declName = strListToZName(name, loc);
           RESULT = new Pair<Name, ZNameList>(declName, fps);
         /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("postfixGenName",89, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //postfixGenName ::= name POST 
    java_cup.runtime.Symbol case380(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pair<Name,ZNameList> RESULT =null;/*3*/
		int fpnleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int fpnright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Name fpn = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		LocString p = (LocString) CUP$Parser$stack.peek().value;
		
           List<String> name = factory_.list(ARG_TOK, p.getString());
           ZNameList decls = factory_.createZNameList();
           decls.add(fpn);
           LocInfo loc = getLocation(pleft, pright);
           Name declName = strListToZName(name, loc);
           RESULT = new Pair<Name, ZNameList>(declName, decls);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("postfixGenName",89, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //prefixGenName ::= L optNameEsSsList name ereOrSre name 
    java_cup.runtime.Symbol case379(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pair<Name,ZNameList> RESULT =null;/*3*/
		int lleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int lright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocString l = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int oneslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int oneslright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		@SuppressWarnings("unchecked") Pair<ZNameList,ZNameList> onesl = (Pair<ZNameList,ZNameList>) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int fpn1left = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int fpn1right = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Name fpn1 = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eosleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eosright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString eos = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int fpn2left = CUP$Parser$stack.peek().left;
		int fpn2right = CUP$Parser$stack.peek().right;
		Name fpn2 = (Name) CUP$Parser$stack.peek().value;
		
           //construct the name
           List<String> name = factory_.list(l.getString());
           
           // BUGFIX:
           // NOTE: This template is for rather complex (i.e. ternary etc) generic operator template.
           //		Surprisingly, there are non in the standard toolkit, and the standard itself is
           //		rather vague about examples of such complex operators. We tried but couldn't create
           //		an example to "test" this production, but at least now the types are right.
           //name.addAll((List) onesl.getSecond());
           name.addAll(extractNamesFromNameList(onesl.getSecond()));
           name.add(ARG_TOK);
           name.add(eos.getString());
           name.add(ARG_TOK);

           //construct the parameter list
           ZNameList fps = onesl.getFirst();
           fps.add(fpn1);
           fps.add(fpn2);
           LocInfo loc = getLocation(fpn2left, fpn2right);
           Name declName = strListToZName(name, loc);
           RESULT = new Pair<Name, ZNameList>(declName, fps);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("prefixGenName",88, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //prefixGenName ::= PRE name 
    java_cup.runtime.Symbol case378(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pair<Name,ZNameList> RESULT =null;/*3*/
		int preleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int preright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString pre = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int formalParameterleft = CUP$Parser$stack.peek().left;
		int formalParameterright = CUP$Parser$stack.peek().right;
		Name formalParameter = (Name) CUP$Parser$stack.peek().value;
		
           List<String> name = factory_.list(pre.getString(), ARG_TOK);
           ZNameList decls = factory_.createZNameList();
           decls.add(formalParameter);
           LocInfo loc = getLocation(formalParameterleft,
                                     formalParameterright);
           Name declName = strListToZName(name, loc);
           RESULT = new Pair<Name, ZNameList>(declName, decls);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("prefixGenName",88, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //genName ::= nofixGenName 
    java_cup.runtime.Symbol case377(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pair<Name,ZNameList> RESULT =null;/*3*/
		int ngnleft = CUP$Parser$stack.peek().left;
		int ngnright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") Pair<Name,ZNameList> ngn = (Pair<Name,ZNameList>) CUP$Parser$stack.peek().value;
		 RESULT = ngn; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("genName",87, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //genName ::= infixGenName 
    java_cup.runtime.Symbol case376(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pair<Name,ZNameList> RESULT =null;/*3*/
		int ignleft = CUP$Parser$stack.peek().left;
		int ignright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") Pair<Name,ZNameList> ign = (Pair<Name,ZNameList>) CUP$Parser$stack.peek().value;
		 RESULT = ign; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("genName",87, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //genName ::= postfixGenName 
    java_cup.runtime.Symbol case375(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pair<Name,ZNameList> RESULT =null;/*3*/
		int pgnleft = CUP$Parser$stack.peek().left;
		int pgnright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") Pair<Name,ZNameList> pgn = (Pair<Name,ZNameList>) CUP$Parser$stack.peek().value;
		 RESULT = pgn; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("genName",87, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //genName ::= prefixGenName 
    java_cup.runtime.Symbol case374(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pair<Name,ZNameList> RESULT =null;/*3*/
		int pgnleft = CUP$Parser$stack.peek().left;
		int pgnright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") Pair<Name,ZNameList> pgn = (Pair<Name,ZNameList>) CUP$Parser$stack.peek().value;
		 RESULT = pgn; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("genName",87, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //argErpOrSrp ::= LISTARG SRP 
    java_cup.runtime.Symbol case373(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int srpleft = CUP$Parser$stack.peek().left;
		int srpright = CUP$Parser$stack.peek().right;
		LocString srp = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = factory_.list(LISTARG_TOK, srp.getString()); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argErpOrSrp",104, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //argErpOrSrp ::= ARG ERP 
    java_cup.runtime.Symbol case372(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int erpleft = CUP$Parser$stack.peek().left;
		int erpright = CUP$Parser$stack.peek().right;
		LocString erp = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = factory_.list(ARG_TOK, erp.getString()); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argErpOrSrp",104, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //argErOrSr ::= LISTARG SR 
    java_cup.runtime.Symbol case371(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int srleft = CUP$Parser$stack.peek().left;
		int srright = CUP$Parser$stack.peek().right;
		LocString sr = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = factory_.list(LISTARG_TOK, sr.getString()); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argErOrSr",102, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //argErOrSr ::= ARG ER 
    java_cup.runtime.Symbol case370(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int erleft = CUP$Parser$stack.peek().left;
		int erright = CUP$Parser$stack.peek().right;
		LocString er = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = factory_.list(ARG_TOK, er.getString()); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argErOrSr",102, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //argErepOrSrep ::= LISTARG SREP 
    java_cup.runtime.Symbol case369(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int srepleft = CUP$Parser$stack.peek().left;
		int srepright = CUP$Parser$stack.peek().right;
		LocString srep = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = factory_.list(LISTARG_TOK, srep.getString()); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argErepOrSrep",100, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //argErepOrSrep ::= ARG EREP 
    java_cup.runtime.Symbol case368(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int erepleft = CUP$Parser$stack.peek().left;
		int erepright = CUP$Parser$stack.peek().right;
		LocString erep = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = factory_.list(ARG_TOK, erep.getString()); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argErepOrSrep",100, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //argEreOrSre ::= LISTARG SRE 
    java_cup.runtime.Symbol case367(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int sreleft = CUP$Parser$stack.peek().left;
		int sreright = CUP$Parser$stack.peek().right;
		LocString sre = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = factory_.list(LISTARG_TOK, sre.getString()); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argEreOrSre",101, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //argEreOrSre ::= ARG ERE 
    java_cup.runtime.Symbol case366(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int ereleft = CUP$Parser$stack.peek().left;
		int ereright = CUP$Parser$stack.peek().right;
		LocString ere = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = factory_.list(ARG_TOK, ere.getString()); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argEreOrSre",101, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //argEsOrSs ::= LISTARG SS 
    java_cup.runtime.Symbol case365(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int ssleft = CUP$Parser$stack.peek().left;
		int ssright = CUP$Parser$stack.peek().right;
		LocString ss = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = factory_.list(LISTARG_TOK, ss.getString()); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argEsOrSs",103, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //argEsOrSs ::= ARG ES 
    java_cup.runtime.Symbol case364(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int esleft = CUP$Parser$stack.peek().left;
		int esright = CUP$Parser$stack.peek().right;
		LocString es = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = factory_.list(ARG_TOK, es.getString()); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argEsOrSs",103, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optVargEsSsList ::= optVargEsSsList argEsOrSs 
    java_cup.runtime.Symbol case363(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int oueslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int oueslright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<String> ouesl = (List<String>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int aeosleft = CUP$Parser$stack.peek().left;
		int aeosright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<String> aeos = (List<String>) CUP$Parser$stack.peek().value;
		
           ouesl.addAll(aeos);
           RESULT = ouesl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optVargEsSsList",92, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optVargEsSsList ::= 
    java_cup.runtime.Symbol case362(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		 RESULT = factory_.list(); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optVargEsSsList",92, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //nofixName ::= LP optVargEsSsList argErpOrSrp 
    java_cup.runtime.Symbol case361(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocString lp = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int oueslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int oueslright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<String> ouesl = (List<String>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int aeosleft = CUP$Parser$stack.peek().left;
		int aeosright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<String> aeos = (List<String>) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.list(lp.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("nofixName",86, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //nofixName ::= L optVargEsSsList argErOrSr 
    java_cup.runtime.Symbol case360(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int lleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocString l = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int oueslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int oueslright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<String> ouesl = (List<String>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int aeosleft = CUP$Parser$stack.peek().left;
		int aeosright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<String> aeos = (List<String>) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.list(l.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("nofixName",86, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixName ::= varg ELP optVargEsSsList argErepOrSrep varg 
    java_cup.runtime.Symbol case359(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int elpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int elpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocString elp = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int oueslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int oueslright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<String> ouesl = (List<String>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int aeosleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int aeosright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<String> aeos = (List<String>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           RESULT = factory_.list(ARG_TOK);
           RESULT.add(elp.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
           RESULT.add(ARG_TOK);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixName",85, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixName ::= varg EL optVargEsSsList argEreOrSre varg 
    java_cup.runtime.Symbol case358(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int elleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int elright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocString el = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int oueslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int oueslright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<String> ouesl = (List<String>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int aeosleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int aeosright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<String> aeos = (List<String>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           RESULT = factory_.list(ARG_TOK);
           RESULT.add(el.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
           RESULT.add(ARG_TOK);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixName",85, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixName ::= varg IP varg 
    java_cup.runtime.Symbol case357(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int ipleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int ipright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString ip = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           RESULT = factory_.list(ARG_TOK);
           RESULT.add(ip.getString());
           RESULT.add(ARG_TOK);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixName",85, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixName ::= varg I varg 
    java_cup.runtime.Symbol case356(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int ileft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int iright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString i = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           RESULT = factory_.list(ARG_TOK);
           RESULT.add(i.getString());
           RESULT.add(ARG_TOK);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixName",85, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //postfixName ::= varg ELP optVargEsSsList argErpOrSrp 
    java_cup.runtime.Symbol case355(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int elpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int elpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocString elp = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int oueslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int oueslright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<String> ouesl = (List<String>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int aeosleft = CUP$Parser$stack.peek().left;
		int aeosright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<String> aeos = (List<String>) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.list(ARG_TOK);
           RESULT.add(elp.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("postfixName",84, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //postfixName ::= varg EL optVargEsSsList argErOrSr 
    java_cup.runtime.Symbol case354(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int elleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int elright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocString el = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int oueslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int oueslright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<String> ouesl = (List<String>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int aeosleft = CUP$Parser$stack.peek().left;
		int aeosright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<String> aeos = (List<String>) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.list(ARG_TOK);
           RESULT.add(el.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("postfixName",84, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //postfixName ::= varg POSTP 
    java_cup.runtime.Symbol case353(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		LocString p = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = factory_.list(ARG_TOK, p.getString()); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("postfixName",84, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //postfixName ::= varg POST 
    java_cup.runtime.Symbol case352(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		LocString p = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = factory_.list(ARG_TOK, p.getString()); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("postfixName",84, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //prefixName ::= LP optVargEsSsList argErepOrSrep varg 
    java_cup.runtime.Symbol case351(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocString lp = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int oueslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int oueslright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<String> ouesl = (List<String>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int aeosleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int aeosright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<String> aeos = (List<String>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           RESULT = factory_.list(lp.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
           RESULT.add(ARG_TOK);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("prefixName",83, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //prefixName ::= L optVargEsSsList argEreOrSre varg 
    java_cup.runtime.Symbol case350(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int lleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocString l = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int oueslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int oueslright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<String> ouesl = (List<String>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int aeosleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int aeosright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<String> aeos = (List<String>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           RESULT = factory_.list(l.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
           RESULT.add(ARG_TOK);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("prefixName",83, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //prefixName ::= PREP varg 
    java_cup.runtime.Symbol case349(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int pleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int pright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString p = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		 RESULT = factory_.list(p.getString(), ARG_TOK); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("prefixName",83, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //prefixName ::= PRE varg 
    java_cup.runtime.Symbol case348(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int pleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int pright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocString p = (LocString) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		 RESULT = factory_.list(p.getString(), ARG_TOK); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("prefixName",83, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //opName ::= nofixName 
    java_cup.runtime.Symbol case347(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int nnleft = CUP$Parser$stack.peek().left;
		int nnright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<String> nn = (List<String>) CUP$Parser$stack.peek().value;
		 RESULT = nn; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("opName",82, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //opName ::= infixName 
    java_cup.runtime.Symbol case346(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int inleft = CUP$Parser$stack.peek().left;
		int inright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<String> in = (List<String>) CUP$Parser$stack.peek().value;
		 RESULT = in; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("opName",82, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //opName ::= postfixName 
    java_cup.runtime.Symbol case345(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int pnleft = CUP$Parser$stack.peek().left;
		int pnright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<String> pn = (List<String>) CUP$Parser$stack.peek().value;
		 RESULT = pn; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("opName",82, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //opName ::= prefixName 
    java_cup.runtime.Symbol case344(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<String> RESULT =null;/*3*/
		int pnleft = CUP$Parser$stack.peek().left;
		int pnright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<String> pn = (List<String>) CUP$Parser$stack.peek().value;
		 RESULT = pn; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("opName",82, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //refName ::= LPAREN opName RPAREN 
    java_cup.runtime.Symbol case343(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZName RESULT =null;/*3*/
		int lparenleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lparenright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo lparen = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int onleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int onright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<String> on = (List<String>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rparenleft = CUP$Parser$stack.peek().left;
		int rparenright = CUP$Parser$stack.peek().right;
		LocInfo rparen = (LocInfo) CUP$Parser$stack.peek().value;
		
           final LocInfo loc = getLocation(lparen, rparen);
           RESULT = strListToZName(on, loc);
           RESULT.getAnns().add(factory_.createParenAnn());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("refName",45, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //refName ::= FIELDNAME 
    java_cup.runtime.Symbol case342(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZName RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
           RESULT = createCircusName(dw);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("refName",45, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //refName ::= DECORWORD 
    java_cup.runtime.Symbol case341(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZName RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
           RESULT = createZName(dw);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("refName",45, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //refNameList ::= DECORWORD 
    java_cup.runtime.Symbol case340(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<ZName> RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
           ZName rn = createZName(dw);
           RESULT = factory_.list(rn);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("refNameList",46, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //refNameList ::= refNameList COMMA DECORWORD 
    java_cup.runtime.Symbol case339(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<ZName> RESULT =null;/*3*/
		int rnlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int rnlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<ZName> rnl = (List<ZName>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
           ZName rn = createZName(dw);
           rnl.add(rn);
           RESULT = rnl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("refNameList",46, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //declName ::= opName 
    java_cup.runtime.Symbol case338(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Name RESULT =null;/*3*/
		int onleft = CUP$Parser$stack.peek().left;
		int onright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<String> on = (List<String>) CUP$Parser$stack.peek().value;
		
           LocInfo loc = getLocation(onleft, onright);
           RESULT = strListToZName(on, loc);
           addLocAnn(RESULT, loc);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declName",44, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //declName ::= name 
    java_cup.runtime.Symbol case337(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Name RESULT =null;/*3*/
		int nleft = CUP$Parser$stack.peek().left;
		int nright = CUP$Parser$stack.peek().right;
		Name n = (Name) CUP$Parser$stack.peek().value;
		 RESULT = n; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declName",44, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= SS 
    java_cup.runtime.Symbol case336(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int ssleft = CUP$Parser$stack.peek().left;
		int ssright = CUP$Parser$stack.peek().right;
		LocString ss = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = ss; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= ES 
    java_cup.runtime.Symbol case335(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int esleft = CUP$Parser$stack.peek().left;
		int esright = CUP$Parser$stack.peek().right;
		LocString es = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = es; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= SRE 
    java_cup.runtime.Symbol case334(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int sreleft = CUP$Parser$stack.peek().left;
		int sreright = CUP$Parser$stack.peek().right;
		LocString sre = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = sre; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= SREP 
    java_cup.runtime.Symbol case333(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int srepleft = CUP$Parser$stack.peek().left;
		int srepright = CUP$Parser$stack.peek().right;
		LocString srep = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = srep; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= ERE 
    java_cup.runtime.Symbol case332(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int ereleft = CUP$Parser$stack.peek().left;
		int ereright = CUP$Parser$stack.peek().right;
		LocString ere = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = ere; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= EREP 
    java_cup.runtime.Symbol case331(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int erepleft = CUP$Parser$stack.peek().left;
		int erepright = CUP$Parser$stack.peek().right;
		LocString erep = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = erep; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= SR 
    java_cup.runtime.Symbol case330(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int srleft = CUP$Parser$stack.peek().left;
		int srright = CUP$Parser$stack.peek().right;
		LocString sr = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = sr; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= SRP 
    java_cup.runtime.Symbol case329(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int srpleft = CUP$Parser$stack.peek().left;
		int srpright = CUP$Parser$stack.peek().right;
		LocString srp = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = srp; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= ER 
    java_cup.runtime.Symbol case328(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int erleft = CUP$Parser$stack.peek().left;
		int erright = CUP$Parser$stack.peek().right;
		LocString er = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = er; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= ERP 
    java_cup.runtime.Symbol case327(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int erpleft = CUP$Parser$stack.peek().left;
		int erpright = CUP$Parser$stack.peek().right;
		LocString erp = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = erp; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= EL 
    java_cup.runtime.Symbol case326(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int elleft = CUP$Parser$stack.peek().left;
		int elright = CUP$Parser$stack.peek().right;
		LocString el = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = el; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= ELP 
    java_cup.runtime.Symbol case325(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int elpleft = CUP$Parser$stack.peek().left;
		int elpright = CUP$Parser$stack.peek().right;
		LocString elp = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = elp; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= L 
    java_cup.runtime.Symbol case324(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int lleft = CUP$Parser$stack.peek().left;
		int lright = CUP$Parser$stack.peek().right;
		LocString l = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = l; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= LP 
    java_cup.runtime.Symbol case323(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.peek().left;
		int lpright = CUP$Parser$stack.peek().right;
		LocString lp = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = lp; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= I 
    java_cup.runtime.Symbol case322(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int ileft = CUP$Parser$stack.peek().left;
		int iright = CUP$Parser$stack.peek().right;
		LocString i = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = i; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= IP 
    java_cup.runtime.Symbol case321(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int ipleft = CUP$Parser$stack.peek().left;
		int ipright = CUP$Parser$stack.peek().right;
		LocString ip = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = ip; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= POST 
    java_cup.runtime.Symbol case320(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		LocString p = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = p; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= POSTP 
    java_cup.runtime.Symbol case319(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		LocString p = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = p; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= PRE 
    java_cup.runtime.Symbol case318(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		LocString p = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = p; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //misusedOpName ::= PREP 
    java_cup.runtime.Symbol case317(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      LocString RESULT =null;/*3*/
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		LocString p = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = p; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("misusedOpName",105, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //declWordList ::= misusedOpName 
    java_cup.runtime.Symbol case316(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZNameList RESULT =null;/*3*/
		int monleft = CUP$Parser$stack.peek().left;
		int monright = CUP$Parser$stack.peek().right;
		LocString mon = (LocString) CUP$Parser$stack.peek().value;
		
           misusedOpName(mon);
           RESULT = factory_.createZNameList();
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declWordList",42, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //declWordList ::= DECLWORD 
    java_cup.runtime.Symbol case315(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZNameList RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
           Name dn = createZName(dw);
           RESULT = factory_.createZNameList();
           RESULT.add(dn);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declWordList",42, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //declWordList ::= opName 
    java_cup.runtime.Symbol case314(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZNameList RESULT =null;/*3*/
		int onleft = CUP$Parser$stack.peek().left;
		int onright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<String> on = (List<String>) CUP$Parser$stack.peek().value;
		
           LocInfo loc = getLocation(onleft, onright);
           Name dn = strListToZName(on, loc);
           if (dn != null) {
             addLocAnn(dn, loc);
           }
           RESULT = factory_.createZNameList();
           RESULT.add(dn);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declWordList",42, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //declWordList ::= declWordList COMMA misusedOpName 
    java_cup.runtime.Symbol case313(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZNameList RESULT =null;/*3*/
		int dwlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dwlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList dwl = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int monleft = CUP$Parser$stack.peek().left;
		int monright = CUP$Parser$stack.peek().right;
		LocString mon = (LocString) CUP$Parser$stack.peek().value;
		
           misusedOpName(mon);
           RESULT = factory_.createZNameList();
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declWordList",42, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //declWordList ::= declWordList COMMA opName 
    java_cup.runtime.Symbol case312(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZNameList RESULT =null;/*3*/
		int dwlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dwlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList dwl = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int onleft = CUP$Parser$stack.peek().left;
		int onright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<String> on = (List<String>) CUP$Parser$stack.peek().value;
		
           LocInfo loc = getLocation(onleft, onright);
           Name dn = strListToZName(on, loc);
           if (dn != null) {
             addLocAnn(dn, loc);
             dwl.add(dn);
           }
           RESULT = dwl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declWordList",42, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //declWordList ::= declWordList COMMA DECLWORD 
    java_cup.runtime.Symbol case311(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZNameList RESULT =null;/*3*/
		int dwlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dwlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList dwl = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
           Name dn = createZName(dw);
           dwl.add(dn);
           RESULT = dwl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declWordList",42, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //name ::= DECORWORD 
    java_cup.runtime.Symbol case310(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Name RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
           RESULT = createZName(dw);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("name",43, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //nameList ::= DECORWORD 
    java_cup.runtime.Symbol case309(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZNameList RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
           Name dn = createZName(dw);
           RESULT = factory_.createZNameList();
           RESULT.add(dn);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("nameList",41, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //nameList ::= nameList COMMA DECORWORD 
    java_cup.runtime.Symbol case308(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZNameList RESULT =null;/*3*/
		int nlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList nl = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
           Name dn = createZName(dw);
           nl.add(dn);
           RESULT = nl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("nameList",41, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //sep ::= NL 
    java_cup.runtime.Symbol case307(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      And RESULT =null;/*3*/
		 RESULT = And.NL; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("sep",61, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //sep ::= SEMICOLON 
    java_cup.runtime.Symbol case306(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      And RESULT =null;/*3*/
		 RESULT = And.Semi; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("sep",61, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //constDecl ::= declName DEFEQUAL expression 
    java_cup.runtime.Symbol case305(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ConstDecl RESULT =null;/*3*/
		int dnleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dnright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Name dn = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int defequalleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int defequalright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo defequal = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createConstDecl(dn, e);
           addLocAnn(RESULT, getLocation(defequalleft, defequalright, dn, e));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("constDecl",54, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //varDecl ::= declWordList COLON error 
    java_cup.runtime.Symbol case304(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      VarDecl RESULT =null;/*3*/
		int dwlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dwlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList dwl = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int colonleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int colonright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo colon = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Object e = (Object) CUP$Parser$stack.peek().value;
		
           ZParseMessage msg = ZParseMessage.MSG_SYNTAX_ERROR_IN_VARDECL;
           parser.report_syntax_error(msg);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varDecl",53, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //varDecl ::= declWordList COLON expression 
    java_cup.runtime.Symbol case303(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      VarDecl RESULT =null;/*3*/
		int dwlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dwlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList dwl = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int colonleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int colonright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo colon = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createVarDecl(dwl, e);
           if (dwl.size() > 0) {
             LocInfo loc = getLocation(colonleft, colonright, dwl.get(0), e);
             addLocAnn(RESULT, loc);
           }
           else {
             addLocAnn(RESULT, getLocation(colon, e));
           }
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varDecl",53, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //basicDeclaration ::= constDecl 
    java_cup.runtime.Symbol case302(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Decl RESULT =null;/*3*/
		int cdleft = CUP$Parser$stack.peek().left;
		int cdright = CUP$Parser$stack.peek().right;
		ConstDecl cd = (ConstDecl) CUP$Parser$stack.peek().value;
		 RESULT = cd; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("basicDeclaration",55, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //basicDeclaration ::= varDecl 
    java_cup.runtime.Symbol case301(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Decl RESULT =null;/*3*/
		int vdleft = CUP$Parser$stack.peek().left;
		int vdright = CUP$Parser$stack.peek().right;
		VarDecl vd = (VarDecl) CUP$Parser$stack.peek().value;
		 RESULT = vd; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("basicDeclaration",55, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //schemaTextNoExpression ::= basicDeclaration 
    java_cup.runtime.Symbol case300(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      SchText RESULT =null;/*3*/
		int bdleft = CUP$Parser$stack.peek().left;
		int bdright = CUP$Parser$stack.peek().right;
		Decl bd = (Decl) CUP$Parser$stack.peek().value;
		
           ZDeclList zdl = factory_.createZDeclList(factory_.list(bd));
           RESULT = factory_.createZSchText(zdl, null);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("schemaTextNoExpression",35, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //schemaTextNoExpression ::= zDeclList sep declaration 
    java_cup.runtime.Symbol case299(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      SchText RESULT =null;/*3*/
		int zdlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int zdlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZDeclList zdl = (ZDeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int dleft = CUP$Parser$stack.peek().left;
		int dright = CUP$Parser$stack.peek().right;
		Decl d = (Decl) CUP$Parser$stack.peek().value;
		
           zdl.add(d);
           RESULT = factory_.createZSchText(zdl, null);
	/*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("schemaTextNoExpression",35, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //schemaTextNoExpression ::= optDeclPart BAR predicate 
    java_cup.runtime.Symbol case298(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      SchText RESULT =null;/*3*/
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		Pred p = (Pred) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createZSchText(dp, p);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("schemaTextNoExpression",35, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //declaration ::= expression 
    java_cup.runtime.Symbol case297(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Decl RESULT =null;/*3*/
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		 RESULT = factory_.createInclDecl(e); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declaration",56, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //declaration ::= basicDeclaration 
    java_cup.runtime.Symbol case296(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Decl RESULT =null;/*3*/
		int bdleft = CUP$Parser$stack.peek().left;
		int bdright = CUP$Parser$stack.peek().right;
		Decl bd = (Decl) CUP$Parser$stack.peek().value;
		 RESULT = bd; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declaration",56, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //zDeclList ::= zDeclList sep declaration 
    java_cup.runtime.Symbol case295(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZDeclList RESULT =null;/*3*/
		int zdlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int zdlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZDeclList zdl = (ZDeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int dleft = CUP$Parser$stack.peek().left;
		int dright = CUP$Parser$stack.peek().right;
		Decl d = (Decl) CUP$Parser$stack.peek().value;
		
           zdl.add(d);
           RESULT = zdl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("zDeclList",50, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //zDeclList ::= declaration 
    java_cup.runtime.Symbol case294(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZDeclList RESULT =null;/*3*/
		int dleft = CUP$Parser$stack.peek().left;
		int dright = CUP$Parser$stack.peek().right;
		Decl d = (Decl) CUP$Parser$stack.peek().value;
		 RESULT = factory_.createZDeclList(factory_.list(d)); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("zDeclList",50, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //declPart ::= zDeclList 
    java_cup.runtime.Symbol case293(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      DeclList RESULT =null;/*3*/
		int zdlleft = CUP$Parser$stack.peek().left;
		int zdlright = CUP$Parser$stack.peek().right;
		ZDeclList zdl = (ZDeclList) CUP$Parser$stack.peek().value;
		
           RESULT = zdl;
           addLocAnn(zdl, getLocation(getLocation(zdl.get(0)),
                                      getLocation(zdl.get(zdl.size() - 1))));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declPart",52, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optDeclPart ::= declPart 
    java_cup.runtime.Symbol case292(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      DeclList RESULT =null;/*3*/
		int dpleft = CUP$Parser$stack.peek().left;
		int dpright = CUP$Parser$stack.peek().right;
		DeclList dp = (DeclList) CUP$Parser$stack.peek().value;
		 RESULT = dp; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optDeclPart",51, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optDeclPart ::= 
    java_cup.runtime.Symbol case291(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      DeclList RESULT =null;/*3*/
		 RESULT = factory_.createZDeclList(); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optDeclPart",51, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //axiomaticSchemaText ::= optDeclPart 
    java_cup.runtime.Symbol case290(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      SchText RESULT =null;/*3*/
		int odpleft = CUP$Parser$stack.peek().left;
		int odpright = CUP$Parser$stack.peek().right;
		DeclList odp = (DeclList) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createZSchText(odp, null);
           addLocAnn(RESULT, getLocation(odp));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("axiomaticSchemaText",36, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //axiomaticSchemaText ::= optDeclPart BAR predicate 
    java_cup.runtime.Symbol case289(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      SchText RESULT =null;/*3*/
		int odpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int odpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList odp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		Pred p = (Pred) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createZSchText(odp, p);
           
           addLocAnn(RESULT, getLocation(getLocation(odp),
                                         getLocation(p)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("axiomaticSchemaText",36, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //schemaText ::= optDeclPart 
    java_cup.runtime.Symbol case288(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      SchText RESULT =null;/*3*/
		int odpleft = CUP$Parser$stack.peek().left;
		int odpright = CUP$Parser$stack.peek().right;
		DeclList odp = (DeclList) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createZSchText(odp, null);
           addLocAnn(RESULT, getLocation(odp));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("schemaText",37, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //schemaText ::= optDeclPart BAR predicate 
    java_cup.runtime.Symbol case287(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      SchText RESULT =null;/*3*/
		int odpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int odpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList odp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		Pred p = (Pred) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createZSchText(odp, p);
           
           addLocAnn(RESULT, getLocation(getLocation(odp),
                                         getLocation(p)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("schemaText",37, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //refines ::= CIRCREFINES DECORWORD 
    java_cup.runtime.Symbol case286(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Transformation RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
           RESULT = Transformation.Refinement;
           parserState_.setRefinementModel(validateModel(dw));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("refines",149, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //refines ::= CIRCREFINES 
    java_cup.runtime.Symbol case285(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Transformation RESULT =null;/*3*/
		
           RESULT = Transformation.Refinement;
           parserState_.setRefinementModel(CircusUtils.DEFAULT_REFINEMENT_MODEL);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("refines",149, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //refines ::= EQUALS 
    java_cup.runtime.Symbol case284(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Transformation RESULT =null;/*3*/
		 RESULT = Transformation.Equivalence; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("refines",149, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //refines ::= CIRCSIMULATES 
    java_cup.runtime.Symbol case283(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Transformation RESULT =null;/*3*/
		 RESULT = Transformation.Simulation; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("refines",149, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //actionRefPara ::= name CIRCASSERTREF circusAction refines circusAction 
    java_cup.runtime.Symbol case282(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int specleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int specright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusAction spec = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Transformation r = (Transformation) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int implleft = CUP$Parser$stack.peek().left;
		int implright = CUP$Parser$stack.peek().right;
		CircusAction impl = (CircusAction) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createTransformerPara(n,
                factory_.createActionTransformerPred(null, r,
                parserState_.getRefinementModel(), factory_.list(spec, impl)));
           addLocAnn(RESULT, getLocation(getLocation(spec), getLocation(impl)));
           parserState_.clearRefinementModel();

        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actionRefPara",114, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //processRefPara ::= name CIRCASSERTREF process refines process 
    java_cup.runtime.Symbol case281(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int specleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int specright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusProcess spec = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Transformation r = (Transformation) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int implleft = CUP$Parser$stack.peek().left;
		int implright = CUP$Parser$stack.peek().right;
		CircusProcess impl = (CircusProcess) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createTransformerPara(n,
                factory_.createProcessTransformerPred(null, r, parserState_.getRefinementModel(),
                factory_.list(spec, impl)));
           addLocAnn(RESULT, getLocation(getLocation(spec), getLocation(impl)));
           parserState_.clearRefinementModel();
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("processRefPara",113, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //nameSubstitution ::= LSQUARE renameList RSQUARE 
    java_cup.runtime.Symbol case280(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      RenameList RESULT =null;/*3*/
		int lsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo ls = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rnlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rnlright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		RenameList rnl = (RenameList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rsleft = CUP$Parser$stack.peek().left;
		int rsright = CUP$Parser$stack.peek().right;
		LocInfo rs = (LocInfo) CUP$Parser$stack.peek().value;
		
            RESULT = rnl;
            addLocAnn(RESULT, getLocation(ls, rs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("nameSubstitution",139, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //guardedCommand ::= guard CIRCTHEN circusAction 
    java_cup.runtime.Symbol case279(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      GuardedAction RESULT =null;/*3*/
		int gleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int gright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Pred g = (Pred) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int caleft = CUP$Parser$stack.peek().left;
		int caright = CUP$Parser$stack.peek().right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createGuardedAction(ca, g);
            addLocAnn(RESULT, getLocation(g, ca));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("guardedCommand",167, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //guardedCommands ::= guardedCommand 
    java_cup.runtime.Symbol case278(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<GuardedAction> RESULT =null;/*3*/
		int gleft = CUP$Parser$stack.peek().left;
		int gright = CUP$Parser$stack.peek().right;
		GuardedAction g = (GuardedAction) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.list(g);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("guardedCommands",166, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //guardedCommands ::= guardedCommands CIRCELSE guardedCommand 
    java_cup.runtime.Symbol case277(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<GuardedAction> RESULT =null;/*3*/
		int gcsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int gcsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<GuardedAction> gcs = (List<GuardedAction>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int gleft = CUP$Parser$stack.peek().left;
		int gright = CUP$Parser$stack.peek().right;
		GuardedAction g = (GuardedAction) CUP$Parser$stack.peek().value;
		
           gcs.add(g);
           RESULT = gcs;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("guardedCommands",166, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //command ::= LSQUARE predicate RSQUARE 
    java_cup.runtime.Symbol case276(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusCommand RESULT =null;/*3*/
		int lsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo ls = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int postleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int postright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Pred post = (Pred) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rsleft = CUP$Parser$stack.peek().left;
		int rsright = CUP$Parser$stack.peek().right;
		LocInfo rs = (LocInfo) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createSpecStmtCommand(factory_.createZNameList(),
              factory_.list(factory_.createTruePred(), post));
            addLocAnn(RESULT, getLocation(getLocation(lsleft, lsright), getLocation(rsleft, rsright)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("command",165, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //command ::= LBRACE predicate RBRACE 
    java_cup.runtime.Symbol case275(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusCommand RESULT =null;/*3*/
		int lbleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lbright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo lb = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int preleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int preright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Pred pre = (Pred) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rbleft = CUP$Parser$stack.peek().left;
		int rbright = CUP$Parser$stack.peek().right;
		LocInfo rb = (LocInfo) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createSpecStmtCommand(factory_.createZNameList(),
              factory_.list(pre, factory_.createTruePred()));
            addLocAnn(RESULT, getLocation(getLocation(lbleft, lbright), getLocation(rbleft, rbright)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("command",165, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //command ::= PREFIXCOLON LSQUARE predicate COMMA predicate RSQUARE 
    java_cup.runtime.Symbol case274(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusCommand RESULT =null;/*3*/
		int cleft = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int cright = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		LocInfo c = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int preleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int preright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		Pred pre = (Pred) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int postleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int postright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Pred post = (Pred) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rsqleft = CUP$Parser$stack.peek().left;
		int rsqright = CUP$Parser$stack.peek().right;
		LocInfo rsq = (LocInfo) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createSpecStmtCommand(factory_.createZNameList(),
              factory_.list(pre, post));
            addLocAnn(RESULT, getLocation(c, rsq));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("command",165, CUP$Parser$stack.elementAt(CUP$Parser$top-5), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //command ::= refNameList PREFIXCOLON LSQUARE predicate COMMA predicate RSQUARE 
    java_cup.runtime.Symbol case273(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusCommand RESULT =null;/*3*/
		int rnlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-6).left;
		int rnlright = CUP$Parser$stack.elementAt(CUP$Parser$top-6).right;
		@SuppressWarnings("unchecked") List<ZName> rnl = (List<ZName>) CUP$Parser$stack.elementAt(CUP$Parser$top-6).value;
		int preleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int preright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		Pred pre = (Pred) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int postleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int postright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Pred post = (Pred) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.createSpecStmtCommand(factory_.createZNameList(rnl),
              factory_.list(pre, post));
            addLocAnn(RESULT, getLocation(getLocation(rnlleft, rnlright), getLocation(post)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("command",165, CUP$Parser$stack.elementAt(CUP$Parser$top-6), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //command ::= CIRCVAR circusParamZDeclList CIRCSPOT circusAction 
    java_cup.runtime.Symbol case272(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusCommand RESULT =null;/*3*/
		int cvleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int cvright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo cv = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZDeclList dp = (ZDeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int caleft = CUP$Parser$stack.peek().left;
		int caright = CUP$Parser$stack.peek().right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.peek().value;
		
            // DESIGN: we do not allow schema inclusion. only variable declaration.

            // NOTE: Variable names with decorations should not be allowed here,
            //       as they mess up their interpretation when added to the state
            //       (e.g., for var x: \nat TC includes x, x', x?, x! , if we allow
            //       var x?: \nat TC will include x?, x?', x??, x!?). Also it makes
            //       prefixing very confusing too (e.g., in "c?x??!x!?z", what should
            //       be the communication pattern? "c ? (x??) ! (x!) ? z"? The smart
            //       scanner makes sure, by differentiating DECORWORD into CHANNELNAME
            //       and FIELDNAME by ensuring no decorated names are allowed as either
            //       terminal. So, the above tokenises as "c ? (x) ??! (x) !? z", which
            //       then is clearly a parsing error.
            RESULT = factory_.createVarDeclCommand(dp, ca);
            addLocAnn(RESULT, getLocation(cv, ca));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("command",165, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //command ::= CIRCDO guardedCommands CIRCOD 
    java_cup.runtime.Symbol case271(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusCommand RESULT =null;/*3*/
		int cdoleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cdoright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo cdo = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int gcsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int gcsright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<GuardedAction> gcs = (List<GuardedAction>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int codleft = CUP$Parser$stack.peek().left;
		int codright = CUP$Parser$stack.peek().right;
		LocInfo cod = (LocInfo) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createDoGuardedCommand(factory_.createCircusActionList(gcs));
            addLocAnn(RESULT, getLocation(cdo, cod));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("command",165, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //command ::= IF guardedCommands CIRCFI 
    java_cup.runtime.Symbol case270(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusCommand RESULT =null;/*3*/
		int cifleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cifright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo cif = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int gcsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int gcsright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<GuardedAction> gcs = (List<GuardedAction>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int cfileft = CUP$Parser$stack.peek().left;
		int cfiright = CUP$Parser$stack.peek().right;
		LocInfo cfi = (LocInfo) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createIfGuardedCommand(factory_.createCircusActionList(gcs));
            addLocAnn(RESULT, getLocation(cif, cfi));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("command",165, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //command ::= refNameList CIRCASSIGN expressionList 
    java_cup.runtime.Symbol case269(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusCommand RESULT =null;/*3*/
		int rnlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int rnlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<ZName> rnl = (List<ZName>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int caleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int caright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo ca = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int elleft = CUP$Parser$stack.peek().left;
		int elright = CUP$Parser$stack.peek().right;
		ZExprList el = (ZExprList) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createAssignmentCommand(
              createAssignmentPairs(ca, factory_.createZNameList(rnl), el));
            addLocAnn(RESULT, getLocation(rnlleft, rnlright, rnl.get(0), el));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("command",165, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //commField ::= CHANNELOUT DECORWORD error END 
    java_cup.runtime.Symbol case268(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Field RESULT =null;/*3*/
		int inleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int inright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo in = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.getCircusFactory().createOutputField(
              factory_.createRefExpr(createCircusName(dw)));
            addLocAnn(RESULT, getLocation(in, dw.getLocation()));
            final Object[] params = { dw.getWord() };
            parser.report_error(CircusParseMessage.MSG_COMMPATTERN_NOT_RECOGNISED,
                                params, dw.getLocation());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commField",164, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //commField ::= CHANNELDOT DECORWORD error END 
    java_cup.runtime.Symbol case267(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Field RESULT =null;/*3*/
		int inleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int inright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo in = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.getCircusFactory().createDotField(
              factory_.createRefExpr(createCircusName(dw)));
            addLocAnn(RESULT, getLocation(in, dw.getLocation()));
            final Object[] params = { dw.getWord() };
            parser.report_error(CircusParseMessage.MSG_COMMPATTERN_NOT_RECOGNISED,
                                params, dw.getLocation());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commField",164, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //commField ::= CHANNELIN DECORWORD error END 
    java_cup.runtime.Symbol case266(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Field RESULT =null;/*3*/
		int inleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int inright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo in = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.createInputField(createCircusName(dw), factory_.createTruePred());
            addLocAnn(RESULT, getLocation(in, dw.getLocation()));
            final Object[] params = { dw.getWord() };
            parser.report_error(CircusParseMessage.MSG_COMMPATTERN_NOT_RECOGNISED,
                                params, dw.getLocation());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commField",164, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //commField ::= CHANNELIN FIELDNAME PREFIXCOLON error END 
    java_cup.runtime.Symbol case265(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Field RESULT =null;/*3*/
		int inleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int inright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo in = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.createInputField(createCircusName(dw), factory_.createTruePred());
            addLocAnn(RESULT, getLocation(in, dw.getLocation()));
            final Object[] params = { dw.getWord() };
            parser.report_error(CircusParseMessage.MSG_COMMPATTERN_PREFIXCOLON_NOT_RECOGNISED,
                                params, dw.getLocation());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commField",164, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //commField ::= CHANNELDOT expression 
    java_cup.runtime.Symbol case264(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Field RESULT =null;/*3*/
		int dtleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int dtright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo dt = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createDotField(e);
            addLocAnn(RESULT, getLocation(dt, e));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commField",164, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //commField ::= CHANNELOUT expression 
    java_cup.runtime.Symbol case263(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Field RESULT =null;/*3*/
		int outleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int outright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo out = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.getCircusFactory().createOutputField(e);
            addLocAnn(RESULT, getLocation(out, e));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commField",164, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //commField ::= CHANNELIN FIELDNAME PREFIXCOLON LPAREN predicate RPAREN 
    java_cup.runtime.Symbol case262(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Field RESULT =null;/*3*/
		int inleft = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int inright = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		LocInfo in = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int pleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int pright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Pred p = (Pred) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.createInputField(createCircusName(dw), p);
            addLocAnn(RESULT, getLocation(in, dw.getLocation()));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commField",164, CUP$Parser$stack.elementAt(CUP$Parser$top-5), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //commField ::= CHANNELIN FIELDNAME 
    java_cup.runtime.Symbol case261(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Field RESULT =null;/*3*/
		int inleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int inright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo in = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createInputField(createCircusName(dw), factory_.createTruePred());
            addLocAnn(RESULT, getLocation(in, dw.getLocation()));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commField",164, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //commFields ::= commField 
    java_cup.runtime.Symbol case260(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Field> RESULT =null;/*3*/
		int cfleft = CUP$Parser$stack.peek().left;
		int cfright = CUP$Parser$stack.peek().right;
		Field cf = (Field) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.list(cf);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commFields",161, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //commFields ::= commFields commField 
    java_cup.runtime.Symbol case259(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Field> RESULT =null;/*3*/
		int cfsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int cfsright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<Field> cfs = (List<Field>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int cfleft = CUP$Parser$stack.peek().left;
		int cfright = CUP$Parser$stack.peek().right;
		Field cf = (Field) CUP$Parser$stack.peek().value;
		
            assert cfs != null;
            cfs.add(cf);
            RESULT = cfs;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("commFields",161, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optCommFields ::= 
    java_cup.runtime.Symbol case258(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Field> RESULT =null;/*3*/
		 RESULT = factory_.<Field>list(); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optCommFields",160, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optCommFields ::= commFields 
    java_cup.runtime.Symbol case257(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Field> RESULT =null;/*3*/
		int cfleft = CUP$Parser$stack.peek().left;
		int cfright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Field> cf = (List<Field>) CUP$Parser$stack.peek().value;
		 RESULT = cf; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optCommFields",160, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //communication ::= CHANNELERROR error PREFIXTHEN 
    java_cup.runtime.Symbol case256(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Communication RESULT =null;/*3*/
		int celeft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ceright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Decorword ce = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           LocInfo loc = ce.getLocation();
           RESULT = factory_.createCommunication(
                factory_.createRefExpr(createCircusName(ce)),  // channel name
                factory_.createCircusFieldList(),         // empty communication fields
                CommUsage.Normal,                         // channel communication usage
                CommPattern.Mixed,                        // assume mixed
                CircusUtils.DEFAULT_MULTISYNCH,           // default multi synch
                false                                     // not implicit
            );
            addLocAnn(RESULT, loc);
            Pair<Integer, Integer> counters = ce.getExtraInfo();
            if (counters == null)
            {
              counters = new Pair<Integer, Integer>(-1, -1);
            }
            final Object[] params = { ce.getWord(), counters.getFirst(), counters.getSecond() };
            parser.report_error(CircusParseMessage.MSG_WRONG_NUMBER_FIELD_STROKES,
                                params, loc);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("communication",159, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //communication ::= CHANNELNAME LSQUARE expressionList RSQUARE commFields 
    java_cup.runtime.Symbol case255(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Communication RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int elleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int elright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZExprList el = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cfleft = CUP$Parser$stack.peek().left;
		int cfright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Field> cf = (List<Field>) CUP$Parser$stack.peek().value;
		
            /* RefExpr: mixfix=false, explicit=true */
            RESULT = factory_.createCommunication(
              factory_.createRefExpr(createCircusName(dw),     // channel name with generic parameters
                  el, Boolean.FALSE, Boolean.TRUE),
                factory_.createCircusFieldList(cf),       // communication fields
                CommUsage.Generic,                // channel communication usage
                CircusUtils.retrieveCommPattern(cf),      // communication pattern
                CircusUtils.DEFAULT_MULTISYNCH,           // default multi synch
                false                                     // not implicit
            );
            addLocAnn(RESULT, dw.getLocation());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("communication",159, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //communication ::= CHANNELNAME optCommFields 
    java_cup.runtime.Symbol case254(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Communication RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int ocfleft = CUP$Parser$stack.peek().left;
		int ocfright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Field> ocf = (List<Field>) CUP$Parser$stack.peek().value;
		
            /* RefExpr: mixfix=false, explicit=false */
            RESULT = factory_.createCommunication(
                factory_.createRefExpr(createCircusName(dw)),  // channel name
                factory_.createCircusFieldList(ocf),      // communication fields
                CommUsage.Normal,                         // channel communication usage
                CircusUtils.retrieveCommPattern(ocf),     // communication pattern
                CircusUtils.DEFAULT_MULTISYNCH,           // default multi synch
                false                                     // not implicit
            );
            addLocAnn(RESULT, dw.getLocation());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("communication",159, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //guard ::= predicate 
    java_cup.runtime.Symbol case253(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Pred RESULT =null;/*3*/
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		Pred p = (Pred) CUP$Parser$stack.peek().value;
		 RESULT = p; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("guard",157, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parenthesisedAction ::= LPAREN circusAction RPAREN channelRenaming 
    java_cup.runtime.Symbol case252(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int caleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int caright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rpright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int crleft = CUP$Parser$stack.peek().left;
		int crright = CUP$Parser$stack.peek().right;
		AssignmentPairs cr = (AssignmentPairs) CUP$Parser$stack.peek().value;
		            
            addParenthesisAnn(lp, ca, rp);
            RESULT = factory_.createRenameAction(ca, cr);
            addLocAnn(RESULT, getLocation(lp, rp));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parenthesisedAction",154, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parenthesisedAction ::= LPAREN CIRCMU name CIRCSPOT paramAction RPAREN actualParameters 
    java_cup.runtime.Symbol case251(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int lp1left = CUP$Parser$stack.elementAt(CUP$Parser$top-6).left;
		int lp1right = CUP$Parser$stack.elementAt(CUP$Parser$top-6).right;
		LocInfo lp1 = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-6).value;
		int cmleft = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int cmright = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		LocInfo cm = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int paleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int paright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusAction pa = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rp1left = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rp1right = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo rp1 = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int elleft = CUP$Parser$stack.peek().left;
		int elright = CUP$Parser$stack.peek().right;
		ZExprList el = (ZExprList) CUP$Parser$stack.peek().value;
		
            MuAction mu = factory_.createMuAction(pa, n);
            addLocAnn(mu, getLocation(cm, pa));
            addParenthesisAnn(lp1, mu, rp1);

            Decorword an = createImplicitlyDeclActUniqueName(mu);
            ActionPara ap = createImplicitActionPara(an, mu);
            parserState_.addImplicitlyDeclActionPara(ap);
            RESULT = factory_.createCallAction(createCircusName(an), el);
            addLocAnn(RESULT, getLocation(lp1, el.get(el.size()-1)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parenthesisedAction",154, CUP$Parser$stack.elementAt(CUP$Parser$top-6), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parenthesisedAction ::= LPAREN paramAction RPAREN actualParameters 
    java_cup.runtime.Symbol case250(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int lp1left = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lp1right = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo lp1 = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int paleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int paright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusAction pa = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rp1left = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rp1right = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo rp1 = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int elleft = CUP$Parser$stack.peek().left;
		int elright = CUP$Parser$stack.peek().right;
		ZExprList el = (ZExprList) CUP$Parser$stack.peek().value;
		
            addParenthesisAnn(lp1, pa, rp1);
            Decorword an = createImplicitlyDeclActUniqueName(pa);
            ActionPara ap = createImplicitActionPara(an, pa);
            parserState_.addImplicitlyDeclActionPara(ap);
            RESULT = factory_.createCallAction(createCircusName(an), el);
            addLocAnn(RESULT, getLocation(lp1, el.get(el.size()-1)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parenthesisedAction",154, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parenthesisedAction ::= LPAREN paramAction RPAREN 
    java_cup.runtime.Symbol case249(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int paleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int paright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		CircusAction pa = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rpleft = CUP$Parser$stack.peek().left;
		int rpright = CUP$Parser$stack.peek().right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.peek().value;
		
           addParenthesisAnn(lp, pa, rp);
           RESULT = pa;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parenthesisedAction",154, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parenthesisedAction ::= LPAREN circusAction RPAREN 
    java_cup.runtime.Symbol case248(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int caleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int caright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rpleft = CUP$Parser$stack.peek().left;
		int rpright = CUP$Parser$stack.peek().right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.peek().value;
		
           addParenthesisAnn(lp, ca, rp);
           RESULT = ca;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parenthesisedAction",154, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //actionCall ::= DECORWORD 
    java_cup.runtime.Symbol case247(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createCallAction(createCircusName(dw), factory_.createZExprList());
            addLocAnn(RESULT, dw.getLocation());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actionCall",153, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //actionCall ::= DECORWORD actualParameters 
    java_cup.runtime.Symbol case246(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int apleft = CUP$Parser$stack.peek().left;
		int apright = CUP$Parser$stack.peek().right;
		ZExprList ap = (ZExprList) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createCallAction(createCircusName(dw), ap);
            addLocAnn(RESULT, dw.getLocation());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actionCall",153, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= circusAction nameSubstitution 
    java_cup.runtime.Symbol case245(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int caleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int caright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int nsleft = CUP$Parser$stack.peek().left;
		int nsright = CUP$Parser$stack.peek().right;
		RenameList ns = (RenameList) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createSubstitutionAction(ca, ns);
            addLocAnn(RESULT, getLocation(ca));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= actionCall 
    java_cup.runtime.Symbol case244(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int acleft = CUP$Parser$stack.peek().left;
		int acright = CUP$Parser$stack.peek().right;
		CircusAction ac = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = ac;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= communication PREFIXTHEN circusAction 
    java_cup.runtime.Symbol case243(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int commleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int commright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Communication comm = (Communication) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int ptleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int ptright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo pt = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int caleft = CUP$Parser$stack.peek().left;
		int caright = CUP$Parser$stack.peek().right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createPrefixingAction(ca, comm);
            addLocAnn(RESULT, getLocation(comm, ca));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= LCIRCGUARD guard RCIRCGUARD ANDALSO circusAction 
    java_cup.runtime.Symbol case242(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int lgleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int lgright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo lg = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int gleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int gright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		Pred g = (Pred) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int rgleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int rgright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo rg = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cgleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int cgright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo cg = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int caleft = CUP$Parser$stack.peek().left;
		int caright = CUP$Parser$stack.peek().right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createGuardedAction(ca, g);
            addLocAnn(RESULT, getLocation(g, ca));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= circusAction CIRCSEQ circusAction 
    java_cup.runtime.Symbol case241(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int calleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int calright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusAction cal = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int csleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int csright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo cs = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int carleft = CUP$Parser$stack.peek().left;
		int carright = CUP$Parser$stack.peek().right;
		CircusAction car = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createSeqAction(factory_.list(cal, car));
            addLocAnn(RESULT, getLocation(cal, car));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= circusAction CIRCINTERRUPT circusAction 
    java_cup.runtime.Symbol case240(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int calleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int calright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusAction cal = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int csleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int csright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo cs = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int carleft = CUP$Parser$stack.peek().left;
		int carright = CUP$Parser$stack.peek().right;
		CircusAction car = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createInterruptAction(factory_.list(cal, car));
            addLocAnn(RESULT, getLocation(cal, car));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= circusAction EXTCHOICE circusAction 
    java_cup.runtime.Symbol case239(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int calleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int calright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusAction cal = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int csleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int csright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo cs = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int carleft = CUP$Parser$stack.peek().left;
		int carright = CUP$Parser$stack.peek().right;
		CircusAction car = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createExtChoiceAction(factory_.list(cal, car));
            addLocAnn(RESULT, getLocation(cal, car));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= circusAction INTCHOICE circusAction 
    java_cup.runtime.Symbol case238(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int calleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int calright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusAction cal = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int icleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int icright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo ic = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int carleft = CUP$Parser$stack.peek().left;
		int carright = CUP$Parser$stack.peek().right;
		CircusAction car = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createIntChoiceAction(factory_.list(cal, car));
            addLocAnn(RESULT, getLocation(cal, car));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= circusAction LSQUARE BAR channelSet BAR BAR channelSet BAR RSQUARE circusAction 
    java_cup.runtime.Symbol case237(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int calleft = CUP$Parser$stack.elementAt(CUP$Parser$top-9).left;
		int calright = CUP$Parser$stack.elementAt(CUP$Parser$top-9).right;
		CircusAction cal = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-9).value;
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-8).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-8).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-8).value;
		int blleft = CUP$Parser$stack.elementAt(CUP$Parser$top-7).left;
		int blright = CUP$Parser$stack.elementAt(CUP$Parser$top-7).right;
		LocInfo bl = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-7).value;
		int cslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-6).left;
		int cslright = CUP$Parser$stack.elementAt(CUP$Parser$top-6).right;
		ChannelSet csl = (ChannelSet) CUP$Parser$stack.elementAt(CUP$Parser$top-6).value;
		int csrleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int csrright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		ChannelSet csr = (ChannelSet) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int brleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int brright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo br = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rpright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int carleft = CUP$Parser$stack.peek().left;
		int carright = CUP$Parser$stack.peek().right;
		CircusAction car = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createAlphabetisedParallelAction(factory_.list(cal, car),
              factory_.list(createEmptyNameSet(getLocation(lp, bl)), createEmptyNameSet(getLocation(br, rp))),
              factory_.list(csl, csr));
            addLocAnn(RESULT, getLocation(cal, car));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.elementAt(CUP$Parser$top-9), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= circusAction LSQUARE nameSet BAR channelSet BAR BAR channelSet BAR nameSet RSQUARE circusAction 
    java_cup.runtime.Symbol case236(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int calleft = CUP$Parser$stack.elementAt(CUP$Parser$top-11).left;
		int calright = CUP$Parser$stack.elementAt(CUP$Parser$top-11).right;
		CircusAction cal = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-11).value;
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-10).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-10).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-10).value;
		int nslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-9).left;
		int nslright = CUP$Parser$stack.elementAt(CUP$Parser$top-9).right;
		NameSet nsl = (NameSet) CUP$Parser$stack.elementAt(CUP$Parser$top-9).value;
		int cslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-7).left;
		int cslright = CUP$Parser$stack.elementAt(CUP$Parser$top-7).right;
		ChannelSet csl = (ChannelSet) CUP$Parser$stack.elementAt(CUP$Parser$top-7).value;
		int csrleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int csrright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		ChannelSet csr = (ChannelSet) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int nsrleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nsrright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		NameSet nsr = (NameSet) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rpright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int carleft = CUP$Parser$stack.peek().left;
		int carright = CUP$Parser$stack.peek().right;
		CircusAction car = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createAlphabetisedParallelAction(factory_.list(cal, car),
              factory_.list(nsl, nsr), factory_.list(csl, csr));
            addLocAnn(RESULT, getLocation(cal, car));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.elementAt(CUP$Parser$top-11), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= circusAction LPAR BAR channelSet BAR RPAR circusAction 
    java_cup.runtime.Symbol case235(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int calleft = CUP$Parser$stack.elementAt(CUP$Parser$top-6).left;
		int calright = CUP$Parser$stack.elementAt(CUP$Parser$top-6).right;
		CircusAction cal = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-6).value;
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int blleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int blright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo bl = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int csleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int csright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		ChannelSet cs = (ChannelSet) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int brleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int brright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo br = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rpright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int carleft = CUP$Parser$stack.peek().left;
		int carright = CUP$Parser$stack.peek().right;
		CircusAction car = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createParallelAction(factory_.list(cal, car),
              factory_.list(createEmptyNameSet(getLocation(lp, bl)), createEmptyNameSet(getLocation(br, rp))), cs);
            addLocAnn(RESULT, getLocation(cal, car));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.elementAt(CUP$Parser$top-6), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= circusAction LPAR nameSet BAR channelSet BAR nameSet RPAR circusAction 
    java_cup.runtime.Symbol case234(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int calleft = CUP$Parser$stack.elementAt(CUP$Parser$top-8).left;
		int calright = CUP$Parser$stack.elementAt(CUP$Parser$top-8).right;
		CircusAction cal = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-8).value;
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-7).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-7).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-7).value;
		int nslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-6).left;
		int nslright = CUP$Parser$stack.elementAt(CUP$Parser$top-6).right;
		NameSet nsl = (NameSet) CUP$Parser$stack.elementAt(CUP$Parser$top-6).value;
		int csleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int csright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		ChannelSet cs = (ChannelSet) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int nsrleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nsrright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		NameSet nsr = (NameSet) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rpright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int carleft = CUP$Parser$stack.peek().left;
		int carright = CUP$Parser$stack.peek().right;
		CircusAction car = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createParallelAction(factory_.list(cal, car), factory_.list(nsl, nsr), cs);
            addLocAnn(RESULT, getLocation(cal, car));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.elementAt(CUP$Parser$top-8), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= circusAction INTERLEAVE circusAction 
    java_cup.runtime.Symbol case233(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int calleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int calright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusAction cal = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int illeft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int ilright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo il = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int carleft = CUP$Parser$stack.peek().left;
		int carright = CUP$Parser$stack.peek().right;
		CircusAction car = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createInterleaveAction(factory_.list(cal, car),
              factory_.list(createEmptyNameSet(getLocation(cal, il)), createEmptyNameSet(getLocation(il, car))));
            addLocAnn(RESULT, getLocation(cal, car));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= circusAction LINTER nameSet BAR nameSet RINTER circusAction 
    java_cup.runtime.Symbol case232(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int calleft = CUP$Parser$stack.elementAt(CUP$Parser$top-6).left;
		int calright = CUP$Parser$stack.elementAt(CUP$Parser$top-6).right;
		CircusAction cal = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-6).value;
		int lileft = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int liright = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		LocInfo li = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int nslleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int nslright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		NameSet nsl = (NameSet) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int nsrleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nsrright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		NameSet nsr = (NameSet) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rileft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int riright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo ri = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int carleft = CUP$Parser$stack.peek().left;
		int carright = CUP$Parser$stack.peek().right;
		CircusAction car = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createInterleaveAction(factory_.list(cal, car), factory_.list(nsl, nsr));
            addLocAnn(RESULT, getLocation(cal, car));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.elementAt(CUP$Parser$top-6), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= circusAction CIRCHIDING channelSet 
    java_cup.runtime.Symbol case231(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int caleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int caright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int hleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int hright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo h = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int csleft = CUP$Parser$stack.peek().left;
		int csright = CUP$Parser$stack.peek().right;
		ChannelSet cs = (ChannelSet) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createHideAction(ca, cs);
           addLocAnn(RESULT, getLocation(ca, cs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= CIRCMU name CIRCSPOT circusAction 
    java_cup.runtime.Symbol case230(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int cmleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int cmright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo cm = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int caleft = CUP$Parser$stack.peek().left;
		int caright = CUP$Parser$stack.peek().right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createMuAction(ca, n);
            addLocAnn(RESULT, getLocation(cm, ca));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= CIRCCHAOS 
    java_cup.runtime.Symbol case229(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int ccleft = CUP$Parser$stack.peek().left;
		int ccright = CUP$Parser$stack.peek().right;
		LocInfo cc = (LocInfo) CUP$Parser$stack.peek().value;
		
          RESULT = factory_.createChaosAction();
          addLocAnn(RESULT, cc);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= CIRCSTOP 
    java_cup.runtime.Symbol case228(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int spleft = CUP$Parser$stack.peek().left;
		int spright = CUP$Parser$stack.peek().right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.peek().value;
		
          RESULT = factory_.createStopAction();
          addLocAnn(RESULT, sp);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //cspAction ::= CIRCSKIP 
    java_cup.runtime.Symbol case227(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int skleft = CUP$Parser$stack.peek().left;
		int skright = CUP$Parser$stack.peek().right;
		LocInfo sk = (LocInfo) CUP$Parser$stack.peek().value;
		
          RESULT = factory_.createSkipAction();
          addLocAnn(RESULT, sk);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cspAction",156, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusAction ::= parenthesisedAction 
    java_cup.runtime.Symbol case226(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int paleft = CUP$Parser$stack.peek().left;
		int paright = CUP$Parser$stack.peek().right;
		CircusAction pa = (CircusAction) CUP$Parser$stack.peek().value;
		 RESULT = pa; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusAction",152, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusAction ::= LSCHEXPRACT expression RSCHEXPRACT 
    java_cup.runtime.Symbol case225(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int laleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int laright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo la = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Expr e = (Expr) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int raleft = CUP$Parser$stack.peek().left;
		int raright = CUP$Parser$stack.peek().right;
		LocInfo ra = (LocInfo) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createSchExprAction(e);
            addLocAnn(RESULT, getLocation(la, ra));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusAction",152, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusAction ::= command 
    java_cup.runtime.Symbol case224(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int cleft = CUP$Parser$stack.peek().left;
		int cright = CUP$Parser$stack.peek().right;
		CircusCommand c = (CircusCommand) CUP$Parser$stack.peek().value;
		 RESULT = c; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusAction",152, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusAction ::= cspAction 
    java_cup.runtime.Symbol case223(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int caleft = CUP$Parser$stack.peek().left;
		int caright = CUP$Parser$stack.peek().right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.peek().value;
		 RESULT = ca; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusAction",152, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramAction ::= circusParamCommandDeclList CIRCSPOT circusParamCommandDeclList CIRCSPOT circusAction 
    java_cup.runtime.Symbol case222(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int cpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int cpright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		DeclList cp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int cp2left = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cp2right = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList cp2 = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int sp2left = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int sp2right = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo sp2 = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int paleft = CUP$Parser$stack.peek().left;
		int paright = CUP$Parser$stack.peek().right;
		CircusAction pa = (CircusAction) CUP$Parser$stack.peek().value;
		
            LocInfo loc = getLocation(getLocation(cpleft, cpright), getLocation(cp2left, cp2right));
            // as we don't have the action, just use skip
            RESULT = createParamAction(pa, cp);
            addLocAnn(RESULT, loc);
            parser.report_error(CircusParseMessage.MSG_NESTED_PARAMACTION,
                          new Object[0], loc);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramAction",151, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramAction ::= ZCOMP circusParamDeclList CIRCSPOT circusAction 
    java_cup.runtime.Symbol case221(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int rsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int rsright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo rs = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int caleft = CUP$Parser$stack.peek().left;
		int caright = CUP$Parser$stack.peek().right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createSeqActionIte(ca, dp);
            addLocAnn(RESULT, getLocation(rs, ca));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramAction",151, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramAction ::= REPEXTCHOICE circusParamDeclList CIRCSPOT circusAction 
    java_cup.runtime.Symbol case220(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int releft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int reright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo re = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int caleft = CUP$Parser$stack.peek().left;
		int caright = CUP$Parser$stack.peek().right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createExtChoiceActionIte(ca, dp);
            addLocAnn(RESULT, getLocation(re, ca));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramAction",151, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramAction ::= REPINTCHOICE circusParamDeclList CIRCSPOT circusAction 
    java_cup.runtime.Symbol case219(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int rileft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int riright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo ri = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int caleft = CUP$Parser$stack.peek().left;
		int caright = CUP$Parser$stack.peek().right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createIntChoiceActionIte(ca, dp);
            addLocAnn(RESULT, getLocation(ri, ca));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramAction",151, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramAction ::= LPAR channelSet RPAR circusParamDeclList CIRCSPOT circusAction 
    java_cup.runtime.Symbol case218(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int csleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int csright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		ChannelSet cs = (ChannelSet) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int rpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int rpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int caleft = CUP$Parser$stack.peek().left;
		int caright = CUP$Parser$stack.peek().right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.peek().value;
		
            // Namesets first because of common parent for parallel actions,
            // and interleave has no channel set but has a name set.
            RESULT = factory_.createParallelActionIte(ca, dp, createEmptyNameSet(rp), cs);
            addLocAnn(RESULT, getLocation(lp, ca));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramAction",151, CUP$Parser$stack.elementAt(CUP$Parser$top-5), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramAction ::= LPAR channelSet RPAR circusParamDeclList CIRCSPOT LPAR nameSet RPAR circusAction 
    java_cup.runtime.Symbol case217(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-8).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-8).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-8).value;
		int csleft = CUP$Parser$stack.elementAt(CUP$Parser$top-7).left;
		int csright = CUP$Parser$stack.elementAt(CUP$Parser$top-7).right;
		ChannelSet cs = (ChannelSet) CUP$Parser$stack.elementAt(CUP$Parser$top-7).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int nsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		NameSet ns = (NameSet) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int caleft = CUP$Parser$stack.peek().left;
		int caright = CUP$Parser$stack.peek().right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.peek().value;
		
            // Namesets first because of common parent for parallel actions,
            // and interleave has no channel set but has a name set.
            RESULT = factory_.createParallelActionIte(ca, dp, ns, cs);
            addLocAnn(RESULT, getLocation(lp, ca));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramAction",151, CUP$Parser$stack.elementAt(CUP$Parser$top-8), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramAction ::= REPINTERLEAVE circusParamDeclList CIRCSPOT circusAction 
    java_cup.runtime.Symbol case216(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int rileft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int riright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo ri = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int caleft = CUP$Parser$stack.peek().left;
		int caright = CUP$Parser$stack.peek().right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createInterleaveActionIte(ca, dp, createEmptyNameSet(ri));
            addLocAnn(RESULT, getLocation(ri, ca));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramAction",151, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramAction ::= REPINTERLEAVE circusParamDeclList LINTER nameSet RINTER CIRCSPOT circusAction 
    java_cup.runtime.Symbol case215(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int rileft = CUP$Parser$stack.elementAt(CUP$Parser$top-6).left;
		int riright = CUP$Parser$stack.elementAt(CUP$Parser$top-6).right;
		LocInfo ri = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-6).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int nsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int nsright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		NameSet ns = (NameSet) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int caleft = CUP$Parser$stack.peek().left;
		int caright = CUP$Parser$stack.peek().right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createInterleaveActionIte(ca, dp, ns);
            addLocAnn(RESULT, getLocation(ri, ca));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramAction",151, CUP$Parser$stack.elementAt(CUP$Parser$top-6), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramAction ::= circusParamCommandDeclList CIRCSPOT circusAction 
    java_cup.runtime.Symbol case214(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int cpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList cp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int caleft = CUP$Parser$stack.peek().left;
		int caright = CUP$Parser$stack.peek().right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.peek().value;
		
            // NOTE: ParamAction covers both parameterised actions and commands
            //       the parser allows both here, whereas the type checker
            //       guarantees the consistency among declarations and inner action/command.
            RESULT = createParamAction(ca, cp);
            addLocAnn(RESULT, getLocation(getLocation(cpleft, cpright), getLocation(ca)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramAction",151, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //actionDesc ::= circusAction 
    java_cup.runtime.Symbol case213(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int caleft = CUP$Parser$stack.peek().left;
		int caright = CUP$Parser$stack.peek().right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.peek().value;
		 RESULT = ca; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actionDesc",150, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //actionDesc ::= paramAction 
    java_cup.runtime.Symbol case212(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int paleft = CUP$Parser$stack.peek().left;
		int paright = CUP$Parser$stack.peek().right;
		CircusAction pa = (CircusAction) CUP$Parser$stack.peek().value;
		 RESULT = pa; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actionDesc",150, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //actionDesc ::= DECORWORD channelRenaming 
    java_cup.runtime.Symbol case211(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int crleft = CUP$Parser$stack.peek().left;
		int crright = CUP$Parser$stack.peek().right;
		AssignmentPairs cr = (AssignmentPairs) CUP$Parser$stack.peek().value;
		                  
          RESULT = factory_.createRenameAction(factory_.createCallAction(
          createCircusName(dw), factory_.createZExprList()), cr);
          addLocAnn(RESULT, getLocation(dw.getLocation(), getLocation(cr)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actionDesc",150, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //actionPara ::= name CIRCDEF actionDesc 
    java_cup.runtime.Symbol case210(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ActionPara RESULT =null;/*3*/
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int paleft = CUP$Parser$stack.peek().left;
		int paright = CUP$Parser$stack.peek().right;
		CircusAction pa = (CircusAction) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createActionPara(n, pa);
           addLocAnn(RESULT, getLocation(n, pa));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actionPara",120, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //nameSet ::= expression 
    java_cup.runtime.Symbol case209(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      NameSet RESULT =null;/*3*/
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createCircusNameSet(e);
           addLocAnn(RESULT, getLocation(e));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("nameSet",168, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //namesetPara ::= CIRCNAMESET name DEFEQUAL nameSet 
    java_cup.runtime.Symbol case208(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int cnsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int cnsright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo cns = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int equalleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int equalright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo equal = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int nsleft = CUP$Parser$stack.peek().left;
		int nsright = CUP$Parser$stack.peek().right;
		NameSet ns = (NameSet) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createNameSetPara(n, ns);
           addLocAnn(RESULT, getLocation(cns, ns));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("namesetPara",115, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelRenaming ::= LCIRCRENAME refNameList CIRCASSIGN expressionList RCIRCRENAME 
    java_cup.runtime.Symbol case207(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      AssignmentPairs RESULT =null;/*3*/
		int lsqleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int lsqright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo lsq = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int rnlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int rnlright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		@SuppressWarnings("unchecked") List<ZName> rnl = (List<ZName>) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int elleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int elright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZExprList el = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rsqleft = CUP$Parser$stack.peek().left;
		int rsqright = CUP$Parser$stack.peek().right;
		LocInfo rsq = (LocInfo) CUP$Parser$stack.peek().value;
		
            /* Must ensure that: 1) sizes of lists are equal; 2) second list contains only RefExpr.
             * RefExpr are possible in the case of generically defined channels.
             */
            RESULT = createChannelRenamingPairs(getLocation(rnlleft, rnlright),
              factory_.createZNameList(rnl), el);
            addLocAnn(RESULT, getLocation(lsq, rsq));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelRenaming",140, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //actualIndexes ::= CIRCLINST expressionList CIRCRINST 
    java_cup.runtime.Symbol case206(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZExprList RESULT =null;/*3*/
		int clileft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cliright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo cli = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int idxleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int idxright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZExprList idx = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int crileft = CUP$Parser$stack.peek().left;
		int criright = CUP$Parser$stack.peek().right;
		LocInfo cri = (LocInfo) CUP$Parser$stack.peek().value;
		
            RESULT = idx;
            addLocAnn(RESULT, getLocation(cli, cri));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actualIndexes",126, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //actualParameters ::= LPAREN expressionList RPAREN 
    java_cup.runtime.Symbol case205(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZExprList RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int elleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int elright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZExprList el = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rpleft = CUP$Parser$stack.peek().left;
		int rpright = CUP$Parser$stack.peek().right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.peek().value;
		
            RESULT = el;
            addLocAnn(RESULT, getLocation(lp, rp));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actualParameters",125, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //genericActuals ::= LSQUARE expressionList RSQUARE 
    java_cup.runtime.Symbol case204(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZExprList RESULT =null;/*3*/
		int lsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lsright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo ls = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int elleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int elright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZExprList el = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rsleft = CUP$Parser$stack.peek().left;
		int rsright = CUP$Parser$stack.peek().right;
		LocInfo rs = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = el;
           addLocAnn(RESULT, getLocation(ls, rs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("genericActuals",124, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusProcessState ::= CIRCSTATE expression 
    java_cup.runtime.Symbol case203(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int csleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int csright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo cs = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
           LocInfo loc = getLocation(e);
           Name dn = parserState_.createDefaultProcessStateName(loc);
           RESULT = createStatePara(dn, e, loc, true /* implicit */);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusProcessState",116, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusProcessState ::= CIRCSTATE name DEFEQUAL expression 
    java_cup.runtime.Symbol case202(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int csleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int csright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo cs = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int equalleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int equalright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo equal = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
           RESULT = createStatePara(n, e, getLocation(n, e), false /* not implicit */);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusProcessState",116, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusBasicProcessMainAction ::= CIRCSPOT circusAction 
    java_cup.runtime.Symbol case201(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusAction RESULT =null;/*3*/
		int sleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int sright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo s = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int caleft = CUP$Parser$stack.peek().left;
		int caright = CUP$Parser$stack.peek().right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.peek().value;
		
           final String from = "CIRCUS BP MAIN ACTION";
           LocInfo loc = getLocation(s, ca);
           RESULT = ca;

           // sets the main action into the parserState_
           setMainAction(RESULT, loc);
           addLocAnn(RESULT, loc);

           // Create an on-the-fly paragraph for the main action named "$$mainAction".
           String maName = parserState_.createUniqueMainActionName(loc);
           ActionPara mainActPara = factory_.createActionPara(
              factory_.createZName(maName), RESULT);
           addLocAnn(mainActPara, loc);
           parserState_.addImplicitlyDeclActionPara(mainActPara);

           //logProductionResult(RESULT, from, loc);
           //logProductionResult(parserState_.getMainAction(), "BP FROM STATE AFTER MA", loc);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusBasicProcessMainAction",155, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusBasicProcess ::= CIRCBEGIN circusInnerProcParaList circusBasicProcessMainAction CIRCEND 
    java_cup.runtime.Symbol case200(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      BasicProcess RESULT =null;/*3*/
		int cbleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int cbright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo cb = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int iplleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int iplright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Para> ipl = (List<Para>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int caleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int caright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int celeft = CUP$Parser$stack.peek().left;
		int ceright = CUP$Parser$stack.peek().right;
		LocInfo ce = (LocInfo) CUP$Parser$stack.peek().value;
		
           final String from = "SINGLE ENVIRONMENT";
           LocInfo loc = getLocation(cb, ce);

           boolean shouldContinue = enterBasicProcessScope(from, loc);
           RESULT = createMockBasicProcessFor(from, loc);
           if (shouldContinue) {
               //logProductionResult(factory_.createZParaList(ipl), "IPL FROM " + from, loc);
               //logProductionResult(factory_.createZParaList(parserState_.getLocallyDeclPara()),
               //     "STATE-LOCAL-PARA-LIST FROM " + from, loc);

               // In here we have a tricky situation...

               // Ensure the list collected in "ipl" is the same the one into RESULT
               if (ensureInnerProcParaListKnownInBasicProcessScope(ipl, from, loc)) {
                  // if ensureInnerProcParaListKnownInBasicProcessScope, then the
                  // warnings can be cleared, since they were properly included.
                  parserState_.clearSectBasicProcessScopeWarnings();
               }

               // logProductionResult(parserState_.getBasicProcess(), "BP FROM " + from + " BEFORE UPDATE", loc);

               // Updates the basic process structures with collected
               // information (i.e. ipl, state para, on the fly, main action, etc.)
               if (updateBasicProcessInformation(from, loc)) {
                    logProductionResult(parserState_.getBasicProcess(), "BP FROM " + from + " AFTER UPDATE", loc);

                    RESULT = parserState_.cloneBasicProcessWithAnns();

                    logProductionResult(RESULT, "RESULT-VAR FROM " + from + " AFTER PARSER STATE UPDATE", loc);
               }
               // If exit fails, a warning is mentioned, not an error, so continue regardless
               exitBasicProcessScope(from, loc);
           }
           // logProductionResult(RESULT, "RESULT-VAR FROM " + from + " AFTER PARSER SCOPE EXIT", loc);

           // if there were any warning collected for the list of paragraphs
           // declared outside the multiple environment scope, raise then.
           raisePendingBasicProcessWarnings(from);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusBasicProcess",138, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusBasicProcess ::= CIRCBEGIN circusBasicProcessMainAction CIRCEND 
    java_cup.runtime.Symbol case199(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      BasicProcess RESULT =null;/*3*/
		int cbleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cbright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo cb = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int caleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int caright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		CircusAction ca = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int celeft = CUP$Parser$stack.peek().left;
		int ceright = CUP$Parser$stack.peek().right;
		LocInfo ce = (LocInfo) CUP$Parser$stack.peek().value;
		
           final String from = "JUST MAINACTION - SINGLE ENVIRONMENT";
           LocInfo loc = getLocation(cb, ce);

           // sets the basic process scope flag.
           // it is important to check mainAction's scope
           // (i.e. main action declared outside basic process scope)
           boolean shouldContinue = enterBasicProcessScope(from, loc);

           // create an empty BasicProcess with empty (rather than null) lists
           // it adds location annotation to the result and set it into the parser state
           // Can only call createMockBasicProcessFor after entering process scope
           RESULT = createMockBasicProcessFor(from, loc);

           if (shouldContinue){
               //logProductionResult(parserState_.getBasicProcess(), "BP FROM " + from + " BEFORE UPDATE", loc);

               // Updates the basic process structures with collected
               // information (i.e. main action)
               if (updateBasicProcessInformation(from, loc)) {
                    //logProductionResult(parserState_.getBasicProcess(), "BP FROM " + from + " AFTER UPDATE", loc);
                    RESULT = parserState_.cloneBasicProcessWithAnns();

                    //logProductionResult(RESULT, "RESULT-VAR FROM " + from + " AFTER PARSER STATE UPDATE", loc);
               }
               // If exit fails, a warning is mentioned, not an error, so continue regardless
               exitBasicProcessScope(from, loc);
            }
            //logProductionResult(RESULT, "RESULT-VAR FROM " + from + " AFTER PARSER SCOPE EXIT", loc);

            // if there were any warning collected for the list of paragraphs
            // declared outside the multiple environment scope, raise then.
            // there should be none, since this is already just a main action.
            raisePendingBasicProcessWarnings(from);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusBasicProcess",138, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusBasicProcess ::= CIRCBEGIN 
    java_cup.runtime.Symbol case198(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      BasicProcess RESULT =null;/*3*/
		int beginleft = CUP$Parser$stack.peek().left;
		int beginright = CUP$Parser$stack.peek().right;
		LocInfo begin = (LocInfo) CUP$Parser$stack.peek().value;
		
           final String from = "MULTIPLE ENVIRONMENT BEGIN";
           LocInfo loc = getLocation(beginleft, beginright);

           // sets the basic process scope flag
           enterBasicProcessScope(from, loc);

           // create an empty BasicProcess with empty (rather than null) lists
           // it adds location annotation to the result and set it into the parser state
           RESULT = createMockBasicProcessFor(from, loc);

        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusBasicProcess",138, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusQualifier ::= CIRCVRES 
    java_cup.runtime.Symbol case197(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ParamQualifier RESULT =null;/*3*/
		 RESULT = ParamQualifier.ValueResult; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusQualifier",148, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusQualifier ::= CIRCRES 
    java_cup.runtime.Symbol case196(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ParamQualifier RESULT =null;/*3*/
		 RESULT = ParamQualifier.Result; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusQualifier",148, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusQualifier ::= CIRCVAL 
    java_cup.runtime.Symbol case195(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ParamQualifier RESULT =null;/*3*/
		 RESULT = ParamQualifier.Value; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusQualifier",148, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //qualifiedDecl ::= circusQualifier circusDeclWordList COLON expression 
    java_cup.runtime.Symbol case194(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      QualifiedDecl RESULT =null;/*3*/
		int cqleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int cqright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		ParamQualifier cq = (ParamQualifier) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int cdwlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cdwlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList cdwl = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int colonleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int colonright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo colon = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createQualifiedDecl(cdwl, e, cq);
           addLocAnn(RESULT, getLocation(cdwl.get(0), getLocation(e)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("qualifiedDecl",147, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusParamCommandZDeclList ::= circusParamCommandZDeclList SEMICOLON circusCommandDecl 
    java_cup.runtime.Symbol case193(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZDeclList RESULT =null;/*3*/
		int cdlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cdlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZDeclList cdl = (ZDeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cdleft = CUP$Parser$stack.peek().left;
		int cdright = CUP$Parser$stack.peek().right;
		Decl cd = (Decl) CUP$Parser$stack.peek().value;
		
           cdl.add(cd);
           RESULT = cdl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusParamCommandZDeclList",144, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusParamCommandZDeclList ::= circusCommandDecl 
    java_cup.runtime.Symbol case192(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZDeclList RESULT =null;/*3*/
		int cdleft = CUP$Parser$stack.peek().left;
		int cdright = CUP$Parser$stack.peek().right;
		Decl cd = (Decl) CUP$Parser$stack.peek().value;
		 RESULT = factory_.createZDeclList(factory_.list(cd)); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusParamCommandZDeclList",144, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusParamCommandDeclList ::= circusParamCommandZDeclList 
    java_cup.runtime.Symbol case191(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      DeclList RESULT =null;/*3*/
		int cdlleft = CUP$Parser$stack.peek().left;
		int cdlright = CUP$Parser$stack.peek().right;
		ZDeclList cdl = (ZDeclList) CUP$Parser$stack.peek().value;
		 RESULT = cdl; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusParamCommandDeclList",142, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusCommandDecl ::= qualifiedDecl 
    java_cup.runtime.Symbol case190(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Decl RESULT =null;/*3*/
		int cdleft = CUP$Parser$stack.peek().left;
		int cdright = CUP$Parser$stack.peek().right;
		QualifiedDecl cd = (QualifiedDecl) CUP$Parser$stack.peek().value;
		 RESULT = cd; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusCommandDecl",146, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusCommandDecl ::= varDecl 
    java_cup.runtime.Symbol case189(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Decl RESULT =null;/*3*/
		int vdleft = CUP$Parser$stack.peek().left;
		int vdright = CUP$Parser$stack.peek().right;
		VarDecl vd = (VarDecl) CUP$Parser$stack.peek().value;
		 RESULT = vd; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusCommandDecl",146, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusParamZDeclList ::= circusParamZDeclList sep varDecl 
    java_cup.runtime.Symbol case188(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZDeclList RESULT =null;/*3*/
		int zdlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int zdlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZDeclList zdl = (ZDeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int vdleft = CUP$Parser$stack.peek().left;
		int vdright = CUP$Parser$stack.peek().right;
		VarDecl vd = (VarDecl) CUP$Parser$stack.peek().value;
		
           zdl.add(vd);
           RESULT = zdl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusParamZDeclList",143, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusParamZDeclList ::= varDecl 
    java_cup.runtime.Symbol case187(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZDeclList RESULT =null;/*3*/
		int vdleft = CUP$Parser$stack.peek().left;
		int vdright = CUP$Parser$stack.peek().right;
		VarDecl vd = (VarDecl) CUP$Parser$stack.peek().value;
		 RESULT = factory_.createZDeclList(factory_.list(vd)); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusParamZDeclList",143, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusParamDeclList ::= circusParamZDeclList 
    java_cup.runtime.Symbol case186(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      DeclList RESULT =null;/*3*/
		int zdlleft = CUP$Parser$stack.peek().left;
		int zdlright = CUP$Parser$stack.peek().right;
		ZDeclList zdl = (ZDeclList) CUP$Parser$stack.peek().value;
		
           RESULT = zdl;
           addLocAnn(zdl, getLocation(getLocation(zdl.get(0)),
                                      getLocation(zdl.get(zdl.size() - 1))));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusParamDeclList",141, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parenthesisedProcess ::= LPAREN indexedProcess RPAREN channelRenaming 
    java_cup.runtime.Symbol case185(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int ipleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ipright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusProcess ip = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rpright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int crleft = CUP$Parser$stack.peek().left;
		int crright = CUP$Parser$stack.peek().right;
		AssignmentPairs cr = (AssignmentPairs) CUP$Parser$stack.peek().value;
		
            addParenthesisAnn(lp, ip, rp);
            RESULT = factory_.createRenameProcess(ip, cr);
            addLocAnn(RESULT, getLocation(lp, rp));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parenthesisedProcess",136, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parenthesisedProcess ::= LPAREN paramProcess RPAREN channelRenaming 
    java_cup.runtime.Symbol case184(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int ppleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ppright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusProcess pp = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rpright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int crleft = CUP$Parser$stack.peek().left;
		int crright = CUP$Parser$stack.peek().right;
		AssignmentPairs cr = (AssignmentPairs) CUP$Parser$stack.peek().value;
		
            addParenthesisAnn(lp, pp, rp);
            RESULT = factory_.createRenameProcess(pp, cr);
            addLocAnn(RESULT, getLocation(lp, rp));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parenthesisedProcess",136, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parenthesisedProcess ::= LPAREN process RPAREN channelRenaming 
    java_cup.runtime.Symbol case183(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int ppleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ppright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusProcess pp = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rpright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int crleft = CUP$Parser$stack.peek().left;
		int crright = CUP$Parser$stack.peek().right;
		AssignmentPairs cr = (AssignmentPairs) CUP$Parser$stack.peek().value;
		
            //System.out.println("VIXE");
            addParenthesisAnn(lp, pp, rp);
            RESULT = factory_.createRenameProcess(pp, cr);
            addLocAnn(RESULT, getLocation(lp, rp));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parenthesisedProcess",136, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parenthesisedProcess ::= formalParameters LPAREN indexedProcess RPAREN genericActuals actualIndexes 
    java_cup.runtime.Symbol case182(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int fpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int fpright = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		ZNameList fp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int ipleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int ipright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		CircusProcess ip = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int rpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int rpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int galeft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int garight = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZExprList ga = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int aileft = CUP$Parser$stack.peek().left;
		int airight = CUP$Parser$stack.peek().right;
		ZExprList ai = (ZExprList) CUP$Parser$stack.peek().value;
		
            addParenthesisAnn(lp, ip, rp);
            Decorword pn = createImplicitlyDeclProcUniqueName(ip);
            ProcessPara pa = createImplicitProcessPara(pn, ip);
            parserState_.addImplicitlyDeclProcessPara(pa);
            /* The CallUsage is Parameterised and the generic actuals are empty */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(createCircusName(pn),
                ga, Boolean.FALSE, Boolean.TRUE), ai, CallUsage.Indexed);
            addLocAnn(RESULT, getLocation(lp, ai.get(ai.size()-1)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parenthesisedProcess",136, CUP$Parser$stack.elementAt(CUP$Parser$top-5), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parenthesisedProcess ::= LPAREN indexedProcess RPAREN actualIndexes 
    java_cup.runtime.Symbol case181(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int ipleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ipright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusProcess ip = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rpright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int aileft = CUP$Parser$stack.peek().left;
		int airight = CUP$Parser$stack.peek().right;
		ZExprList ai = (ZExprList) CUP$Parser$stack.peek().value;
		
            addParenthesisAnn(lp, ip, rp);
            Decorword pn = createImplicitlyDeclProcUniqueName(ip);
            ProcessPara pa = createImplicitProcessPara(pn, ip);
            parserState_.addImplicitlyDeclProcessPara(pa);
            /* The CallUsage is Parameterised and the generic actuals are empty */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(createCircusName(pn)), ai, CallUsage.Indexed);
            addLocAnn(RESULT, getLocation(lp, ai.get(ai.size()-1)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parenthesisedProcess",136, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parenthesisedProcess ::= LPAREN indexedProcess RPAREN 
    java_cup.runtime.Symbol case180(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int ipleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int ipright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		CircusProcess ip = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rpleft = CUP$Parser$stack.peek().left;
		int rpright = CUP$Parser$stack.peek().right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.peek().value;
		
           addParenthesisAnn(lp, ip, rp);
           RESULT = ip;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parenthesisedProcess",136, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parenthesisedProcess ::= formalParameters LPAREN paramProcess RPAREN genericActuals actualParameters 
    java_cup.runtime.Symbol case179(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int fpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int fpright = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		ZNameList fp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int lp1left = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int lp1right = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo lp1 = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int ppleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int ppright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		CircusProcess pp = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int rp1left = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int rp1right = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo rp1 = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int galeft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int garight = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZExprList ga = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int apleft = CUP$Parser$stack.peek().left;
		int apright = CUP$Parser$stack.peek().right;
		ZExprList ap = (ZExprList) CUP$Parser$stack.peek().value;
		
            addParenthesisAnn(lp1, pp, rp1);
            Decorword pn = createImplicitlyDeclProcUniqueName(pp);
            ProcessPara pa = createImplicitProcessPara(pn, pp);
            parserState_.addImplicitlyDeclProcessPara(pa);
            /* The CallUsage is Parameterised and the generic actuals are the same as the  */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(createCircusName(pn),
                ga, Boolean.FALSE, Boolean.TRUE), ap, CallUsage.Parameterised);
            addLocAnn(RESULT, getLocation(lp1, ap.get(ap.size()-1)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parenthesisedProcess",136, CUP$Parser$stack.elementAt(CUP$Parser$top-5), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parenthesisedProcess ::= LPAREN paramProcess RPAREN actualParameters 
    java_cup.runtime.Symbol case178(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int lp1left = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lp1right = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo lp1 = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int ppleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ppright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusProcess pp = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rp1left = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rp1right = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo rp1 = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int apleft = CUP$Parser$stack.peek().left;
		int apright = CUP$Parser$stack.peek().right;
		ZExprList ap = (ZExprList) CUP$Parser$stack.peek().value;
		
            addParenthesisAnn(lp1, pp, rp1);
            Decorword pn = createImplicitlyDeclProcUniqueName(pp);
            ProcessPara pa = createImplicitProcessPara(pn, pp);
            parserState_.addImplicitlyDeclProcessPara(pa);
            /* The CallUsage is Parameterised and the generic actuals are the same as the  */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(createCircusName(pn)), ap, CallUsage.Parameterised);
            addLocAnn(RESULT, getLocation(lp1, ap.get(ap.size()-1)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parenthesisedProcess",136, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parenthesisedProcess ::= LPAREN paramProcess RPAREN 
    java_cup.runtime.Symbol case177(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int ppleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int ppright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		CircusProcess pp = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rpleft = CUP$Parser$stack.peek().left;
		int rpright = CUP$Parser$stack.peek().right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.peek().value;
		
           addParenthesisAnn(lp, pp, rp);
           RESULT = pp;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parenthesisedProcess",136, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parenthesisedProcess ::= LPAREN process RPAREN 
    java_cup.runtime.Symbol case176(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int pleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int pright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		CircusProcess p = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rpleft = CUP$Parser$stack.peek().left;
		int rpright = CUP$Parser$stack.peek().right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.peek().value;
		
           addParenthesisAnn(lp, p, rp);
           RESULT = p;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parenthesisedProcess",136, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //processCall ::= DECORWORD 
    java_cup.runtime.Symbol case175(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
            /* The CallUsage is irrelevant and both generic actuals and parameters are empty */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(createCircusName(dw)),
                factory_.createZExprList(), CallUsage.Parameterised);
            addLocAnn(RESULT, dw.getLocation());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("processCall",135, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //processCall ::= DECORWORD genericActuals 
    java_cup.runtime.Symbol case174(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int galeft = CUP$Parser$stack.peek().left;
		int garight = CUP$Parser$stack.peek().right;
		ZExprList ga = (ZExprList) CUP$Parser$stack.peek().value;
		
            /* The CallUsage is irrelevant and the parameters are empty */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(
              createCircusName(dw), ga, Boolean.FALSE, Boolean.TRUE),
              factory_.createZExprList(), CallUsage.Parameterised);
            addLocAnn(RESULT, dw.getLocation());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("processCall",135, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //processCall ::= DECORWORD genericActuals actualIndexes 
    java_cup.runtime.Symbol case173(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int galeft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int garight = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZExprList ga = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int aileft = CUP$Parser$stack.peek().left;
		int airight = CUP$Parser$stack.peek().right;
		ZExprList ai = (ZExprList) CUP$Parser$stack.peek().value;
		
            /* The CallUsage is Indexed and both generic actuals and indexes are not null */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(
              createCircusName(dw), ga, Boolean.FALSE, Boolean.TRUE), ai, CallUsage.Indexed);
            addLocAnn(RESULT, dw.getLocation());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("processCall",135, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //processCall ::= DECORWORD actualIndexes 
    java_cup.runtime.Symbol case172(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int aileft = CUP$Parser$stack.peek().left;
		int airight = CUP$Parser$stack.peek().right;
		ZExprList ai = (ZExprList) CUP$Parser$stack.peek().value;
		
            /* The CallUsage is Indexed and the generic actuals are empty */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(createCircusName(dw)), ai, CallUsage.Indexed);
            addLocAnn(RESULT, dw.getLocation());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("processCall",135, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //processCall ::= DECORWORD genericActuals actualParameters 
    java_cup.runtime.Symbol case171(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int galeft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int garight = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZExprList ga = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int apleft = CUP$Parser$stack.peek().left;
		int apright = CUP$Parser$stack.peek().right;
		ZExprList ap = (ZExprList) CUP$Parser$stack.peek().value;
		
            /* The CallUsage is Parameterised and both generic actuals and indexes are not null */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(
              createCircusName(dw), ga, Boolean.FALSE, Boolean.TRUE), ap, CallUsage.Parameterised);
            addLocAnn(RESULT, dw.getLocation());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("processCall",135, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //processCall ::= DECORWORD actualParameters 
    java_cup.runtime.Symbol case170(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int apleft = CUP$Parser$stack.peek().left;
		int apright = CUP$Parser$stack.peek().right;
		ZExprList ap = (ZExprList) CUP$Parser$stack.peek().value;
		
            /* The CallUsage is Parameterised and the generic actuals are empty */
            /* RefExpr: mixfix = false, explicit = false */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(createCircusName(dw)), ap, CallUsage.Parameterised);
            addLocAnn(RESULT, dw.getLocation());
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("processCall",135, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //process ::= parenthesisedProcess 
    java_cup.runtime.Symbol case169(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int ppleft = CUP$Parser$stack.peek().left;
		int ppright = CUP$Parser$stack.peek().right;
		CircusProcess pp = (CircusProcess) CUP$Parser$stack.peek().value;
		
           RESULT = pp;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("process",137, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //process ::= processCall 
    java_cup.runtime.Symbol case168(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int pcleft = CUP$Parser$stack.peek().left;
		int pcright = CUP$Parser$stack.peek().right;
		CircusProcess pc = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = pc;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("process",137, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //process ::= process CIRCSEQ process 
    java_cup.runtime.Symbol case167(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int plleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int plright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusProcess pl = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int csleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int csright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo cs = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int prleft = CUP$Parser$stack.peek().left;
		int prright = CUP$Parser$stack.peek().right;
		CircusProcess pr = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createSeqProcess(factory_.list(pl, pr));
            addLocAnn(RESULT, getLocation(csleft, csright, pl, pr));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("process",137, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //process ::= process EXTCHOICE process 
    java_cup.runtime.Symbol case166(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int plleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int plright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusProcess pl = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int csleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int csright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo cs = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int prleft = CUP$Parser$stack.peek().left;
		int prright = CUP$Parser$stack.peek().right;
		CircusProcess pr = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createExtChoiceProcess(factory_.list(pl, pr));
            addLocAnn(RESULT, getLocation(csleft, csright, pl, pr));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("process",137, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //process ::= process INTCHOICE process 
    java_cup.runtime.Symbol case165(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int plleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int plright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusProcess pl = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int icleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int icright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo ic = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int prleft = CUP$Parser$stack.peek().left;
		int prright = CUP$Parser$stack.peek().right;
		CircusProcess pr = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createIntChoiceProcess(factory_.list(pl, pr));
            addLocAnn(RESULT, getLocation(icleft, icright, pl, pr));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("process",137, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //process ::= process LPAR channelSet RPAR process 
    java_cup.runtime.Symbol case164(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int plleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int plright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		CircusProcess pl = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int lpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int lpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo lp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int csleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int csright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ChannelSet cs = (ChannelSet) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int rpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int rpright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int prleft = CUP$Parser$stack.peek().left;
		int prright = CUP$Parser$stack.peek().right;
		CircusProcess pr = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createParallelProcess(factory_.list(pl, pr), cs);
            addLocAnn(RESULT, getLocation(rpleft, rpright, pl, pr));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("process",137, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //process ::= process INTERLEAVE process 
    java_cup.runtime.Symbol case163(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int plleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int plright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusProcess pl = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int inleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int inright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo in = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int prleft = CUP$Parser$stack.peek().left;
		int prright = CUP$Parser$stack.peek().right;
		CircusProcess pr = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createInterleaveProcess(factory_.list(pl, pr));
            addLocAnn(RESULT, getLocation(inleft, inright, pl, pr));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("process",137, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //process ::= process CIRCHIDING channelSet 
    java_cup.runtime.Symbol case162(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int pleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int pright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		CircusProcess p = (CircusProcess) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int hleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int hright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo h = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int csleft = CUP$Parser$stack.peek().left;
		int csright = CUP$Parser$stack.peek().right;
		ChannelSet cs = (ChannelSet) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createHideProcess(p, cs);
           addLocAnn(RESULT, getLocation(hleft, hright, p, cs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("process",137, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //process ::= circusBasicProcess 
    java_cup.runtime.Symbol case161(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int bpleft = CUP$Parser$stack.peek().left;
		int bpright = CUP$Parser$stack.peek().right;
		BasicProcess bp = (BasicProcess) CUP$Parser$stack.peek().value;
		 RESULT = bp; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("process",137, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //indexedProcess ::= ZCOMP circusParamDeclList CIRCINDEX error END 
    java_cup.runtime.Symbol case160(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int rsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int rsright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo rs = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int cileft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ciright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo ci = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.createSeqProcessIdx(null, dp);
            addLocAnn(RESULT, getLocation(rs, ci));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated indexed parameterised sequential composition process" },
                getLocation(eleft, eright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("indexedProcess",134, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //indexedProcess ::= REPEXTCHOICE circusParamDeclList CIRCINDEX error END 
    java_cup.runtime.Symbol case159(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int releft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int reright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo re = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int cileft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ciright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo ci = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.createExtChoiceProcessIdx(null, dp);
            addLocAnn(RESULT, getLocation(re, ci));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated indexed parameterised external choice process" },
                getLocation(eleft, eright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("indexedProcess",134, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //indexedProcess ::= REPINTCHOICE circusParamDeclList CIRCINDEX error END 
    java_cup.runtime.Symbol case158(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int rileft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int riright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo ri = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int cileft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ciright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo ci = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.createIntChoiceProcessIdx(null, dp);
            addLocAnn(RESULT, getLocation(ri, ci));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated indexed parameterised internal choice process" },
                getLocation(eleft, eright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("indexedProcess",134, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //indexedProcess ::= REPPARALLEL circusParamDeclList LPAR channelSet RPAR CIRCINDEX error END 
    java_cup.runtime.Symbol case157(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int rpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-7).left;
		int rpright = CUP$Parser$stack.elementAt(CUP$Parser$top-7).right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-7).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-6).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-6).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-6).value;
		int csleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int csright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		ChannelSet cs = (ChannelSet) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int cileft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ciright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo ci = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.createParallelProcessIdx(null, dp, cs);
            addLocAnn(RESULT, getLocation(rp, cs));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated indexed parameterised parallel process" },
                getLocation(eleft, eright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("indexedProcess",134, CUP$Parser$stack.elementAt(CUP$Parser$top-7), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //indexedProcess ::= REPINTERLEAVE circusParamDeclList CIRCINDEX error END 
    java_cup.runtime.Symbol case156(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int rileft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int riright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo ri = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int cileft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ciright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo ci = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.createInterleaveProcessIdx(null, dp);
            addLocAnn(RESULT, getLocation(ri, ci));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated indexed parameterised interleave process" },
                getLocation(eleft, eright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("indexedProcess",134, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //indexedProcess ::= circusParamDeclList CIRCINDEX error END 
    java_cup.runtime.Symbol case155(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int cileft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ciright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo ci = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.createIndexedProcess(null, dp);
            addLocAnn(RESULT, getLocation(eleft, eright));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "parameterised indexed process" }, getLocation(eleft, eright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("indexedProcess",134, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //indexedProcess ::= ZCOMP circusParamDeclList CIRCINDEX processDesc 
    java_cup.runtime.Symbol case154(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int rsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int rsright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo rs = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cileft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int ciright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo ci = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		CircusProcess p = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createSeqProcessIdx(p, dp);
            addLocAnn(RESULT, getLocation(rs, p));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("indexedProcess",134, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //indexedProcess ::= REPEXTCHOICE circusParamDeclList CIRCINDEX processDesc 
    java_cup.runtime.Symbol case153(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int releft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int reright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo re = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cileft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int ciright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo ci = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		CircusProcess p = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createExtChoiceProcessIdx(p, dp);
            addLocAnn(RESULT, getLocation(re, p));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("indexedProcess",134, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //indexedProcess ::= REPINTCHOICE circusParamDeclList CIRCINDEX processDesc 
    java_cup.runtime.Symbol case152(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int rileft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int riright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo ri = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cileft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int ciright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo ci = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		CircusProcess p = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createIntChoiceProcessIdx(p, dp);
            addLocAnn(RESULT, getLocation(ri, p));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("indexedProcess",134, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //indexedProcess ::= REPPARALLEL circusParamDeclList LPAR channelSet RPAR CIRCINDEX processDesc 
    java_cup.runtime.Symbol case151(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int rpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-6).left;
		int rpright = CUP$Parser$stack.elementAt(CUP$Parser$top-6).right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-6).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int csleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int csright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		ChannelSet cs = (ChannelSet) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int cileft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int ciright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo ci = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		CircusProcess p = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createParallelProcessIdx(p, dp, cs);
            addLocAnn(RESULT, getLocation(rp, p));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("indexedProcess",134, CUP$Parser$stack.elementAt(CUP$Parser$top-6), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //indexedProcess ::= REPINTERLEAVE circusParamDeclList CIRCINDEX processDesc 
    java_cup.runtime.Symbol case150(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int rileft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int riright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo ri = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cileft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int ciright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo ci = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		CircusProcess p = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createInterleaveProcessIdx(p, dp);
            addLocAnn(RESULT, getLocation(ri, p));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("indexedProcess",134, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //indexedProcess ::= circusParamDeclList CIRCINDEX processDesc 
    java_cup.runtime.Symbol case149(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cileft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int ciright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo ci = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		CircusProcess p = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createIndexedProcess(p, dp);
            addLocAnn(RESULT, getLocation(getLocation(dpleft, dpright), getLocation(p)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("indexedProcess",134, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramProcess ::= ZCOMP circusParamDeclList CIRCSPOT error END 
    java_cup.runtime.Symbol case148(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int rsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int rsright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo rs = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.createSeqProcessIte(null, dp);
            addLocAnn(RESULT, getLocation(rs, sp));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated parameterised sequential composition process" },
                getLocation(eleft, eright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramProcess",133, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramProcess ::= REPEXTCHOICE circusParamDeclList CIRCSPOT error END 
    java_cup.runtime.Symbol case147(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int releft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int reright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo re = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.createExtChoiceProcessIte(null, dp);
            addLocAnn(RESULT, getLocation(re, sp));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated parameterised external choice process" },
                getLocation(eleft, eright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramProcess",133, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramProcess ::= REPINTCHOICE circusParamDeclList CIRCSPOT error END 
    java_cup.runtime.Symbol case146(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int rileft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int riright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo ri = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.createIntChoiceProcessIte(null, dp);
            addLocAnn(RESULT, getLocation(ri, sp));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated parameterised internal choice process" },
                getLocation(eleft, eright));

        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramProcess",133, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramProcess ::= REPPARALLEL circusParamDeclList LPAR channelSet RPAR CIRCSPOT error END 
    java_cup.runtime.Symbol case145(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int rpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-7).left;
		int rpright = CUP$Parser$stack.elementAt(CUP$Parser$top-7).right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-7).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-6).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-6).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-6).value;
		int csleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int csright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		ChannelSet cs = (ChannelSet) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.createParallelProcessIte(null, dp, cs);
            addLocAnn(RESULT, getLocation(rp, cs));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated parameterised parallel process" },
                getLocation(eleft, eright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramProcess",133, CUP$Parser$stack.elementAt(CUP$Parser$top-7), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramProcess ::= REPINTERLEAVE circusParamDeclList CIRCSPOT error END 
    java_cup.runtime.Symbol case144(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int rileft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int riright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo ri = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.createInterleaveProcessIte(null, dp);
            addLocAnn(RESULT, getLocation(ri, sp));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated parameterised interleave process" },
                getLocation(eleft, eright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramProcess",133, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramProcess ::= circusParamDeclList CIRCSPOT error END 
    java_cup.runtime.Symbol case143(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
            RESULT = factory_.createParamProcess(null, dp);
            addLocAnn(RESULT, getLocation(eleft, eright));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "parameterised process" }, getLocation(eleft, eright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramProcess",133, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramProcess ::= ZCOMP circusParamDeclList CIRCSPOT processDesc 
    java_cup.runtime.Symbol case142(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int rsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int rsright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo rs = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		CircusProcess p = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createSeqProcessIte(p, dp);
            addLocAnn(RESULT, getLocation(rs, p));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramProcess",133, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramProcess ::= REPEXTCHOICE circusParamDeclList CIRCSPOT processDesc 
    java_cup.runtime.Symbol case141(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int releft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int reright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo re = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		CircusProcess p = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createExtChoiceProcessIte(p, dp);
            addLocAnn(RESULT, getLocation(re, p));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramProcess",133, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramProcess ::= REPINTCHOICE circusParamDeclList CIRCSPOT processDesc 
    java_cup.runtime.Symbol case140(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int rileft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int riright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo ri = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		CircusProcess p = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createIntChoiceProcessIte(p, dp);
            addLocAnn(RESULT, getLocation(ri, p));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramProcess",133, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramProcess ::= REPPARALLEL circusParamDeclList LPAR channelSet RPAR CIRCSPOT processDesc 
    java_cup.runtime.Symbol case139(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int rpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-6).left;
		int rpright = CUP$Parser$stack.elementAt(CUP$Parser$top-6).right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-6).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int csleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int csright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		ChannelSet cs = (ChannelSet) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		CircusProcess p = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createParallelProcessIte(p, dp, cs);
            addLocAnn(RESULT, getLocation(rp, p));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramProcess",133, CUP$Parser$stack.elementAt(CUP$Parser$top-6), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramProcess ::= REPINTERLEAVE circusParamDeclList CIRCSPOT processDesc 
    java_cup.runtime.Symbol case138(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int rileft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int riright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo ri = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		CircusProcess p = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createInterleaveProcessIte(p, dp);
            addLocAnn(RESULT, getLocation(ri, p));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramProcess",133, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paramProcess ::= circusParamDeclList CIRCSPOT processDesc 
    java_cup.runtime.Symbol case137(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int dpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		DeclList dp = (DeclList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int spleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int spright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo sp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		CircusProcess p = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createParamProcess(p, dp);
            addLocAnn(RESULT, getLocation(getLocation(dpleft, dpright), getLocation(p)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paramProcess",133, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //processDesc ::= process 
    java_cup.runtime.Symbol case136(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		CircusProcess p = (CircusProcess) CUP$Parser$stack.peek().value;
		
           RESULT = p;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("processDesc",132, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //processDesc ::= indexedProcess 
    java_cup.runtime.Symbol case135(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int ipleft = CUP$Parser$stack.peek().left;
		int ipright = CUP$Parser$stack.peek().right;
		CircusProcess ip = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = ip;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("processDesc",132, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //processDesc ::= paramProcess 
    java_cup.runtime.Symbol case134(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int ppleft = CUP$Parser$stack.peek().left;
		int ppright = CUP$Parser$stack.peek().right;
		CircusProcess pp = (CircusProcess) CUP$Parser$stack.peek().value;
		
            RESULT = pp;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("processDesc",132, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //processDesc ::= DECORWORD genericActuals channelRenaming 
    java_cup.runtime.Symbol case133(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int galeft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int garight = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZExprList ga = (ZExprList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int crleft = CUP$Parser$stack.peek().left;
		int crright = CUP$Parser$stack.peek().right;
		AssignmentPairs cr = (AssignmentPairs) CUP$Parser$stack.peek().value;
		
            RESULT = factory_.createRenameProcess(
              factory_.createCallProcess(factory_.createRefExpr(
                createCircusName(dw), ga, Boolean.FALSE, Boolean.TRUE),
                factory_.createZExprList(), CallUsage.Parameterised), cr);
            addLocAnn(RESULT, getLocation(dw.getLocation(), getLocation(cr)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("processDesc",132, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //processDesc ::= DECORWORD channelRenaming 
    java_cup.runtime.Symbol case132(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      CircusProcess RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int crleft = CUP$Parser$stack.peek().left;
		int crright = CUP$Parser$stack.peek().right;
		AssignmentPairs cr = (AssignmentPairs) CUP$Parser$stack.peek().value;
		
          //System.out.println("OXENTE");
          RESULT = factory_.createRenameProcess(
              factory_.createCallProcess(factory_.createRefExpr(createCircusName(dw)),
                factory_.createZExprList(), CallUsage.Parameterised), cr);
            addLocAnn(RESULT, getLocation(dw.getLocation(), getLocation(cr)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("processDesc",132, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //processPara ::= CIRCEND 
    java_cup.runtime.Symbol case131(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ProcessPara RESULT =null;/*3*/
		int endleft = CUP$Parser$stack.peek().left;
		int endright = CUP$Parser$stack.peek().right;
		LocInfo end = (LocInfo) CUP$Parser$stack.peek().value;
		
           final String from = "MULTIPLE ENVIRONMENT END";
           LocInfo loc = getLocation(endleft, endright);

           // if there is no scope add warning.
           addBasicProcessScopePostCheckFor(from, loc);

           //Name pn = null;
           //NameList gen = null;
           BasicProcess bp = null;

           // Updates the basic process structures with collected information
           // from previous environment
           if (updateBasicProcessInformation(from, loc)) {
                //logProductionResult(parserState_.getBasicProcess(), "PARSER STATE BP FROM " + from + " AFTER UPDATE", loc);

                //pn = parserState_.getProcessName();
                bp = parserState_.cloneBasicProcessWithAnns();
                //gen = parserState_.getProcessGenFormals();

                //logProductionResult(bp, "BP FROM " + from + " AFTER PARSER STATE UPDATE", loc);
           }
           // retrive the process from the state before clearing it up

           if (checkProcessParaScope(loc)
              &&
              parserState_.isWithinMultipleEnvBasicProcessScope()) {
              parserState_.updateProcessParaBasicProcess(bp);
              RESULT = parserState_.getProcessPara();

              logProductionResult(RESULT, "AFTER-PROCESS-PARA-BP-UPDATE", loc);

              // if we have a ProcessPara, the CIRCEND warning
              // should be removed provided the procName is the same
              removeMultipleEnvBasicProcessCIRCENDWarning(loc);

              // This was creating a duplicated entry into section level for processpara
              //RESULT = factory_.createProcessPara(pn, gen, bp);
           } else {
              // error was raised at this point
              RESULT = factory_.createProcessPara();
           }

           // If exit fails, a warning is mentioned, not an error, so continue regardless
           exitBasicProcessScope(from, loc);

           addLocAnn(RESULT, loc);
           checkStateDeclNotRepeated(RESULT);
           //logProductionResult(RESULT, "PROCESS PARA " + from, loc);

           // if there were any warning collected for the list of paragraphs
           // declared outside the multiple environment scope, raise then
           raisePendingBasicProcessWarnings(from);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("processPara",119, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //processPara ::= CIRCPROC optFormalParameters name CIRCDEF processDesc 
    java_cup.runtime.Symbol case130(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ProcessPara RESULT =null;/*3*/
		int cpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int cpright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo cp = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int ofpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int ofpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		ZNameList ofp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int pdleft = CUP$Parser$stack.peek().left;
		int pdright = CUP$Parser$stack.peek().right;
		CircusProcess pd = (CircusProcess) CUP$Parser$stack.peek().value;
		
           LocInfo loc = getLocation(cp, pd);
           final String from = "PROCESS PARA";
           ProcessPara pp = factory_.createProcessPara(n, ofp, pd);
           checkStateDeclNotRepeated(pp);
           addLocAnn(pp, loc);

           // If processDesc is a multiple env BasicProcess, check whether
           // it is multiple environment or single environment - ParamProcess is also basic!
           if (CircusUtils.isBasicProcess(pd)
              &&
              // If multiple environment, just return null. This avoids creating
              // duplicated entries into section level for process para.
              // The null entry is dealt with in unboxedParagraphItemList production
              parserState_.isWithinMultipleEnvBasicProcessScope()) {
                  RESULT = null;
                  parserState_.setProcessPara(pp);

                  // to ensure this is harmless, we add must add a
                  // post check warning in case the process is not
                  // properly closed. Such warnings are cleared whenever
                  // a process scope is properly closed.
                  addMultipleEnvBasicProcessCIRCENDWarning(n, loc);
           } else {
              // Otherwise, for either single environment basic process or
              // process paragraphs that are not basic processes, create a
              // new entry.
              RESULT = pp;
           }
           logProductionResult(pp, from + " with " +
              (RESULT == null ? "null" : "non-null"), loc);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("processPara",119, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelSet ::= expression 
    java_cup.runtime.Symbol case129(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ChannelSet RESULT =null;/*3*/
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
           // NOTE: The validation below makes sure that if this is a channel set extension,
           //       set displays (SetExpr) or comprehension (SetCompExpr) are not allowed.
           Expr eValid = validateChannelSetExpr(e);
           RESULT = factory_.createCircusChannelSet(eValid);
           addLocAnn(RESULT, getLocation(e));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelSet",131, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelSetPara ::= CIRCCHANSET optFormalParameters error END 
    java_cup.runtime.Symbol case128(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int ccsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int ccsright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo ccs = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int ofpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ofpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList ofp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           RESULT = factory_.createChannelSetPara(ofp, null, null);
           addLocAnn(RESULT, getLocation(ccs, ofp.get(ofp.size()-1)));
           parser.report_error(CircusParseMessage.MSG_CHANNELSET_MISSING_NAME_ERROR,
              new Object[0], getLocation(eleft, eright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelSetPara",112, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelSetPara ::= CIRCCHANSET optFormalParameters name error END 
    java_cup.runtime.Symbol case127(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int ccsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int ccsright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo ccs = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int ofpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int ofpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		ZNameList ofp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           RESULT = factory_.createChannelSetPara(ofp, n, null);
           addLocAnn(RESULT, getLocation(ccs, n));
           parser.report_error(CircusParseMessage.MSG_CHANNELSET_MISSING_DEFEQUAL_ERROR,
              new Object[0], getLocation(eleft, eright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelSetPara",112, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelSetPara ::= CIRCCHANSET optFormalParameters name DEFEQUAL error END 
    java_cup.runtime.Symbol case126(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int ccsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int ccsright = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		LocInfo ccs = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int ofpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int ofpright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		ZNameList ofp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int equalleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int equalright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo equal = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           RESULT = factory_.createChannelSetPara(ofp, n, null);
           addLocAnn(RESULT, getLocation(ccs, n));
           parser.report_error(CircusParseMessage.MSG_CHANNELSET_EXPR_ERROR,
              new Object[0], getLocation(eleft, eright));

        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelSetPara",112, CUP$Parser$stack.elementAt(CUP$Parser$top-5), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelSetPara ::= CIRCCHANSET optFormalParameters name DEFEQUAL channelSet 
    java_cup.runtime.Symbol case125(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int ccsleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int ccsright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo ccs = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int ofpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int ofpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		ZNameList ofp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int equalleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int equalright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo equal = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int csleft = CUP$Parser$stack.peek().left;
		int csright = CUP$Parser$stack.peek().right;
		ChannelSet cs = (ChannelSet) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createChannelSetPara(ofp, n, cs);
           addLocAnn(RESULT, getLocation(ccs, cs));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelSetPara",112, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelFromDecl ::= optFormalParameters DECORWORD 
    java_cup.runtime.Symbol case124(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ChannelDecl RESULT =null;/*3*/
		int ofpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int ofpright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZNameList ofp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
           RefExpr re = factory_.createRefExpr(createCircusName(dw));/*same as: FALSE, FALSE*/
           ZNameList znl = factory_.createZNameList();
           RESULT = factory_.createChannelDecl(factory_.list(ofp, znl), re);
           addLocAnn(RESULT, getLocation(ofp, dw.getLocation()));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelFromDecl",130, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelFromDecl ::= optFormalParameters DECORWORD genericActuals 
    java_cup.runtime.Symbol case123(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ChannelDecl RESULT =null;/*3*/
		int ofpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ofpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList ofp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int galeft = CUP$Parser$stack.peek().left;
		int garight = CUP$Parser$stack.peek().right;
		ZExprList ga = (ZExprList) CUP$Parser$stack.peek().value;
		
           // NOTE: channel from declarations does not allow decorated schema names!

           RefExpr re = factory_.createRefExpr(createCircusName(dw), ga, Boolean.FALSE, Boolean.TRUE);
           ZNameList znl = factory_.createZNameList();
           RESULT = factory_.createChannelDecl(factory_.list(ofp, znl), re);
           addLocAnn(RESULT, getLocation(ofp, ga));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelFromDecl",130, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelDecl ::= circusDeclWordList error END 
    java_cup.runtime.Symbol case122(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ChannelDecl RESULT =null;/*3*/
		int cdwlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cdwlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList cdwl = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
          parser.report_error(CircusParseMessage.MSG_CHANNEL_TYPE_ERROR,
                            new Object[0], getLocation(eleft, eright));
          ZNameList znl = factory_.createZNameList();
          RESULT = factory_.createChannelDecl(factory_.list(znl, cdwl), null);
          addLocAnn(RESULT, getLocation(cdwl.get(0), getLocation(eleft, eright)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelDecl",129, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelDecl ::= circusDeclWordList COLON error END 
    java_cup.runtime.Symbol case121(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ChannelDecl RESULT =null;/*3*/
		int cdwlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int cdwlright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		ZNameList cdwl = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int cleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo c = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
          parser.report_error(CircusParseMessage.MSG_CHANNEL_TYPE_ERROR,
                            new Object[0], getLocation(eleft, eright));
          ZNameList znl = factory_.createZNameList();
          RESULT = factory_.createChannelDecl(factory_.list(znl, cdwl), null);
          addLocAnn(RESULT, getLocation(cdwl.get(0), getLocation(eleft, eright)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelDecl",129, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelDecl ::= formalParameters circusDeclWordList error END 
    java_cup.runtime.Symbol case120(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ChannelDecl RESULT =null;/*3*/
		int fpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int fpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		ZNameList fp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int cdwlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cdwlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList cdwl = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
          parser.report_error(CircusParseMessage.MSG_CHANNEL_TYPE_ERROR,
                            new Object[0], getLocation(eleft, eright));
          RESULT = factory_.createChannelDecl(factory_.list(fp, cdwl), null);
          addLocAnn(RESULT, getLocation(fp, getLocation(eleft, eright)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelDecl",129, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelDecl ::= formalParameters circusDeclWordList COLON error END 
    java_cup.runtime.Symbol case119(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ChannelDecl RESULT =null;/*3*/
		int fpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int fpright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		ZNameList fp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int cdwlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int cdwlright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		ZNameList cdwl = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int cleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo c = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
          parser.report_error(CircusParseMessage.MSG_CHANNEL_TYPE_ERROR,
                            new Object[0], getLocation(eleft, eright));
          RESULT = factory_.createChannelDecl(factory_.list(fp, cdwl), null);
          addLocAnn(RESULT, getLocation(fp, getLocation(eleft, eright)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelDecl",129, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelDecl ::= nameList 
    java_cup.runtime.Symbol case118(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ChannelDecl RESULT =null;/*3*/
		int nlleft = CUP$Parser$stack.peek().left;
		int nlright = CUP$Parser$stack.peek().right;
		ZNameList nl = (ZNameList) CUP$Parser$stack.peek().value;
		
           // no generics for synchronisation channels.
           ZNameList znl = factory_.createZNameList();

           assert nl != null && !nl.isEmpty() : "Cannot have empty synch channel name list";
           RESULT = factory_.createChannelDecl(factory_.list(znl, nl),
              CircusUtils.SYNCH_CHANNEL_EXPR);
           addLocAnn(RESULT, getLocation(nl));
	/*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelDecl",129, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelDecl ::= circusDeclWordList COLON expression 
    java_cup.runtime.Symbol case117(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ChannelDecl RESULT =null;/*3*/
		int cdwlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cdwlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList cdwl = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
           ZNameList znl = factory_.createZNameList();
           RESULT = factory_.createChannelDecl(factory_.list(znl, cdwl), e);
           addLocAnn(RESULT, getLocation(cdwl.get(0), e));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelDecl",129, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelDecl ::= formalParameters circusDeclWordList COLON expression 
    java_cup.runtime.Symbol case116(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ChannelDecl RESULT =null;/*3*/
		int fpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int fpright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		ZNameList fp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int cdwlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cdwlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList cdwl = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createChannelDecl(factory_.list(fp, cdwl), e);
           addLocAnn(RESULT, getLocation(fp, e));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelDecl",129, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelFromDeclList ::= channelFromDecl 
    java_cup.runtime.Symbol case115(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<ChannelDecl> RESULT =null;/*3*/
		int cfdleft = CUP$Parser$stack.peek().left;
		int cfdright = CUP$Parser$stack.peek().right;
		ChannelDecl cfd = (ChannelDecl) CUP$Parser$stack.peek().value;
		
           assert cfd != null;
           RESULT = factory_.list(cfd);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelFromDeclList",127, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelFromDeclList ::= channelFromDeclList SEMICOLON channelFromDecl 
    java_cup.runtime.Symbol case114(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<ChannelDecl> RESULT =null;/*3*/
		int cfdlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cfdlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<ChannelDecl> cfdl = (List<ChannelDecl>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cfdleft = CUP$Parser$stack.peek().left;
		int cfdright = CUP$Parser$stack.peek().right;
		ChannelDecl cfd = (ChannelDecl) CUP$Parser$stack.peek().value;
		
           assert cfd != null && cfdl != null ;
           cfdl.add(cfd);
           RESULT = cfdl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelFromDeclList",127, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelDeclList ::= channelDecl 
    java_cup.runtime.Symbol case113(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<ChannelDecl> RESULT =null;/*3*/
		int cdleft = CUP$Parser$stack.peek().left;
		int cdright = CUP$Parser$stack.peek().right;
		ChannelDecl cd = (ChannelDecl) CUP$Parser$stack.peek().value;
		
           assert cd != null;
           RESULT = factory_.list(cd);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelDeclList",128, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelDeclList ::= channelDeclList SEMICOLON channelDecl 
    java_cup.runtime.Symbol case112(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<ChannelDecl> RESULT =null;/*3*/
		int cdlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cdlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<ChannelDecl> cdl = (List<ChannelDecl>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cdleft = CUP$Parser$stack.peek().left;
		int cdright = CUP$Parser$stack.peek().right;
		ChannelDecl cd = (ChannelDecl) CUP$Parser$stack.peek().value;
		
           assert cd != null && cdl != null;
           cdl.add(cd);
           RESULT = cdl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelDeclList",128, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelPara ::= CIRCCHANFROM error END 
    java_cup.runtime.Symbol case111(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int chanfleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int chanfright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo chanf = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           RESULT = factory_.createChannelPara(factory_.createZDeclList());
           addLocAnn(RESULT, getLocation(eleft, eright));
           parser.report_error(CircusParseMessage.MSG_CHANFROMDECL_ERROR,
              new Object[0], getLocation(eleft, eright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelPara",111, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelPara ::= CIRCCHAN error END 
    java_cup.runtime.Symbol case110(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int chanleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int chanright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo chan = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           RESULT = factory_.createChannelPara(factory_.createZDeclList());
           addLocAnn(RESULT, getLocation(eleft, eright));
           parser.report_error(CircusParseMessage.MSG_CHANDECL_ERROR,
              new Object[0], getLocation(eleft, eright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelPara",111, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelPara ::= CIRCCHANFROM channelFromDeclList 
    java_cup.runtime.Symbol case109(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int chanfleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int chanfright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo chanf = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int cfdlleft = CUP$Parser$stack.peek().left;
		int cfdlright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<ChannelDecl> cfdl = (List<ChannelDecl>) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createChannelPara(factory_.createZDeclList(cfdl));
           addLocAnn(RESULT, getLocation(chanf, cfdl.get(cfdl.size()-1)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelPara",111, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //channelPara ::= CIRCCHAN channelDeclList 
    java_cup.runtime.Symbol case108(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int chanleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int chanright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo chan = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int cdlleft = CUP$Parser$stack.peek().left;
		int cdlright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<ChannelDecl> cdl = (List<ChannelDecl>) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createChannelPara(factory_.createZDeclList(cdl));
           addLocAnn(RESULT, getLocation(chan, cdl.get(cdl.size()-1)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("channelPara",111, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusDeclWordList ::= DECLWORD 
    java_cup.runtime.Symbol case107(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZNameList RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
       ZName dn = createCircusName(dw);
       RESULT = factory_.createZNameList();
       RESULT.add(dn);
    /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusDeclWordList",145, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusDeclWordList ::= circusDeclWordList COMMA DECLWORD 
    java_cup.runtime.Symbol case106(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZNameList RESULT =null;/*3*/
		int cdwlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cdwlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList cdwl = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
       ZName dn = createCircusName(dw);
       cdwl.add(dn);
       RESULT = cdwl;
    /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusDeclWordList",145, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusInnerProcPara ::= actionRefPara 
    java_cup.runtime.Symbol case105(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int rpleft = CUP$Parser$stack.peek().left;
		int rpright = CUP$Parser$stack.peek().right;
		Para rp = (Para) CUP$Parser$stack.peek().value;
		
           RESULT = rp;
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("action refinement paragraph", getLocation(rp));
           parserState_.addLocallyDeclPara(RESULT);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusInnerProcPara",118, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusInnerProcPara ::= actionPara 
    java_cup.runtime.Symbol case104(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int apleft = CUP$Parser$stack.peek().left;
		int apright = CUP$Parser$stack.peek().right;
		ActionPara ap = (ActionPara) CUP$Parser$stack.peek().value;
		
           RESULT = ap;
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("action paragraph", getLocation(ap));

           // check whether this is already recorded as implicitly declared
           if (!parserState_.isImplicitlyDeclaredActionPara(ap)) {
               parserState_.addLocallyDeclPara(RESULT);
           }
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusInnerProcPara",118, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusInnerProcPara ::= namesetPara 
    java_cup.runtime.Symbol case103(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int npleft = CUP$Parser$stack.peek().left;
		int npright = CUP$Parser$stack.peek().right;
		Para np = (Para) CUP$Parser$stack.peek().value;
		
           RESULT = np;
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("name set paragraph", getLocation(np));
           parserState_.addLocallyDeclPara(RESULT);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusInnerProcPara",118, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusInnerProcPara ::= circusProcessState 
    java_cup.runtime.Symbol case102(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int cpsleft = CUP$Parser$stack.peek().left;
		int cpsright = CUP$Parser$stack.peek().right;
		Para cps = (Para) CUP$Parser$stack.peek().value;
		
           RESULT = cps;
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("process state", getLocation(cps));

           // no need to add to local paragraphs, see circusProcessState
           // production: state could be a local paragraph or implicitly declared
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusInnerProcPara",118, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusInnerProcPara ::= optFormalParameters CONJECTURE predicate 
    java_cup.runtime.Symbol case101(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int ofpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ofpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList ofp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int cright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo c = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		Pred p = (Pred) CUP$Parser$stack.peek().value;
		
           LocInfo loc = getLocation(c, p);
           RESULT = factory_.createConjPara(ofp, p);
           addLocAnn(RESULT, loc);
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("a local conjecture", loc);
           parserState_.addLocallyDeclPara(RESULT);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusInnerProcPara",118, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusInnerProcPara ::= THEOREM name optNL optFormalParameters CONJECTURE predicate 
    java_cup.runtime.Symbol case100(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int ofpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ofpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList ofp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int cright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo c = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		Pred p = (Pred) CUP$Parser$stack.peek().value;
		
           LocInfo loc = getLocation(c, p);
           RESULT = factory_.createConjPara(ofp, p);
           RESULT.getAnns().add(n); // add it as an annotation for now.
           addLocAnn(RESULT, loc);
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("a local named conjecture " + n, loc);
           parserState_.addLocallyDeclPara(RESULT);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusInnerProcPara",118, CUP$Parser$stack.elementAt(CUP$Parser$top-5), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusInnerProcPara ::= abbreviationDefinition 
    java_cup.runtime.Symbol case99(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int adleft = CUP$Parser$stack.peek().left;
		int adright = CUP$Parser$stack.peek().right;
		AxPara ad = (AxPara) CUP$Parser$stack.peek().value;
		
           RESULT = ad;
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("a local abbreviation", getLocation(ad));
           parserState_.addLocallyDeclPara(RESULT);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusInnerProcPara",118, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusInnerProcPara ::= freeTypeList 
    java_cup.runtime.Symbol case98(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int ftlleft = CUP$Parser$stack.peek().left;
		int ftlright = CUP$Parser$stack.peek().right;
		ZFreetypeList ftl = (ZFreetypeList) CUP$Parser$stack.peek().value;
		
           LocInfo loc = getLocation(ftl.get(0), ftl.get(ftl.size() - 1));
           RESULT = factory_.createFreePara(ftl);
           addLocAnn(RESULT, loc);
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("a local free type list", loc);
           parserState_.addLocallyDeclPara(RESULT);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusInnerProcPara",118, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusInnerProcPara ::= basicTypeDefinition 
    java_cup.runtime.Symbol case97(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int gtdleft = CUP$Parser$stack.peek().left;
		int gtdright = CUP$Parser$stack.peek().right;
		GivenPara gtd = (GivenPara) CUP$Parser$stack.peek().value;
		
            RESULT = gtd;
            // raise a scoping warning if needed
            addBasicProcessScopePostCheckFor("a local given set", getLocation(gtd));
            parserState_.addLocallyDeclPara(RESULT);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusInnerProcPara",118, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusInnerProcParaList ::= circusInnerProcPara 
    java_cup.runtime.Symbol case96(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Para> RESULT =null;/*3*/
		int ipleft = CUP$Parser$stack.peek().left;
		int ipright = CUP$Parser$stack.peek().right;
		Para ip = (Para) CUP$Parser$stack.peek().value;
		 RESULT = factory_.list(ip); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusInnerProcParaList",123, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusInnerProcParaList ::= circusInnerProcParaList NL circusInnerProcPara 
    java_cup.runtime.Symbol case95(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Para> RESULT =null;/*3*/
		int iplleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int iplright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Para> ipl = (List<Para>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int ipleft = CUP$Parser$stack.peek().left;
		int ipright = CUP$Parser$stack.peek().right;
		Para ip = (Para) CUP$Parser$stack.peek().value;
		
           if (ip != null) ipl.add(ip);
           RESULT = ipl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusInnerProcParaList",123, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //singleCircusParagraphItem ::= processRefPara 
    java_cup.runtime.Symbol case94(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int rpleft = CUP$Parser$stack.peek().left;
		int rpright = CUP$Parser$stack.peek().right;
		Para rp = (Para) CUP$Parser$stack.peek().value;
		 RESULT = rp; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("singleCircusParagraphItem",117, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //singleCircusParagraphItem ::= processPara 
    java_cup.runtime.Symbol case93(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int ppleft = CUP$Parser$stack.peek().left;
		int ppright = CUP$Parser$stack.peek().right;
		ProcessPara pp = (ProcessPara) CUP$Parser$stack.peek().value;
		 RESULT = pp; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("singleCircusParagraphItem",117, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //singleCircusParagraphItem ::= channelSetPara 
    java_cup.runtime.Symbol case92(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int cspleft = CUP$Parser$stack.peek().left;
		int cspright = CUP$Parser$stack.peek().right;
		Para csp = (Para) CUP$Parser$stack.peek().value;
		 RESULT = csp; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("singleCircusParagraphItem",117, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //singleCircusParagraphItem ::= channelPara 
    java_cup.runtime.Symbol case91(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int cpleft = CUP$Parser$stack.peek().left;
		int cpright = CUP$Parser$stack.peek().right;
		Para cp = (Para) CUP$Parser$stack.peek().value;
		 RESULT = cp; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("singleCircusParagraphItem",117, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //singleCircusParagraphItemList ::= singleCircusParagraphItem 
    java_cup.runtime.Symbol case90(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Para> RESULT =null;/*3*/
		int cpileft = CUP$Parser$stack.peek().left;
		int cpiright = CUP$Parser$stack.peek().right;
		Para cpi = (Para) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.list();

           
           // for implicitly declared processes, add the implicit decl first
           if (cpi instanceof ProcessPara)
           {
             addImplicitlyDeclaredProcPara(RESULT);
           }
           

           // This nullness result check is important for
           // consistency with the check above for lists.
           //
           // It is also important to avoid duplication
           // of Circus BasicPorcess declared across multiple
           // Circus environments.
           //
           // see unboxedParagraphItem
           if (cpi != null) {
             RESULT.add(cpi);
             logProductionResult(RESULT, "CIRCUS-PARAGRAPH-ITEM-SINGLE-ENV", getLocation(cpi));
           }
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("singleCircusParagraphItemList",121, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //singleCircusParagraphItemList ::= singleCircusParagraphItemList NL singleCircusParagraphItem 
    java_cup.runtime.Symbol case89(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Para> RESULT =null;/*3*/
		int cplleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int cplright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Para> cpl = (List<Para>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cpileft = CUP$Parser$stack.peek().left;
		int cpiright = CUP$Parser$stack.peek().right;
		Para cpi = (Para) CUP$Parser$stack.peek().value;
		
           if (cpi != null) cpl.add(cpi);
           RESULT = cpl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("singleCircusParagraphItemList",121, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusMultiEnvParagraphList ::= CIRCUSACTION circusBasicProcessMainAction END 
    java_cup.runtime.Symbol case88(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Para> RESULT =null;/*3*/
		int circleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int circright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo circ = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cbpmaleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int cbpmaright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		CircusAction cbpma = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int endleft = CUP$Parser$stack.peek().left;
		int endright = CUP$Parser$stack.peek().right;
		LocInfo end = (LocInfo) CUP$Parser$stack.peek().value;
		
            final String from = "JUST MAINACTION - MULTIPLE ENVIRONMENT";
            // If exit fails, a warning is mentioned, not an error,
            // exitBasicProcessScope(from, getLocation(circ, cbpma));

            // Result here is the current process that was on scope.
            RESULT = factory_.list();
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusMultiEnvParagraphList",122, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusMultiEnvParagraphList ::= CIRCUSACTION circusInnerProcParaList END 
    java_cup.runtime.Symbol case87(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Para> RESULT =null;/*3*/
		int circleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int circright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo circ = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int pplleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int pplright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<Para> ppl = (List<Para>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int endleft = CUP$Parser$stack.peek().left;
		int endright = CUP$Parser$stack.peek().right;
		LocInfo end = (LocInfo) CUP$Parser$stack.peek().value;
		
           ensureInnerProcParaListKnownInBasicProcessScope(ppl, "MULTIPLE ENV", getLocation(circ, end));

           // Result here does not matter. It will be collected later via ParserState
           RESULT = factory_.list();
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusMultiEnvParagraphList",122, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //circusMultiEnvParagraphList ::= CIRCUS singleCircusParagraphItemList END 
    java_cup.runtime.Symbol case86(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Para> RESULT =null;/*3*/
		int circleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int circright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo circ = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int pplleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int pplright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<Para> ppl = (List<Para>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int endleft = CUP$Parser$stack.peek().left;
		int endright = CUP$Parser$stack.peek().right;
		LocInfo end = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = ppl;
           //logProductionResult(RESULT, "CIRCUS-PARAGRAPH-ITEM-LIST", getLocation(circ, end));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("circusMultiEnvParagraphList",122, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //varg ::= ARG 
    java_cup.runtime.Symbol case85(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Operand RESULT =null;/*3*/
		int argleft = CUP$Parser$stack.peek().left;
		int argright = CUP$Parser$stack.peek().right;
		LocInfo arg = (LocInfo) CUP$Parser$stack.peek().value;
		 RESULT = factory_.createOperand(Boolean.FALSE); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("varg",31, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //templateTag ::= LISTARG 
    java_cup.runtime.Symbol case84(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Operand RESULT =null;/*3*/
		int listargleft = CUP$Parser$stack.peek().left;
		int listargright = CUP$Parser$stack.peek().right;
		LocInfo listarg = (LocInfo) CUP$Parser$stack.peek().value;
		 RESULT = factory_.createOperand(Boolean.TRUE); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("templateTag",32, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //templateTag ::= varg 
    java_cup.runtime.Symbol case83(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Operand RESULT =null;/*3*/
		int vleft = CUP$Parser$stack.peek().left;
		int vright = CUP$Parser$stack.peek().right;
		Operand v = (Operand) CUP$Parser$stack.peek().value;
		 RESULT = v; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("templateTag",32, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optWordOperandList ::= optWordOperandList templateTag DECORWORD 
    java_cup.runtime.Symbol case82(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Oper> RESULT =null;/*3*/
		int wlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int wlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Oper> wl = (List<Oper>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int tleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int tright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Operand t = (Operand) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int nleft = CUP$Parser$stack.peek().left;
		int nright = CUP$Parser$stack.peek().right;
		Decorword n = (Decorword) CUP$Parser$stack.peek().value;
		
           wl.add(t);
           wl.add(createOperator(n));
           RESULT = wl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optWordOperandList",30, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optWordOperandList ::= 
    java_cup.runtime.Symbol case81(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Oper> RESULT =null;/*3*/
		 RESULT = factory_.list(); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optWordOperandList",30, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //nofixTemplate ::= LPAREN DECORWORD optWordOperandList RPAREN 
    java_cup.runtime.Symbol case80(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Oper> RESULT =null;/*3*/
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Decorword n = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int olleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int olright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<Oper> ol = (List<Oper>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rpleft = CUP$Parser$stack.peek().left;
		int rpright = CUP$Parser$stack.peek().right;
		LocInfo rp = (LocInfo) CUP$Parser$stack.peek().value;
		
           if (ol.size() < 1) {
             parser.report_error(ZParseMessage.MSG_UNEXPECTED_TOKEN,
                                 new Object[] {"RPAREN"},
                                 getLocation(rpleft, rpright));
           }
           ol.add(0, createOperator(n));
           RESULT = ol;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("nofixTemplate",29, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //infixTemplate ::= LPAREN varg DECORWORD optWordOperandList varg RPAREN 
    java_cup.runtime.Symbol case79(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Oper> RESULT =null;/*3*/
		int v1left = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int v1right = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Operand v1 = (Operand) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		Decorword n = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int olleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int olright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Oper> ol = (List<Oper>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int v2left = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int v2right = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Operand v2 = (Operand) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           ol.add(0, createOperator(n));
           ol.add(0, v1);
           ol.add(v2);
           RESULT = ol;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("infixTemplate",28, CUP$Parser$stack.elementAt(CUP$Parser$top-5), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //postfixTemplate ::= LPAREN varg DECORWORD optWordOperandList RPAREN 
    java_cup.runtime.Symbol case78(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Oper> RESULT =null;/*3*/
		int vleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int vright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		Operand v = (Operand) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Decorword n = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int olleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int olright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<Oper> ol = (List<Oper>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		 
           ol.add(0, createOperator(n));
           ol.add(0, v);
           RESULT = ol;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("postfixTemplate",27, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //prefixTemplate ::= LPAREN POWER varg RPAREN 
    java_cup.runtime.Symbol case77(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Oper> RESULT =null;/*3*/
		int pleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int pright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo p = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int vleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int vright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Operand v = (Operand) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           RESULT = factory_.list(createOperator(ZString.POWER, p), v);
	/*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("prefixTemplate",26, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //prefixTemplate ::= LPAREN DECORWORD optWordOperandList varg RPAREN 
    java_cup.runtime.Symbol case76(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Oper> RESULT =null;/*3*/
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		Decorword n = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int olleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int olright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Oper> ol = (List<Oper>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int vleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int vright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Operand v = (Operand) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           ol.add(0, createOperator(n));
           ol.add(v);
           RESULT = ol;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("prefixTemplate",26, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //assoc ::= RIGHTASSOC 
    java_cup.runtime.Symbol case75(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Assoc RESULT =null;/*3*/
		 RESULT = Assoc.Right; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("assoc",33, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //assoc ::= LEFTASSOC 
    java_cup.runtime.Symbol case74(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Assoc RESULT =null;/*3*/
		 RESULT = Assoc.Left; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("assoc",33, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //catTemplate ::= nofixTemplate 
    java_cup.runtime.Symbol case73(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      OptempPara RESULT =null;/*3*/
		int ntleft = CUP$Parser$stack.peek().left;
		int ntright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Oper> nt = (List<Oper>) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createOptempPara();
           RESULT.getOper().addAll(nt);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("catTemplate",34, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //catTemplate ::= NUMERAL assoc infixTemplate 
    java_cup.runtime.Symbol case72(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      OptempPara RESULT =null;/*3*/
		int prleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int prright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInt pr = (LocInt) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int aleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int aright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Assoc a = (Assoc) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int itleft = CUP$Parser$stack.peek().left;
		int itright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Oper> it = (List<Oper>) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createOptempPara();
           RESULT.setPrec(pr.getValue());
           RESULT.getOper().addAll(it);
           RESULT.setAssoc(a);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("catTemplate",34, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //catTemplate ::= postfixTemplate 
    java_cup.runtime.Symbol case71(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      OptempPara RESULT =null;/*3*/
		int ptleft = CUP$Parser$stack.peek().left;
		int ptright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Oper> pt = (List<Oper>) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createOptempPara();
           RESULT.getOper().addAll(pt);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("catTemplate",34, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //catTemplate ::= prefixTemplate 
    java_cup.runtime.Symbol case70(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      OptempPara RESULT =null;/*3*/
		int ptleft = CUP$Parser$stack.peek().left;
		int ptright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Oper> pt = (List<Oper>) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createOptempPara();
           RESULT.getOper().addAll(pt);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("catTemplate",34, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //template ::= nofixTemplate 
    java_cup.runtime.Symbol case69(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Oper> RESULT =null;/*3*/
		int ntleft = CUP$Parser$stack.peek().left;
		int ntright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Oper> nt = (List<Oper>) CUP$Parser$stack.peek().value;
		 RESULT = nt; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("template",25, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //template ::= infixTemplate 
    java_cup.runtime.Symbol case68(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Oper> RESULT =null;/*3*/
		int itleft = CUP$Parser$stack.peek().left;
		int itright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Oper> it = (List<Oper>) CUP$Parser$stack.peek().value;
		 RESULT = it; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("template",25, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //template ::= postfixTemplate 
    java_cup.runtime.Symbol case67(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Oper> RESULT =null;/*3*/
		int ptleft = CUP$Parser$stack.peek().left;
		int ptright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Oper> pt = (List<Oper>) CUP$Parser$stack.peek().value;
		 RESULT = pt; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("template",25, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //template ::= prefixTemplate 
    java_cup.runtime.Symbol case66(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Oper> RESULT =null;/*3*/
		int ptleft = CUP$Parser$stack.peek().left;
		int ptright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Oper> pt = (List<Oper>) CUP$Parser$stack.peek().value;
		 RESULT = pt; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("template",25, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //operatorTemplate ::= GENERIC catTemplate 
    java_cup.runtime.Symbol case65(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      OptempPara RESULT =null;/*3*/
		int gleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int gright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo g = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int ctleft = CUP$Parser$stack.peek().left;
		int ctright = CUP$Parser$stack.peek().right;
		OptempPara ct = (OptempPara) CUP$Parser$stack.peek().value;
		
           ct.setCat(Cat.Generic);
           addLocAnn(ct, getLocation(gleft, gright));
           RESULT = ct;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("operatorTemplate",24, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //operatorTemplate ::= FUNCTION catTemplate 
    java_cup.runtime.Symbol case64(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      OptempPara RESULT =null;/*3*/
		int funleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int funright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo fun = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int ctleft = CUP$Parser$stack.peek().left;
		int ctright = CUP$Parser$stack.peek().right;
		OptempPara ct = (OptempPara) CUP$Parser$stack.peek().value;
		
           ct.setCat(Cat.Function);
           addLocAnn(ct, getLocation(funleft, funright));
           RESULT = ct;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("operatorTemplate",24, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //operatorTemplate ::= RELATION template 
    java_cup.runtime.Symbol case63(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      OptempPara RESULT =null;/*3*/
		int relleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int relright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo rel = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Oper> t = (List<Oper>) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createOptempPara();
           RESULT.getOper().addAll(t);
           RESULT.setCat(Cat.Relation);
           addLocAnn(RESULT, getLocation(relleft, relright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("operatorTemplate",24, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //narrWordList ::= TEXT 
    java_cup.runtime.Symbol case62(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<LocString> RESULT =null;/*3*/
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		LocString t = (LocString) CUP$Parser$stack.peek().value;
		 RESULT = factory_.list(t); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("narrWordList",23, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //narrWordList ::= narrWordList TEXT 
    java_cup.runtime.Symbol case61(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<LocString> RESULT =null;/*3*/
		int nwlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int nwlright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<LocString> nwl = (List<LocString>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int tleft = CUP$Parser$stack.peek().left;
		int tright = CUP$Parser$stack.peek().right;
		LocString t = (LocString) CUP$Parser$stack.peek().value;
		
           nwl.add(t);
           RESULT = nwl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("narrWordList",23, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //branch ::= declName LDATA expression RDATA 
    java_cup.runtime.Symbol case60(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Branch RESULT =null;/*3*/
		int dnleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int dnright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		Name dn = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Expr e = (Expr) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int rdataleft = CUP$Parser$stack.peek().left;
		int rdataright = CUP$Parser$stack.peek().right;
		LocInfo rdata = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createBranch(dn, e);
           addLocAnn(RESULT, getLocation(dn, rdata));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("branch",40, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //branch ::= declName 
    java_cup.runtime.Symbol case59(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Branch RESULT =null;/*3*/
		int dnleft = CUP$Parser$stack.peek().left;
		int dnright = CUP$Parser$stack.peek().right;
		Name dn = (Name) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createBranch(dn, null);
           addLocAnn(RESULT, getLocation(dn));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("branch",40, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //branchList ::= branch 
    java_cup.runtime.Symbol case58(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZBranchList RESULT =null;/*3*/
		int bleft = CUP$Parser$stack.peek().left;
		int bright = CUP$Parser$stack.peek().right;
		Branch b = (Branch) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createZBranchList();
           RESULT.add(b); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("branchList",39, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //branchList ::= branchList BAR branch 
    java_cup.runtime.Symbol case57(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZBranchList RESULT =null;/*3*/
		int blleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int blright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZBranchList bl = (ZBranchList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int bleft = CUP$Parser$stack.peek().left;
		int bright = CUP$Parser$stack.peek().right;
		Branch b = (Branch) CUP$Parser$stack.peek().value;
		
           bl.add(b);
           RESULT = bl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("branchList",39, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //freeTypeDefinition ::= name DEFFREE branchList 
    java_cup.runtime.Symbol case56(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Freetype RESULT =null;/*3*/
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int deffreeleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int deffreeright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo deffree = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int blleft = CUP$Parser$stack.peek().left;
		int blright = CUP$Parser$stack.peek().right;
		ZBranchList bl = (ZBranchList) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createFreetype(n, bl);
           addLocAnn(RESULT, getLocation(deffreeleft, deffreeright,
                                         n, bl.get(bl.size() - 1)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("freeTypeDefinition",22, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //freeTypeList ::= freeTypeDefinition 
    java_cup.runtime.Symbol case55(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZFreetypeList RESULT =null;/*3*/
		int ftdleft = CUP$Parser$stack.peek().left;
		int ftdright = CUP$Parser$stack.peek().right;
		Freetype ftd = (Freetype) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createZFreetypeList();
           RESULT.add(ftd); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("freeTypeList",21, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //freeTypeList ::= freeTypeList ANDALSO freeTypeDefinition 
    java_cup.runtime.Symbol case54(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZFreetypeList RESULT =null;/*3*/
		int ftlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ftlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZFreetypeList ftl = (ZFreetypeList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int ftdleft = CUP$Parser$stack.peek().left;
		int ftdright = CUP$Parser$stack.peek().right;
		Freetype ftd = (Freetype) CUP$Parser$stack.peek().value;
		
           ftl.add(ftd);
           RESULT = ftl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("freeTypeList",21, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //abbreviationDefinition ::= genName DEFEQUAL expression 
    java_cup.runtime.Symbol case53(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      AxPara RESULT =null;/*3*/
		int gnleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int gnright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") Pair<Name,ZNameList> gn = (Pair<Name,ZNameList>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int equalleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int equalright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo equal = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
           Name dn = gn.getFirst();
           LocInfo dnLoc = dn != null ?
             getLocation(dn) : getLocation(gnleft, gnright);
           ZNameList fp = gn.getSecond();
           ConstDecl cd = factory_.createConstDecl(dn, e);
           LocInfo eLoc = getLocation(e);
           addLocAnn(cd, getLocation(equalleft, equalright, dnLoc, eLoc));
           ZDeclList decls = factory_.createZDeclList();
           decls.add(cd);
           ZSchText st = factory_.createZSchText(decls, null);
           addLocAnn(st, getLocation(dnLoc, eLoc));
           RESULT = factory_.createAxPara(fp, st, Box.OmitBox);
           addLocAnn(RESULT, getLocation(dnLoc, eLoc));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("abbreviationDefinition",18, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //abbreviationDefinition ::= declName formalParameters DEFEQUAL expression 
    java_cup.runtime.Symbol case52(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      AxPara RESULT =null;/*3*/
		int dnleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int dnright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		Name dn = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int fpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int fpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList fp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int equalleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int equalright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo equal = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
           ConstDecl cd = factory_.createConstDecl(dn, e);
           addLocAnn(cd, getLocation(equalleft, equalright, dn, e));
           ZDeclList decls = factory_.createZDeclList();
           decls.add(cd);
           ZSchText st = factory_.createZSchText(decls, null);
           addLocAnn(st, getLocation(cd, e));
           RESULT = factory_.createAxPara(fp, st, Box.OmitBox);
           addLocAnn(RESULT, getLocation(dn, e));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("abbreviationDefinition",18, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //abbreviationDefinition ::= declName DEFEQUAL expression 
    java_cup.runtime.Symbol case51(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      AxPara RESULT =null;/*3*/
		int dnleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dnright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Name dn = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int equalleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int equalright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo equal = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		
           ConstDecl cd = factory_.createConstDecl(dn, e);
           addLocAnn(cd, getLocation(equalleft, equalright, dn, e));
           ZDeclList decls = factory_.createZDeclList();
           decls.add(cd);
           ZSchText st = factory_.createZSchText(decls, null);
           addLocAnn(st, getLocation(dn, e));
           ZNameList zdnl = factory_.createZNameList();
           RESULT = factory_.createAxPara(zdnl, st, Box.OmitBox);
           addLocAnn(RESULT, getLocation(dn, e));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("abbreviationDefinition",18, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //axiomaticDefinition ::= AX axiomaticSchemaText END 
    java_cup.runtime.Symbol case50(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      AxPara RESULT =null;/*3*/
		int axleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int axright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo ax = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int stleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int stright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		SchText st = (SchText) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int endleft = CUP$Parser$stack.peek().left;
		int endright = CUP$Parser$stack.peek().right;
		LocInfo end = (LocInfo) CUP$Parser$stack.peek().value;
		
           ZNameList zdnl = factory_.createZNameList();
           RESULT = factory_.createAxPara(zdnl, st, Box.AxBox);
           
           addLocAnn(RESULT, getLocation(ax, end));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("axiomaticDefinition",16, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //formalParameters ::= LSQUARE nameList RSQUARE optNL 
    java_cup.runtime.Symbol case49(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZNameList RESULT =null;/*3*/
		int nlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int nlright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList nl = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		 RESULT = nl; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("formalParameters",58, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optFormalParameters ::= 
    java_cup.runtime.Symbol case48(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZNameList RESULT =null;/*3*/
		 RESULT = factory_.createZNameList(); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optFormalParameters",59, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //optFormalParameters ::= formalParameters 
    java_cup.runtime.Symbol case47(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZNameList RESULT =null;/*3*/
		int fpleft = CUP$Parser$stack.peek().left;
		int fpright = CUP$Parser$stack.peek().right;
		ZNameList fp = (ZNameList) CUP$Parser$stack.peek().value;
		 RESULT = fp; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optFormalParameters",59, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //genericAxDefinition ::= GENAX formalParameters axiomaticSchemaText END 
    java_cup.runtime.Symbol case46(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      AxPara RESULT =null;/*3*/
		int genaxleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int genaxright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo genax = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int fpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int fpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList fp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int stleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int stright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		SchText st = (SchText) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int endleft = CUP$Parser$stack.peek().left;
		int endright = CUP$Parser$stack.peek().right;
		LocInfo end = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createAxPara(fp, st, Box.AxBox);
           
           addLocAnn(RESULT, getLocation(genax, end));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("genericAxDefinition",17, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //schema ::= GENSCH name optNL formalParameters schemaText END 
    java_cup.runtime.Symbol case45(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      AxPara RESULT =null;/*3*/
		int genschleft = CUP$Parser$stack.elementAt(CUP$Parser$top-5).left;
		int genschright = CUP$Parser$stack.elementAt(CUP$Parser$top-5).right;
		LocInfo gensch = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-5).value;
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int fpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int fpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList fp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int stleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int stright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		SchText st = (SchText) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int endleft = CUP$Parser$stack.peek().left;
		int endright = CUP$Parser$stack.peek().right;
		LocInfo end = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createSchema(n, fp, st);
           
           addLocAnn(RESULT, getLocation(gensch, end));
           //addZStateRefInfo(RESULT, ozsi, n);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("schema",19, CUP$Parser$stack.elementAt(CUP$Parser$top-5), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //schema ::= SCH name optNL schemaText END 
    java_cup.runtime.Symbol case44(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      AxPara RESULT =null;/*3*/
		int schleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int schright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		LocInfo sch = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int stleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int stright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		SchText st = (SchText) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int endleft = CUP$Parser$stack.peek().left;
		int endright = CUP$Parser$stack.peek().right;
		LocInfo end = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createSchema(n, null, st);
           
           addLocAnn(RESULT, getLocation(sch, end));
           //addZStateRefInfo(RESULT, ozsi, n);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("schema",19, CUP$Parser$stack.elementAt(CUP$Parser$top-4), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //basicTypeDefinition ::= LSQUARE nameList RSQUARE 
    java_cup.runtime.Symbol case43(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      GivenPara RESULT =null;/*3*/
		int lsqleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int lsqright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo lsq = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int nlleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int nlright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZNameList nl = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           RESULT = factory_.createGivenPara(nl);
           addLocAnn(RESULT, getLocation(lsqleft, lsqright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("basicTypeDefinition",57, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //conjecture ::= CONJECTURE 
    java_cup.runtime.Symbol case42(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Boolean RESULT =null;/*3*/
		int cleft = CUP$Parser$stack.peek().left;
		int cright = CUP$Parser$stack.peek().right;
		LocInfo c = (LocInfo) CUP$Parser$stack.peek().value;
		
          RESULT = true;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("conjecture",110, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //unboxedParagraphItem ::= operatorTemplate 
    java_cup.runtime.Symbol case41(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int otleft = CUP$Parser$stack.peek().left;
		int otright = CUP$Parser$stack.peek().right;
		OptempPara ot = (OptempPara) CUP$Parser$stack.peek().value;
		
           try {
             opTable_.add(ot);
           }
           catch (OpTable.OperatorException e) {
             //final Symbol token = new Symbol(Sym.ZED, otleft, otright);
             parser.report_error(ZParseMessage.MSG_CANNOT_ADD_OP,
                                 new Object[] { e.getMessage() },
                                 getLocation(otleft, otright));
           }
           RESULT = ot;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unboxedParagraphItem",14, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //unboxedParagraphItem ::= optFormalParameters CONJECTURE predicate 
    java_cup.runtime.Symbol case40(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int ofpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ofpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList ofp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int cright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		LocInfo c = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		Pred p = (Pred) CUP$Parser$stack.peek().value;
		
           // unnamed conjectures in Unicode, as in the Z standard.
           RESULT = factory_.createConjPara(ofp, p);
           addLocAnn(RESULT, getLocation(getLocation(ofpleft, ofpright), getLocation(p)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unboxedParagraphItem",14, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //unboxedParagraphItem ::= THEOREM name optNL optFormalParameters conjecture predicate 
    java_cup.runtime.Symbol case39(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int nleft = CUP$Parser$stack.elementAt(CUP$Parser$top-4).left;
		int nright = CUP$Parser$stack.elementAt(CUP$Parser$top-4).right;
		Name n = (Name) CUP$Parser$stack.elementAt(CUP$Parser$top-4).value;
		int ofpleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int ofpright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		ZNameList ofp = (ZNameList) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int cright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Boolean c = (Boolean) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		Pred p = (Pred) CUP$Parser$stack.peek().value;
		
           // named conjectures in Unicode are a CZT extension of the Z standard.
           RESULT = factory_.createConjPara(ofp, p);
           RESULT.getAnns().add(n); // add it as an annotation for now.
           LocInfo loc = getLocation(getLocation(ofpleft, ofpright), getLocation(p));
           
           addLocAnn(RESULT, loc);
           
           try
           {
             thmTable_.add((ConjPara)RESULT);
           }
           catch (ThmTable.ThmTableException e)
           {
             //final Symbol token = new Symbol(Sym.ZED, nleft, nright);
               parser.report_error(ZParseMessage.MSG_CANNOT_ADD_THM,
                                   new Object[] { e.getMessage() },
                                   getLocation(nleft, nright));
           }           
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unboxedParagraphItem",14, CUP$Parser$stack.elementAt(CUP$Parser$top-5), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //unboxedParagraphItem ::= freeTypeList 
    java_cup.runtime.Symbol case38(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int ftlleft = CUP$Parser$stack.peek().left;
		int ftlright = CUP$Parser$stack.peek().right;
		ZFreetypeList ftl = (ZFreetypeList) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createFreePara(ftl);
           addLocAnn(RESULT, getLocation(ftl.get(0), ftl.get(ftl.size() - 1)));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unboxedParagraphItem",14, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //unboxedParagraphItem ::= abbreviationDefinition 
    java_cup.runtime.Symbol case37(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int adleft = CUP$Parser$stack.peek().left;
		int adright = CUP$Parser$stack.peek().right;
		AxPara ad = (AxPara) CUP$Parser$stack.peek().value;
		 RESULT = ad; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unboxedParagraphItem",14, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //unboxedParagraphItem ::= basicTypeDefinition 
    java_cup.runtime.Symbol case36(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int btdleft = CUP$Parser$stack.peek().left;
		int btdright = CUP$Parser$stack.peek().right;
		GivenPara btd = (GivenPara) CUP$Parser$stack.peek().value;
		 RESULT = btd; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unboxedParagraphItem",14, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //unboxedParagraphItemList ::= unboxedParagraphItem 
    java_cup.runtime.Symbol case35(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Para> RESULT =null;/*3*/
		int uileft = CUP$Parser$stack.peek().left;
		int uiright = CUP$Parser$stack.peek().right;
		Para ui = (Para) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.list();

           
           // for implicitly declared processes, add the implicit decl first
           if (ui instanceof ProcessPara)
           {
             addImplicitlyDeclaredProcPara(RESULT);
           }
           

           // This nullness result check is important for
           // consistency with the check above for lists.
           //
           // It is also important to avoid duplication
           // of Circus BasicPorcess declared across multiple
           // Circus environments.
           if (ui != null) RESULT.add(ui);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unboxedParagraphItemList",12, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //unboxedParagraphItemList ::= unboxedParagraphItemList NL unboxedParagraphItem 
    java_cup.runtime.Symbol case34(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Para> RESULT =null;/*3*/
		int uilleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int uilright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Para> uil = (List<Para>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int uileft = CUP$Parser$stack.peek().left;
		int uiright = CUP$Parser$stack.peek().right;
		Para ui = (Para) CUP$Parser$stack.peek().value;
		
           if (ui != null) uil.add(ui);
           RESULT = uil;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unboxedParagraphItemList",12, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //unboxedParagraphList ::= ZED error END 
    java_cup.runtime.Symbol case33(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Para> RESULT =null;/*3*/
		int zleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int zright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo z = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           parser.report_syntax_error();
           RESULT = factory_.list();

        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unboxedParagraphList",11, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //unboxedParagraphList ::= ZED circusBasicProcessMainAction END 
    java_cup.runtime.Symbol case32(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Para> RESULT =null;/*3*/
		int zedleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int zedright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo zed = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int cbpmaleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int cbpmaright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		CircusAction cbpma = (CircusAction) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int endleft = CUP$Parser$stack.peek().left;
		int endright = CUP$Parser$stack.peek().right;
		LocInfo end = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.list();
           parser.report_error(CircusParseMessage.MSG_INVALID_CIRCUS_PARA_IN_ZED,
              new Object[] { "action level", "CIRCUSACTION" }, getLocation(zed, end));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unboxedParagraphList",11, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //unboxedParagraphList ::= ZED singleCircusParagraphItemList END 
    java_cup.runtime.Symbol case31(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Para> RESULT =null;/*3*/
		int zedleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int zedright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo zed = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int pplleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int pplright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<Para> ppl = (List<Para>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int endleft = CUP$Parser$stack.peek().left;
		int endright = CUP$Parser$stack.peek().right;
		LocInfo end = (LocInfo) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.list();
           parser.report_error(CircusParseMessage.MSG_INVALID_CIRCUS_PARA_IN_ZED,
              new Object[] { "process level", "CIRCUS" }, getLocation(zed, end));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unboxedParagraphList",11, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //unboxedParagraphList ::= ZED unboxedParagraphItemList END 
    java_cup.runtime.Symbol case30(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Para> RESULT =null;/*3*/
		int zedleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int zedright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		LocInfo zed = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int uilleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int uilright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<Para> uil = (List<Para>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int endleft = CUP$Parser$stack.peek().left;
		int endright = CUP$Parser$stack.peek().right;
		LocInfo end = (LocInfo) CUP$Parser$stack.peek().value;
		 if (uil.size() == 1) {
             addLocAnn(uil.get(0), getLocation(zed, end));
           }
             
             // for unboxed paragraphs for basic circus process added
             // across multiple circus LaTeX environments
             if (parserState_.isWithinMultipleEnvBasicProcessScope()) {
                String msg;
                LocInfo loc;
                boolean add;
                Iterator<Para> it = uil.iterator();
                while (it.hasNext()) {
                    Para para = it.next();
                    loc = getLocation(para);
                    add = ZUtils.isZPara(para);
                    if (para instanceof AxPara) {
                        AxPara p = (AxPara)para;
                        NameList nl = ZUtils.getAxParaGenFormals(p);
                        boolean hasGenerics = (nl != null &&
                            (nl instanceof ZNameList) &&
                            !((ZNameList)nl).isEmpty());
                        msg = "a local " +
                            (hasGenerics ? "generic " : "") +
                            (ZUtils.isSimpleSchema(p) ? "schema " :
                                (((AxPara)p).getBox().equals(Box.OmitBox) ?
                                    "horizontal definition " :
                                    "axiomatic definition ")
                            ) +
                            "paragraph";
                    } else if (para instanceof GivenPara) {
                        msg = "a local given set paragraph";
                    } else if (para instanceof FreePara) {
                        msg = "a local free type paragraph";
                    } else if (para instanceof ConjPara) {
                        msg = "a local conjecture paragraph";
                    } else if (para instanceof OptempPara) {
                        msg = "a local operator template paragraph";
                    } else {
                        msg = "an invalid local paragrph";
                        //assert parserState_.isZPara(para);
                        parser.report_error(CircusParseMessage.MSG_INVALID_INNER_PROCESS_PARA,
                            new Object[] { para.getClass().getSimpleName(), loc }, loc);
                    }
                    if (add) {
                        // raise a scoping warning if needed
                        addBasicProcessScopePostCheckFor("SINGLE ENV - " + msg, loc);
                        parserState_.addLocallyDeclPara(para);
                        it.remove();
                    }
                }
                it = null;
             }
           
           RESULT = uil;
           
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unboxedParagraphList",11, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //narrParagraph ::= narrWordList 
    java_cup.runtime.Symbol case29(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int nwlleft = CUP$Parser$stack.peek().left;
		int nwlright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<LocString> nwl = (List<LocString>) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createNarrPara(toStringList(nwl));
           addLocAnn(RESULT, getLocation(nwl));
           
           // If within a basic process keep the narr para within it.
           if (parserState_.isWithinMultipleEnvBasicProcessScope()) {
              // raise a scoping warning if needed
              addBasicProcessScopePostCheckFor("narrative paragraph", getLocation(nwl));
              parserState_.addLocallyDeclPara(RESULT);
           }
           
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("narrParagraph",15, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //boxedParagraph ::= error END 
    java_cup.runtime.Symbol case28(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int eleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int eright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Object e = (Object) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int edleft = CUP$Parser$stack.peek().left;
		int edright = CUP$Parser$stack.peek().right;
		LocInfo ed = (LocInfo) CUP$Parser$stack.peek().value;
		
          parser.report_syntax_error();
          
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boxedParagraph",13, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //boxedParagraph ::= genericAxDefinition 
    java_cup.runtime.Symbol case27(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int gdleft = CUP$Parser$stack.peek().left;
		int gdright = CUP$Parser$stack.peek().right;
		AxPara gd = (AxPara) CUP$Parser$stack.peek().value;
		 RESULT = gd; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boxedParagraph",13, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //boxedParagraph ::= schema 
    java_cup.runtime.Symbol case26(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int sleft = CUP$Parser$stack.peek().left;
		int sright = CUP$Parser$stack.peek().right;
		AxPara s = (AxPara) CUP$Parser$stack.peek().value;
		 RESULT = s; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boxedParagraph",13, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //boxedParagraph ::= axiomaticDefinition 
    java_cup.runtime.Symbol case25(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Para RESULT =null;/*3*/
		int adleft = CUP$Parser$stack.peek().left;
		int adright = CUP$Parser$stack.peek().right;
		AxPara ad = (AxPara) CUP$Parser$stack.peek().value;
		 RESULT = ad; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boxedParagraph",13, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paragraphList ::= 
    java_cup.runtime.Symbol case24(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZParaList RESULT =null;/*3*/
		 RESULT = factory_.createZParaList(); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paragraphList",10, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paragraphList ::= paragraphList narrParagraph 
    java_cup.runtime.Symbol case23(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZParaList RESULT =null;/*3*/
		int plleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int plright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZParaList pl = (ZParaList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int npleft = CUP$Parser$stack.peek().left;
		int npright = CUP$Parser$stack.peek().right;
		Para np = (Para) CUP$Parser$stack.peek().value;
		
           
           // If not within a basic process keep the narr para at section level
           if (!parserState_.isWithinMultipleEnvBasicProcessScope())
           
              pl.add(np);
           RESULT = pl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paragraphList",10, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paragraphList ::= paragraphList circusMultiEnvParagraphList 
    java_cup.runtime.Symbol case22(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZParaList RESULT =null;/*3*/
		int plleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int plright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZParaList pl = (ZParaList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int ucplleft = CUP$Parser$stack.peek().left;
		int ucplright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Para> ucpl = (List<Para>) CUP$Parser$stack.peek().value;
		
           //assert ucpl.isEmpty() : "Circus paragraph list from multiple environment must be empty. " +
           //    "Its members are stored within the parserState and collected when the basic process " +
           //    "scope is closed. If they appear dangling outside a scope, relevant warnings/errors " +
           //    "are raised accordingly. For this production, this s necessary in order to allow the " +
           //    "tokens to be consumed, even if stored indirectly as in here.";
           pl.addAll(ucpl);
           RESULT = pl;
           //logProductionResult(RESULT, "MULTIPLE-CIRCUS-PARAGRAPH-LIST", null);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paragraphList",10, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paragraphList ::= paragraphList unboxedParagraphList 
    java_cup.runtime.Symbol case21(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZParaList RESULT =null;/*3*/
		int plleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int plright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZParaList pl = (ZParaList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int uplleft = CUP$Parser$stack.peek().left;
		int uplright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Para> upl = (List<Para>) CUP$Parser$stack.peek().value;
		
           
           if (!parserState_.isWithinMultipleEnvBasicProcessScope())
           
              pl.addAll(upl);
           RESULT = pl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paragraphList",10, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //paragraphList ::= paragraphList boxedParagraph 
    java_cup.runtime.Symbol case20(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZParaList RESULT =null;/*3*/
		int plleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int plright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZParaList pl = (ZParaList) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		Para p = (Para) CUP$Parser$stack.peek().value;
		
           if (p != null) {
             
             // for boxed paragraphs for basic circus process added
             // across multiple circus LaTeX environments
             if (parserState_.isWithinMultipleEnvBasicProcessScope()) {
                LocInfo loc = getLocation(p);
                if (p instanceof AxPara) {
                    NameList nl = ZUtils.getAxParaGenFormals(p);
                    boolean hasGenerics = (nl != null &&
                        (nl instanceof ZNameList) &&
                        !((ZNameList)nl).isEmpty());
                    final String msg = "a local " +
                        (hasGenerics ? "generic " : "") +
                        (ZUtils.isSimpleSchema(p) ? "schema " :
                            (((AxPara)p).getBox().equals(Box.OmitBox) ?
                                "horizontal definition " :
                                "axiomatic definition ")
                        ) +
                        "paragraph";

                    // raise a scoping warning if needed
                    addBasicProcessScopePostCheckFor("MULTIPLE ENV - " + msg, getLocation(p));
                    parserState_.addLocallyDeclPara(p);
                } else {
                    //assert ZUtils.isZPara(para);
                    parser.report_error(CircusParseMessage.MSG_INVALID_INNER_PROCESS_PARA,
                        new Object[] { p.getClass().getSimpleName(), loc }, loc);
                }
             }
             // Only add to the list when not within a basic process
             else
             
                pl.add(p);
           }
           RESULT = pl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("paragraphList",10, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parentList ::= DECORWORD 
    java_cup.runtime.Symbol case19(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Parent> RESULT =null;/*3*/
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
           checkName(dw);
           Parent p = factory_.createParent(dw.getName());
           addLocAnn(p, dw.getLocation());
           RESULT = factory_.list(p);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parentList",8, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parentList ::= parentList COMMA DECORWORD 
    java_cup.runtime.Symbol case18(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Parent> RESULT =null;/*3*/
		int plleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int plright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		@SuppressWarnings("unchecked") List<Parent> pl = (List<Parent>) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int dwleft = CUP$Parser$stack.peek().left;
		int dwright = CUP$Parser$stack.peek().right;
		Decorword dw = (Decorword) CUP$Parser$stack.peek().value;
		
           checkName(dw);
           Parent p = factory_.createParent(dw.getName());
           addLocAnn(p, dw.getLocation());
           pl.add(p);
           RESULT = pl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parentList",8, CUP$Parser$stack.elementAt(CUP$Parser$top-2), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parents ::= PARENTS parentList 
    java_cup.runtime.Symbol case17(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Parent> RESULT =null;/*3*/
		int plleft = CUP$Parser$stack.peek().left;
		int plright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Parent> pl = (List<Parent>) CUP$Parser$stack.peek().value;
		 RESULT = pl; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parents",9, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parents ::= PARENTS 
    java_cup.runtime.Symbol case16(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Parent> RESULT =null;/*3*/
		 RESULT = factory_.list(); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parents",9, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //parents ::= 
    java_cup.runtime.Symbol case15(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Parent> RESULT =null;/*3*/
		 RESULT = factory_.list(); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parents",9, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //sectionHeader ::= SECTION DECORWORD parents END 
    java_cup.runtime.Symbol case14(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZSect RESULT =null;/*3*/
		int sleft = CUP$Parser$stack.elementAt(CUP$Parser$top-3).left;
		int sright = CUP$Parser$stack.elementAt(CUP$Parser$top-3).right;
		LocInfo s = (LocInfo) CUP$Parser$stack.elementAt(CUP$Parser$top-3).value;
		int dwleft = CUP$Parser$stack.elementAt(CUP$Parser$top-2).left;
		int dwright = CUP$Parser$stack.elementAt(CUP$Parser$top-2).right;
		Decorword dw = (Decorword) CUP$Parser$stack.elementAt(CUP$Parser$top-2).value;
		int pleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int pright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<Parent> p = (List<Parent>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		
           String name = dw.getName();
           checkName(dw);

			// add default parents only if given parents are empty
			// this includes explicitly given NON-PARENTS (i.e. SECTION name PARENTS _empty_ ; SECTION name).
			// in both cases we override to add default parents. 
			//
			// This is as prescribed by the Z Standard (see the Section production in Appendix C.3)
           if (p.isEmpty())
           {
			   // add to the set to avoid repetition of parents
	           //final Set<String> parentStrSet = defaultSP_.defaultParents(name);
	           final Set<Parent> parentSet = ZUtils.parentsAsSetOfParent(defaultSP_.defaultParents(name));
	           parentSet.addAll(p);
	           
	           // make it back into list of Parent cleared of duplicates
	           p.clear();
	           p.addAll(parentSet);
           }
		   
           // update the parsed section information
           startZSectTransaction(name);
           resetInfoTables(name, p, pleft, pright);
           RESULT = createZSect(name, p);

           parserState_.clearAllProcessInformation();

           addLocAnn(RESULT, s);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("sectionHeader",6, CUP$Parser$stack.elementAt(CUP$Parser$top-3), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //section ::= sectionHeader paragraphList 
    java_cup.runtime.Symbol case13(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZSect RESULT =null;/*3*/
		int headerleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int headerright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZSect header = (ZSect) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int plleft = CUP$Parser$stack.peek().left;
		int plright = CUP$Parser$stack.peek().right;
		ZParaList pl = (ZParaList) CUP$Parser$stack.peek().value;
		
           
               //logProductionResult(pl, "PARAGRAPH LIST AT SECTION", pl.isEmpty() ? null : getLocation(pl.get(0)));
           
           header.setParaList(pl);
           RESULT = endZSectTransaction(header, opTable_);
           if (pl.size() > 0) {
             Para plPara = pl.get(pl.size()-1);
             //logProductionResult(plPara, "PARAGRAPH LOCATION AT SECTION", getLocation(plPara));
             LocInfo loc = getLocation(plPara);
             LocAnn locAnn = (LocAnn) RESULT.getAnn(LocAnn.class);
             if (loc.getStart() >= 0 &&
                 loc.getLength() >= 0  &&
                 locAnn.getStart() != null) {
               final int length = loc.getStart() + loc.getLength()
                                  - locAnn.getStart().intValue();
               locAnn.setLength(BigInteger.valueOf(length));
             }
           }

           
               logProductionResult(pl, "SECTION[" + header.getName() + "]-PL", getLocation(RESULT));
               raisePendingBasicProcessWarnings("SECTION PRODUCTION");
           
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("section",3, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //sectionList ::= section 
    java_cup.runtime.Symbol case12(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Sect> RESULT =null;/*3*/
		int sleft = CUP$Parser$stack.peek().left;
		int sright = CUP$Parser$stack.peek().right;
		ZSect s = (ZSect) CUP$Parser$stack.peek().value;
		 RESULT = factory_.list((Sect) s); /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("sectionList",7, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //sectionList ::= sectionList section 
    java_cup.runtime.Symbol case11(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      List<Sect> RESULT =null;/*3*/
		int slleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int slright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		@SuppressWarnings("unchecked") List<Sect> sl = (List<Sect>) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int sleft = CUP$Parser$stack.peek().left;
		int sright = CUP$Parser$stack.peek().right;
		ZSect s = (ZSect) CUP$Parser$stack.peek().value;
		
           sl.add(s);
           RESULT = sl;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("sectionList",7, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //empty ::= 
    java_cup.runtime.Symbol case10(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZSect RESULT =null;/*3*/
		
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("empty",5, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //emptySectionHeader ::= empty 
    java_cup.runtime.Symbol case9(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      ZSect RESULT =null;/*3*/
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		ZSect e = (ZSect) CUP$Parser$stack.peek().value;
		
           // Apply Syntactic Transformation Rule 12.2.1.1
           final String name = Section.ANONYMOUS.getName();
           startZSectTransaction(name);
           final Set<String> parentSet = defaultSP_.defaultParents(name);
           final List<Parent> parents = ZUtils.parentsAsListOfParent(parentSet);
           resetInfoTables(name, parents, eleft, eright);
           RESULT = createZSect(name, parents);

           parserState_.clearAllProcessInformation();

           addLocAnn(RESULT, getLocation(eleft, eright));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("emptySectionHeader",4, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //specification ::= sectionList 
    java_cup.runtime.Symbol case8(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Spec RESULT =null;/*3*/
		int slleft = CUP$Parser$stack.peek().left;
		int slright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<Sect> sl = (List<Sect>) CUP$Parser$stack.peek().value;
		
           RESULT = createSpec(sl);
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("specification",1, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //specification ::= emptySectionHeader paragraphList 
    java_cup.runtime.Symbol case7(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Spec RESULT =null;/*3*/
		int headerleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int headerright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		ZSect header = (ZSect) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int plleft = CUP$Parser$stack.peek().left;
		int plright = CUP$Parser$stack.peek().right;
		ZParaList pl = (ZParaList) CUP$Parser$stack.peek().value;
		
           header.setParaList(pl);
           ZSect zSect = endZSectTransaction(header, opTable_);
           RESULT = createSpec(factory_.list(zSect));
           
               //logProductionResult(pl, "EMPTY-SECTION-HEADER", getLocation(RESULT));
               raisePendingBasicProcessWarnings("SPECIFICATION PRODUCTION");
           
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("specification",1, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //narrSect ::= narrWordList 
    java_cup.runtime.Symbol case6(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      NarrSect RESULT =null;/*3*/
		int nwlleft = CUP$Parser$stack.peek().left;
		int nwlright = CUP$Parser$stack.peek().right;
		@SuppressWarnings("unchecked") List<LocString> nwl = (List<LocString>) CUP$Parser$stack.peek().value;
		
           RESULT = factory_.createNarrSect(toStringList(nwl));
           addLocAnn(RESULT, getLocation(nwl));
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("narrSect",2, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //narrSect ::= 
    java_cup.runtime.Symbol case5(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      NarrSect RESULT =null;/*3*/
		
           RESULT = null;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("narrSect",2, CUP$Parser$stack.peek(), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //input ::= PRED predicate 
    java_cup.runtime.Symbol case4(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		Pred p = (Pred) CUP$Parser$stack.peek().value;
		 RESULT = p; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("input",0, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //input ::= EXPR expression 
    java_cup.runtime.Symbol case3(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int eleft = CUP$Parser$stack.peek().left;
		int eright = CUP$Parser$stack.peek().right;
		Expr e = (Expr) CUP$Parser$stack.peek().value;
		 RESULT = e; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("input",0, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //input ::= PARA boxedParagraph 
    java_cup.runtime.Symbol case2(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int pleft = CUP$Parser$stack.peek().left;
		int pright = CUP$Parser$stack.peek().right;
		Para p = (Para) CUP$Parser$stack.peek().value;
		 RESULT = p; /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("input",0, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //$START ::= input EOF 
    java_cup.runtime.Symbol case1(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Object RESULT =null;/*3*/
		int start_valleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int start_valright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		Term start_val = (Term) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		RESULT = start_val;/*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
    //input ::= narrSect specification 
    java_cup.runtime.Symbol case0(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      java_cup.runtime.Symbol CUP$Parser$result;
      Term RESULT =null;/*3*/
		int narrleft = CUP$Parser$stack.elementAt(CUP$Parser$top-1).left;
		int narrright = CUP$Parser$stack.elementAt(CUP$Parser$top-1).right;
		NarrSect narr = (NarrSect) CUP$Parser$stack.elementAt(CUP$Parser$top-1).value;
		int sleft = CUP$Parser$stack.peek().left;
		int sright = CUP$Parser$stack.peek().right;
		Spec s = (Spec) CUP$Parser$stack.peek().value;
		
           if (narr != null) {
             s.getSect().add(0, narr);
           }
           
               //logProductionResult(s, "SPECIFICATION AT INPUT", getLocation(s));
           
           RESULT = s;
        /*5*/
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("input",0, CUP$Parser$stack.elementAt(CUP$Parser$top-1), CUP$Parser$stack.peek(), RESULT); /*6*/
      return CUP$Parser$result;/*8*/

    }
}

