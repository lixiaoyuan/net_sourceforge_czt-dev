
/**
Copyright 2003 Mark Utting
This file is part of the czt project.

The czt project contains free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

The czt project is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with czt; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

package net.sourceforge.czt.z.util;

/**
 * An interface for commonly used Z characters.
 *
 * @author generated by XSL script zchar2stringclass.xsl
 */
public interface ZString
{


  /**
   * Greek capital letter delta.
   */
  String DELTA = String.valueOf(ZChar.DELTA);

  /**
   * Greek capital letter xi.
   */
  String XI = String.valueOf(ZChar.XI);

  /**
   * Greek small letter theta.
   */
  String THETA = String.valueOf(ZChar.THETA);

  /**
   * Greek small letter lambda.
   */
  String LAMBDA = String.valueOf(ZChar.LAMBDA);

  /**
   * Greek small letter mu.
   */
  String MU = String.valueOf(ZChar.MU);

  /**
   * arithmos, the set of all number-like objects.
   */
  String ARITHMOS = String.valueOf(ZChar.ARITHMOS);

  /**
   * the set of natural numbers (0..).
   */
  String NAT = String.valueOf(ZChar.NAT);

  /**
   * power set.
   */
  String POWER = String.valueOf(ZChar.POWER);

  /**
   * prime.
   */
  String PRIME = String.valueOf(ZChar.PRIME);

  /**
   * exclamation mark.
   */
  String OUTSTROKE = String.valueOf(ZChar.OUTSTROKE);

  /**
   * question mark.
   */
  String INSTROKE = String.valueOf(ZChar.INSTROKE);

  /**
   * north east arrow.
   */
  String NE = String.valueOf(ZChar.NE);

  /**
   * south west arrow.
   */
  String SW = String.valueOf(ZChar.SW);

  /**
   * south east arrow.
   */
  String SE = String.valueOf(ZChar.SE);

  /**
   * north west arrow.
   */
  String NW = String.valueOf(ZChar.NW);

  /**
   * low line.
   */
  String LL = String.valueOf(ZChar.LL);

  /**
   * left parenthesis.
   */
  String LPAREN = String.valueOf(ZChar.LPAREN);

  /**
   * right parenthesis.
   */
  String RPAREN = String.valueOf(ZChar.RPAREN);

  /**
   * left square bracket.
   */
  String LSQUARE = String.valueOf(ZChar.LSQUARE);

  /**
   * right square bracket.
   */
  String RSQUARE = String.valueOf(ZChar.RSQUARE);

  /**
   * left curly bracket.
   */
  String LBRACE = String.valueOf(ZChar.LBRACE);

  /**
   * right curly bracket.
   */
  String RBRACE = String.valueOf(ZChar.RBRACE);

  /**
   * left binding bracket.
   */
  String LBIND = String.valueOf(ZChar.LBIND);

  /**
   * right binding bracket.
   */
  String RBIND = String.valueOf(ZChar.RBIND);

  /**
   * left angle bracket for use in free type definitions.
   */
  String LDATA = String.valueOf(ZChar.LDATA);

  /**
   * left angle bracket for use in free type definitions.
   */
  String RDATA = String.valueOf(ZChar.RDATA);

  /**
   * start a Z paragraph.
   */
  String ZEDCHAR = String.valueOf(ZChar.ZEDCHAR);

  /**
   * start a Z axiomatic paragraph.
   */
  String AXCHAR = String.valueOf(ZChar.AXCHAR);

  /**
   * start a Z schema definition.
   */
  String SCHCHAR = String.valueOf(ZChar.SCHCHAR);

  /**
   * start a generic Z axiomatic paragraph.
   */
  String GENCHAR = String.valueOf(ZChar.GENCHAR);

  /**
   * end a Z paragraph.
   */
  String ENDCHAR = String.valueOf(ZChar.ENDCHAR);

  /**
   * line separator.
   */
  String NLCHAR = String.valueOf(ZChar.NLCHAR);

  /**
   * space.
   */
  String SPACE = String.valueOf(ZChar.SPACE);

  /**
   * vertical line.
   */
  String VL = String.valueOf(ZChar.VL);

  /**
   * ampersand.
   */
  String AMP = String.valueOf(ZChar.AMP);

  /**
   * conjecture.
   */
  String VDASH = String.valueOf(ZChar.VDASH);

  /**
   * logical and.
   */
  String AND = String.valueOf(ZChar.AND);

  /**
   * logical or.
   */
  String OR = String.valueOf(ZChar.OR);

  /**
   * logical implication.
   */
  String IMP = String.valueOf(ZChar.IMP);

  /**
   * logical equivalence.
   */
  String IFF = String.valueOf(ZChar.IFF);

  /**
   * logical negation.
   */
  String NOT = String.valueOf(ZChar.NOT);

  /**
   * for all.
   */
  String ALL = String.valueOf(ZChar.ALL);

  /**
   * there exists.
   */
  String EXI = String.valueOf(ZChar.EXI);

  /**
   * cartesian product.
   */
  String CROSS = String.valueOf(ZChar.CROSS);

  /**
   * solidus forward slash character.
   */
  String SOLIDUS = String.valueOf(ZChar.SOLIDUS);

  /**
   * equals sign.
   */
  String EQUALS = String.valueOf(ZChar.EQUALS);

  /**
   * element of.
   */
  String MEM = String.valueOf(ZChar.MEM);

  /**
   * colon.
   */
  String COLON = String.valueOf(ZChar.COLON);

  /**
   * semicolon.
   */
  String SEMICOLON = String.valueOf(ZChar.SEMICOLON);

  /**
   * comma.
   */
  String COMMA = String.valueOf(ZChar.COMMA);

  /**
   * full stop.
   */
  String DOT = String.valueOf(ZChar.DOT);

  /**
   * Z notation spot.
   */
  String SPOT = String.valueOf(ZChar.SPOT);

  /**
   * schema hiding.
   */
  String ZHIDE = String.valueOf(ZChar.ZHIDE);

  /**
   * schema projection.
   */
  String ZPROJ = String.valueOf(ZChar.ZPROJ);

  /**
   * schema composition.
   */
  String ZCOMP = String.valueOf(ZChar.ZCOMP);

  /**
   * schema piping.
   */
  String ZPIPE = String.valueOf(ZChar.ZPIPE);

  /**
   * plus sign.
   */
  String PLUS = String.valueOf(ZChar.PLUS);

  /**
   * Z notation type colon.
   */
  String TYPECOLON = String.valueOf(ZChar.TYPECOLON);

  /**
   * relation.
   */
  String REL = String.valueOf(ZChar.REL);

  /**
   * total function.
   */
  String FUN = String.valueOf(ZChar.FUN);

  /**
   * not equal to.
   */
  String NEQ = String.valueOf(ZChar.NEQ);

  /**
   * not an element of.
   */
  String NOTMEM = String.valueOf(ZChar.NOTMEM);

  /**
   * empty set.
   */
  String EMPTYSET = String.valueOf(ZChar.EMPTYSET);

  /**
   * subset of or equal to.
   */
  String SUBSETEQ = String.valueOf(ZChar.SUBSETEQ);

  /**
   * subset of.
   */
  String SUBSET = String.valueOf(ZChar.SUBSET);

  /**
   * union.
   */
  String CUP = String.valueOf(ZChar.CUP);

  /**
   * intersection.
   */
  String CAP = String.valueOf(ZChar.CAP);

  /**
   * set minus.
   */
  String SETMINUS = String.valueOf(ZChar.SETMINUS);

  /**
   * set symmetric difference.
   */
  String SYMDIFF = String.valueOf(ZChar.SYMDIFF);

  /**
   * n-ary union.
   */
  String BIGCUP = String.valueOf(ZChar.BIGCUP);

  /**
   * n-ary intersection.
   */
  String BIGCAP = String.valueOf(ZChar.BIGCAP);

  /**
   * finite set.
   */
  String FINSET = String.valueOf(ZChar.FINSET);

  /**
   * maplet, forms a pair.
   */
  String MAPSTO = String.valueOf(ZChar.MAPSTO);

  /**
   * relational composition.
   */
  String COMP = String.valueOf(ZChar.COMP);

  /**
   * functional composition.
   */
  String CIRC = String.valueOf(ZChar.CIRC);

  /**
   * domain restriction.
   */
  String DRES = String.valueOf(ZChar.DRES);

  /**
   * range restriction.
   */
  String RRES = String.valueOf(ZChar.RRES);

  /**
   * domain subtraction.
   */
  String NDRES = String.valueOf(ZChar.NDRES);

  /**
   * range subtraction.
   */
  String NRRES = String.valueOf(ZChar.NRRES);

  /**
   * relational inversion.
   */
  String TILDE = String.valueOf(ZChar.TILDE);

  /**
   * left relational image bracket.
   */
  String LIMG = String.valueOf(ZChar.LIMG);

  /**
   * right relational image bracket.
   */
  String RIMG = String.valueOf(ZChar.RIMG);

  /**
   * relational override.
   */
  String OPLUS = String.valueOf(ZChar.OPLUS);

  /**
   * partial function.
   */
  String PFUN = String.valueOf(ZChar.PFUN);

  /**
   * partial injective (1-1) function.
   */
  String PINJ = String.valueOf(ZChar.PINJ);

  /**
   * total injective (1-1) function.
   */
  String INJ = String.valueOf(ZChar.INJ);

  /**
   * partial surjective (onto) function.
   */
  String PSURJ = String.valueOf(ZChar.PSURJ);

  /**
   * total surjective (onto) function.
   */
  String SURJ = String.valueOf(ZChar.SURJ);

  /**
   * bijective (1-1 and onto) function.
   */
  String BIJ = String.valueOf(ZChar.BIJ);

  /**
   * finite function.
   */
  String FFUN = String.valueOf(ZChar.FFUN);

  /**
   * finite injective function.
   */
  String FINJ = String.valueOf(ZChar.FINJ);

  /**
   * set of integers.
   */
  String NUM = String.valueOf(ZChar.NUM);

  /**
   * prefix numeric negation.
   */
  String NEG = String.valueOf(ZChar.NEG);

  /**
   * infix minus sign.
   */
  String MINUS = String.valueOf(ZChar.MINUS);

  /**
   * less-than or equal to.
   */
  String LEQ = String.valueOf(ZChar.LEQ);

  /**
   * less-than sign.
   */
  String LESS = String.valueOf(ZChar.LESS);

  /**
   * greater-than or equal to.
   */
  String GEQ = String.valueOf(ZChar.GEQ);

  /**
   * greater-than sign.
   */
  String GREATER = String.valueOf(ZChar.GREATER);

  /**
   * asterisk (multiplication sign).
   */
  String MULT = String.valueOf(ZChar.MULT);

  /**
   * set cardinality.
   */
  String NUMBER = String.valueOf(ZChar.NUMBER);

  /**
   * left sequence bracket.
   */
  String LANGLE = String.valueOf(ZChar.LANGLE);

  /**
   * right sequence bracket.
   */
  String RANGLE = String.valueOf(ZChar.RANGLE);

  /**
   * sequence concatenation.
   */
  String CAT = String.valueOf(ZChar.CAT);

  /**
   * domain restriction for sequences.
   */
  String EXTRACT = String.valueOf(ZChar.EXTRACT);

  /**
   * range restriction for sequences.
   */
  String FILTER = String.valueOf(ZChar.FILTER);
  String SUB1 = SE + "1" + NW;
  String SUP1 = NE + "1" + SW;
  String ZED = ZEDCHAR;
  String AX = AXCHAR;
  String SCH = SCHCHAR;
  String GENAX = AXCHAR + GENCHAR;
  String GENSCH = SCHCHAR + GENCHAR;
  String END = ENDCHAR;
  String NL = NLCHAR;
  String CONJECTURE = VDASH + "?";
  String EXIONE = EXI + SUB1;

  String ELSE = "else";
  String FALSE = "false";
  String FUNCTION = "function";
  String GENERIC = "generic";
  String IF = "if";
  String LEFTASSOC = "leftassoc";
  String LET = "let";
  String PARENTS = "parents";
  String PRE = "pre";
  String RELATION = "relation";
  String RIGHTASSOC = "rightassoc";
  String SECTION = "section";
  String THEN = "then";
  String THEOREM = "theorem";
  String TRUE = "true";
  String DEFEQUAL = "==";
  String DEFFREE = "::=";
  String BAR = "|";
  String ANDALSO = AMP;
  String SLASH = "/";
  String SEMI = SEMICOLON;
  String ARG = LL;
  String LISTARG = ",,";

/*
  String ZSTATE       = "zstate";
  String ZSTINIT      = "zstinit";
  String ZSTFIN       = "zstfin";
  String ZRETRIEVE    = "zretrieve";

  String ZAINITIN     = "zainitin";
  String ZAFINOUT     = "zafinout";
  String ZCINITIN     = "zcinitin";
  String ZCFINOUT     = "zcfinout";
  String ZRETRIEVEIN  = "zretrievein";
  String ZRETRIEVEOUT = "zretrieveout";
*/

  /**
   * The separator that is used when representing operators as strings
   * to separate names and arguments.
   */
  String OP_SEPARATOR = SPACE;

  /** When a list of operator tokens is represented as a string,
      ARG_TOK stands for an EXPRESSION argument. For example,
      the Latex input A+B is represented by the operator
      name " _ + _ " applied to the tuple (A,B).
  */
  String ARG_TOK = OP_SEPARATOR + ARG + OP_SEPARATOR;

  /** When a list of operator tokens is represented as a string,
      LISTARG_TOK stands for an EXPRESSION-LIST argument. For example,
      the Latex input \langle A,B,C \rangle is represented by the operator
      name "< ,, >" (where < is actually the unicode char u27E8,
      and > is the unicode char u27E9), applied to the A,B,C list
      (which is actually represented as the set {(1,A),(2,B),(3,C)}).
  */
  String LISTARG_TOK = OP_SEPARATOR + LISTARG + OP_SEPARATOR;
}
